From 6b84c48343de5a89546cf6c7cd953fbbea011e86 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Thu, 19 Aug 2021 17:38:29 +0200
Subject: [PATCH 14/40] WIP: soc: apple: rtkit: Add RTKit library

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/soc/Kconfig             |   1 +
 drivers/soc/Makefile            |   1 +
 drivers/soc/apple/Kconfig       |  17 +
 drivers/soc/apple/Makefile      |   3 +
 drivers/soc/apple/apple-rtkit.c | 645 ++++++++++++++++++++++++++++++++
 include/linux/apple-rtkit.h     | 152 ++++++++
 6 files changed, 819 insertions(+)
 create mode 100644 drivers/soc/apple/Kconfig
 create mode 100644 drivers/soc/apple/Makefile
 create mode 100644 drivers/soc/apple/apple-rtkit.c
 create mode 100644 include/linux/apple-rtkit.h

diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index e8a30c4c5aec..a8562678c437 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -3,6 +3,7 @@ menu "SOC (System On Chip) specific Drivers"
 
 source "drivers/soc/actions/Kconfig"
 source "drivers/soc/amlogic/Kconfig"
+source "drivers/soc/apple/Kconfig"
 source "drivers/soc/aspeed/Kconfig"
 source "drivers/soc/atmel/Kconfig"
 source "drivers/soc/bcm/Kconfig"
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index a05e9fbcd3e0..adb30c2d4fea 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -4,6 +4,7 @@
 #
 
 obj-$(CONFIG_ARCH_ACTIONS)	+= actions/
+obj-$(CONFIG_ARCH_APPLE)	+= apple/
 obj-y				+= aspeed/
 obj-$(CONFIG_ARCH_AT91)		+= atmel/
 obj-y				+= bcm/
diff --git a/drivers/soc/apple/Kconfig b/drivers/soc/apple/Kconfig
new file mode 100644
index 000000000000..778745219d9f
--- /dev/null
+++ b/drivers/soc/apple/Kconfig
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-only
+if ARCH_APPLE || COMPILE_TEST
+menu "Apple SoC drivers"
+
+config APPLE_RTKIT
+	bool "Apple RTKit co-processor IPC protocol"
+	depends on ARCH_APPLE || COMPILE_TEST
+	default ARCH_APPLE
+	help
+	  Apple SoCs such as the M1 come with various co-processors running
+	  their proprietary RTKit operating system. This option enables support
+	  for the common IPC protocl used by these.
+
+	  Say 'y' here if you have an Apple SoC.
+
+endmenu
+endif
diff --git a/drivers/soc/apple/Makefile b/drivers/soc/apple/Makefile
new file mode 100644
index 000000000000..be42b7f7519d
--- /dev/null
+++ b/drivers/soc/apple/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_APPLE_RTKIT) += apple-rtkit.o
diff --git a/drivers/soc/apple/apple-rtkit.c b/drivers/soc/apple/apple-rtkit.c
new file mode 100644
index 000000000000..086ebcf2e2f2
--- /dev/null
+++ b/drivers/soc/apple/apple-rtkit.c
@@ -0,0 +1,645 @@
+// SPDX-License-Identifier: GPL-2.0-only OR MIT
+
+#include <linux/apple-rtkit.h>
+#include <linux/apple-mailbox.h>
+#include <linux/bitfield.h>
+#include <linux/bitmap.h>
+#include <linux/completion.h>
+#include <linux/kthread.h>
+#include <linux/kfifo.h>
+#include <linux/dma-mapping.h>
+#include <linux/mailbox_client.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+
+#define rtk_err(format, arg...) dev_err(rtk->dev, "RTKit: " format, ##arg)
+#define rtk_warn(format, arg...) dev_warn(rtk->dev, "RTKit: " format, ##arg)
+#define rtk_info(format, arg...) dev_info(rtk->dev, "RTKit: " format, ##arg)
+#define rtk_dbg(format, arg...) dev_dbg(rtk->dev, "RTKit: " format, ##arg)
+
+struct apple_rtkit_shmem {
+	void *buffer;
+	void __iomem *iomem;
+	size_t size;
+	dma_addr_t iova;
+};
+
+enum { APPLE_RTKIT_STATE_INIT,
+       APPLE_RTKIT_STATE_BOOTING,
+       APPLE_RTKIT_STATE_RUNNING,
+       APPLE_RTKIT_STATE_BOOT_FAILED,
+};
+
+struct apple_rtkit {
+	void *cookie;
+	const struct apple_rtkit_ops *ops;
+	struct device *dev;
+	void __iomem *regs;
+	struct mbox_client mbox_cl;
+	struct mbox_chan *mbox_chan;
+	struct completion boot_completion;
+	unsigned state;
+	int boot_result;
+	int version;
+
+	struct wait_queue_head wq;
+	DECLARE_KFIFO(msg_fifo, struct apple_mbox_msg, 64);
+
+	DECLARE_BITMAP(endpoints, 0x100);
+
+	struct apple_rtkit_shmem ioreport_buffer;
+	struct apple_rtkit_shmem crashlog_buffer;
+
+	struct apple_rtkit_shmem syslog_buffer;
+	char *syslog_msg_buffer;
+	size_t syslog_n_entries;
+	size_t syslog_msg_size;
+};
+
+#define APPLE_RTKIT_CPU_CONTROL 0x44
+#define APPLE_RTKIT_CPU_CONTROL_RUN BIT(4)
+
+#define APPLE_RTKIT_EP_MGMT 0
+#define APPLE_RTKIT_EP_CRASHLOG 1
+#define APPLE_RTKIT_EP_SYSLOG 2
+#define APPLE_RTKIT_EP_DEBUG 3
+#define APPLE_RTKIT_EP_IOREPORT 4
+
+#define APPLE_RTKIT_MGMT_WAKEUP 0x60000000000220
+
+#define APPLE_RTKIT_MGMT_TYPE GENMASK(59, 52)
+
+#define APPLE_RTKIT_MGMT_HELLO 1
+#define APPLE_RTKIT_MGMT_HELLO_REPLY 2
+#define APPLE_RTKIT_MGMT_HELLO_MINVER GENMASK(15, 0)
+#define APPLE_RTKIT_MGMT_HELLO_MAXVER GENMASK(31, 16)
+
+#define APPLE_RTKIT_MGMT_EPMAP 8
+#define APPLE_RTKIT_MGMT_EPMAP_LAST BIT(51)
+#define APPLE_RTKIT_MGMT_EPMAP_BASE GENMASK(34, 32)
+#define APPLE_RTKIT_MGMT_EPMAP_BITMAP GENMASK(31, 0)
+
+#define APPLE_RTKIT_MGMT_EPMAP_REPLY 8
+#define APPLE_RTKIT_MGMT_EPMAP_REPLY_MORE BIT(0)
+
+#define APPLE_RTKIT_MGMT_STARTEP 5
+#define APPLE_RTKIT_MGMT_STARTEP_EP GENMASK(39, 32)
+#define APPLE_RTKIT_MGMT_STARTEP_FLAG BIT(1)
+
+#define APPLE_RTKIT_MGMT_BOOT_DONE 7
+#define APPLE_RTKIT_MGMT_BOOT_DONE_UNK GENMASK(15, 0)
+
+#define APPLE_RTKIT_MGMT_BOOT_DONE2 0xb
+
+#define APPLE_RTKIT_CRASHLOG_CRASH 1
+
+#define APPLE_RTKIT_BUFFER_REQUEST 1
+#define APPLE_RTKIT_BUFFER_REQUEST_SIZE GENMASK(51, 44)
+#define APPLE_RTKIT_BUFFER_REQUEST_IOVA GENMASK(41, 0)
+
+#define APPLE_RTKIT_SYSLOG_TYPE GENMASK(59, 52)
+
+#define APPLE_RTKIT_SYSLOG_LOG 5
+
+#define APPLE_RTKIT_SYSLOG_INIT 8
+#define APPLE_RTKIT_SYSLOG_N_ENTRIES GENMASK(7, 0)
+#define APPLE_RTKIT_SYSLOG_MSG_SIZE GENMASK(31, 24)
+
+#define APPLE_RTKIT_MIN_SUPPORTED_VERSION 11
+#define APPLE_RTKIT_MAX_SUPPORTED_VERSION 12
+
+static void apple_rtkit_boot_abort(struct apple_rtkit *rtk, int res)
+{
+	WARN_ON(rtk->state != APPLE_RTKIT_STATE_BOOTING);
+	rtk->state = APPLE_RTKIT_STATE_BOOT_FAILED;
+	rtk->boot_result = res;
+	mbox_free_channel(rtk->mbox_chan);
+	complete(&rtk->boot_completion);
+}
+
+static void apple_rtkit_management_send(struct apple_rtkit *rtk, u8 type,
+					u64 msg)
+{
+	msg &= ~APPLE_RTKIT_MGMT_TYPE;
+	msg |= FIELD_PREP(APPLE_RTKIT_MGMT_TYPE, type);
+	apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_MGMT, msg);
+}
+
+static void apple_rtkit_management_rx_hello(struct apple_rtkit *rtk, u64 msg)
+{
+	u64 reply;
+
+	int min_ver = FIELD_GET(APPLE_RTKIT_MGMT_HELLO_MINVER, msg);
+	int max_ver = FIELD_GET(APPLE_RTKIT_MGMT_HELLO_MAXVER, msg);
+	int want_ver = min(APPLE_RTKIT_MAX_SUPPORTED_VERSION, max_ver);
+
+	rtk_dbg("Min ver %d, max ver %d\n", min_ver, max_ver);
+
+	if (min_ver > APPLE_RTKIT_MAX_SUPPORTED_VERSION) {
+		rtk_err("Firmware min version %d is too new\n", min_ver);
+		apple_rtkit_boot_abort(rtk, -ENOTSUPP);
+		return;
+	}
+
+	if (max_ver < APPLE_RTKIT_MIN_SUPPORTED_VERSION) {
+		rtk_err("Firmware max version %d is too old\n", max_ver);
+		apple_rtkit_boot_abort(rtk, -ENOTSUPP);
+		return;
+	}
+
+	rtk_info("Initializing (protocol version %d)\n", want_ver);
+	rtk->version = want_ver;
+
+	reply = FIELD_PREP(APPLE_RTKIT_MGMT_HELLO_MINVER, want_ver) |
+		FIELD_PREP(APPLE_RTKIT_MGMT_HELLO_MAXVER, want_ver);
+
+	apple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_HELLO_REPLY, reply);
+}
+
+static void apple_rtkit_management_rx_epmap(struct apple_rtkit *rtk, u64 msg)
+{
+	int i, ep;
+	u64 reply;
+
+	for (i = 0; i < 32; ++i) {
+		u32 bitmap = FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BITMAP, msg);
+		u32 base = FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BASE, msg);
+		if (bitmap & BIT(i))
+			set_bit(32 * base + i, rtk->endpoints);
+	}
+
+	reply = FIELD_PREP(APPLE_RTKIT_MGMT_EPMAP_BASE,
+			   FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BASE, msg));
+	if (msg & APPLE_RTKIT_MGMT_EPMAP_LAST)
+		reply |= APPLE_RTKIT_MGMT_EPMAP_LAST;
+	else
+		reply |= APPLE_RTKIT_MGMT_EPMAP_REPLY_MORE;
+
+	apple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_EPMAP_REPLY, reply);
+
+	if (msg & APPLE_RTKIT_MGMT_EPMAP_LAST) {
+		for_each_set_bit (ep, rtk->endpoints, 0x100) {
+			switch (ep) {
+			/* the management endpoint is started by default */
+			case APPLE_RTKIT_EP_MGMT:
+				break;
+
+			/*
+                         * we need to start at least these system endpoints or
+                         * RTKit refuses to boot
+                         */
+			case APPLE_RTKIT_EP_SYSLOG:
+			case APPLE_RTKIT_EP_CRASHLOG:
+			case APPLE_RTKIT_EP_DEBUG:
+			case APPLE_RTKIT_EP_IOREPORT:
+				apple_rtkit_start_ep(rtk, ep);
+				break;
+
+			/*
+                         * everything above 0x20 is an app-specific endpoint
+                         * which can be started later by the driver itself
+                         */
+			case 0x20 ... 0xff:
+				break;
+
+			default:
+				rtk_warn("Unknown system ep: %d\n", ep);
+			}
+		}
+	}
+}
+
+static void apple_rtkit_management_rx_boot_done(struct apple_rtkit *rtk,
+						u64 msg)
+{
+	u64 reply;
+	reply = FIELD_PREP(APPLE_RTKIT_MGMT_BOOT_DONE_UNK, 0x20);
+	apple_rtkit_management_send(rtk, 0xb, reply);
+}
+
+static void apple_rtkit_management_rx_boot_done2(struct apple_rtkit *rtk,
+						 u64 msg)
+{
+	rtk->state = APPLE_RTKIT_STATE_RUNNING;
+	complete_all(&rtk->boot_completion);
+	rtk_info("system endpoints successfuly initialized!");
+}
+
+static void apple_rtkit_management_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_MGMT_TYPE, msg);
+
+	switch (type) {
+	case APPLE_RTKIT_MGMT_HELLO:
+		apple_rtkit_management_rx_hello(rtk, msg);
+		break;
+	case APPLE_RTKIT_MGMT_EPMAP:
+		apple_rtkit_management_rx_epmap(rtk, msg);
+		break;
+	case APPLE_RTKIT_MGMT_BOOT_DONE:
+		apple_rtkit_management_rx_boot_done(rtk, msg);
+		break;
+	case APPLE_RTKIT_MGMT_BOOT_DONE2:
+		apple_rtkit_management_rx_boot_done2(rtk, msg);
+		break;
+	}
+}
+
+static void
+apple_rtkit_common_rx_get_buffer_linux(struct apple_rtkit *rtk,
+				       struct apple_rtkit_shmem *buffer, u8 ep,
+				       u64 msg)
+{
+	size_t size = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_SIZE, msg) << 12;
+	dma_addr_t iova = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_IOVA, msg);
+	u64 reply;
+
+	rtk_dbg("DMA buffer request for 0x%zx bytes\n", size);
+
+	if (rtk->ops->shmem_alloc)
+		buffer->buffer = rtk->ops->shmem_alloc(rtk->cookie, size, &iova,
+						       GFP_KERNEL);
+	else
+		buffer->buffer =
+			dma_alloc_coherent(rtk->dev, size, &iova, GFP_KERNEL);
+
+	if (!buffer->buffer) {
+		rtk_warn("couldn't allocate 0x%zx bytes.\n", size);
+		apple_rtkit_boot_abort(rtk, -ENOMEM);
+		return;
+	}
+
+	buffer->size = size;
+	buffer->iova = iova;
+
+	reply = FIELD_PREP(APPLE_RTKIT_SYSLOG_TYPE, APPLE_RTKIT_BUFFER_REQUEST);
+	reply |=
+		FIELD_PREP(APPLE_RTKIT_BUFFER_REQUEST_SIZE, buffer->size >> 12);
+	reply |= FIELD_PREP(APPLE_RTKIT_BUFFER_REQUEST_IOVA, buffer->iova);
+	apple_rtkit_send_message(rtk, ep, reply);
+}
+
+static void
+apple_rtkit_common_rx_get_buffer_rtkit(struct apple_rtkit *rtk,
+				       struct apple_rtkit_shmem *buffer, u8 ep,
+				       u64 msg)
+{
+	size_t size = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_SIZE, msg) << 12;
+	dma_addr_t iova = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_IOVA, msg);
+
+	rtk_dbg("shmem buffer request for 0x%zx bytes at 0x%llx\n", size, iova);
+
+	buffer->size = size;
+	buffer->iova = iova;
+	buffer->iomem = rtk->ops->shmem_map(rtk->cookie, iova, size);
+
+	if (!buffer->iomem) {
+		buffer->size = 0;
+		buffer->iova = 0;
+		rtk_warn("failed to map 0x%zx bytes at 0x%llx\n", size, iova);
+		apple_rtkit_boot_abort(rtk, -ENOMEM);
+	}
+}
+
+static void apple_rtkit_common_rx_get_buffer(struct apple_rtkit *rtk,
+					     struct apple_rtkit_shmem *buffer,
+					     u8 ep, u64 msg)
+{
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT)
+		return apple_rtkit_common_rx_get_buffer_rtkit(rtk, buffer, ep,
+							      msg);
+	else if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_LINUX)
+		return apple_rtkit_common_rx_get_buffer_linux(rtk, buffer, ep,
+							      msg);
+}
+
+static void apple_rtkit_crashlog_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);
+
+	if (type != APPLE_RTKIT_CRASHLOG_CRASH) {
+		rtk_warn("Unknown crashlog message: %llx\n", msg);
+		return;
+	}
+
+	if (!rtk->crashlog_buffer.size)
+		return apple_rtkit_common_rx_get_buffer(rtk,
+							&rtk->crashlog_buffer,
+							APPLE_RTKIT_EP_CRASHLOG,
+							msg);
+
+	rtk_err("co-processor has crashed.\n");
+}
+
+static void apple_rtkit_ioreport_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);
+
+	switch (type) {
+	case APPLE_RTKIT_BUFFER_REQUEST:
+		apple_rtkit_common_rx_get_buffer(rtk, &rtk->ioreport_buffer,
+						 APPLE_RTKIT_EP_IOREPORT, msg);
+		break;
+	/* unknown, must be ACKed */
+	case 0x8:
+	case 0xc:
+		apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_IOREPORT, msg);
+		break;
+	default:
+		rtk_warn("Unknown ioreport message: %llx\n", msg);
+	}
+}
+
+static void apple_rtkit_syslog_rx_init(struct apple_rtkit *rtk, u64 msg)
+{
+	rtk->syslog_n_entries = FIELD_GET(APPLE_RTKIT_SYSLOG_N_ENTRIES, msg);
+	rtk->syslog_msg_size = FIELD_GET(APPLE_RTKIT_SYSLOG_MSG_SIZE, msg);
+
+	rtk->syslog_msg_buffer =
+		devm_kzalloc(rtk->dev, rtk->syslog_msg_size, GFP_KERNEL);
+
+	rtk_dbg("syslog initialized: entries: %zd, msg_size: %zd\n",
+		rtk->syslog_n_entries, rtk->syslog_msg_size);
+}
+
+static void apple_rtkit_memcpy(struct apple_rtkit *rtk, void *dst,
+			       struct apple_rtkit_shmem *bfr, size_t offset,
+			       size_t len)
+{
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT)
+		memcpy_fromio(dst, bfr->iomem + offset, len);
+	else
+		memcpy(dst, bfr->buffer + offset, len);
+}
+
+static void apple_rtkit_syslog_rx_log(struct apple_rtkit *rtk, u64 msg)
+{
+	u32 idx = msg & 0xff;
+	char log_context[24];
+	size_t entry_size = 0x20 + rtk->syslog_msg_size;
+
+	if (!rtk->syslog_buffer.size) {
+		rtk_warn(
+			"received syslog message but syslog_buffer.size is zero");
+		goto done;
+	}
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_LINUX &&
+	    !rtk->syslog_buffer.buffer) {
+		rtk_warn(
+			"received syslog message but have no syslog_buffer.buffer");
+		goto done;
+	}
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT &&
+	    !rtk->syslog_buffer.iomem) {
+		rtk_warn(
+			"received syslog message but have no syslog_buffer.iomem");
+		goto done;
+	}
+	if (idx > rtk->syslog_n_entries) {
+		rtk_warn("syslog index %d out of range", idx);
+		goto done;
+	}
+
+	apple_rtkit_memcpy(rtk, log_context, &rtk->syslog_buffer,
+			   idx * entry_size + 8, sizeof(log_context));
+	apple_rtkit_memcpy(rtk, rtk->syslog_msg_buffer, &rtk->syslog_buffer,
+			   idx * entry_size + 8 + sizeof(log_context),
+			   rtk->syslog_msg_size);
+
+	log_context[sizeof(log_context) - 1] = 0;
+	rtk->syslog_msg_buffer[rtk->syslog_msg_size - 1] = 0;
+	rtk_info("syslog message: %s: %s", log_context, rtk->syslog_msg_buffer);
+
+done:
+	apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_SYSLOG, msg);
+}
+
+static void apple_rtkit_syslog_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);
+
+	switch (type) {
+	case APPLE_RTKIT_BUFFER_REQUEST:
+		apple_rtkit_common_rx_get_buffer(rtk, &rtk->syslog_buffer,
+						 APPLE_RTKIT_EP_SYSLOG, msg);
+		break;
+	case APPLE_RTKIT_SYSLOG_INIT:
+		apple_rtkit_syslog_rx_init(rtk, msg);
+		break;
+	case APPLE_RTKIT_SYSLOG_LOG:
+		apple_rtkit_syslog_rx_log(rtk, msg);
+		break;
+	default:
+		rtk_warn("Unknown syslog message: %llx\n", msg);
+	}
+}
+
+static void apple_rtkit_rx(struct apple_rtkit *rtk, struct apple_mbox_msg *msg)
+{
+	u8 ep = msg->msg1;
+
+	switch (ep) {
+	case APPLE_RTKIT_EP_MGMT:
+		apple_rtkit_management_rx(rtk, msg->msg0);
+		break;
+	case APPLE_RTKIT_EP_CRASHLOG:
+		apple_rtkit_crashlog_rx(rtk, msg->msg0);
+		break;
+	case APPLE_RTKIT_EP_SYSLOG:
+		apple_rtkit_syslog_rx(rtk, msg->msg0);
+		break;
+	case APPLE_RTKIT_EP_IOREPORT:
+		apple_rtkit_ioreport_rx(rtk, msg->msg0);
+		break;
+	case 0x20 ... 0xff:
+		rtk->ops->recv_message(rtk->cookie, ep, msg->msg0);
+		break;
+	default:
+		rtk_warn("message to unknown endpoint %02x: %llx\n", ep,
+			 msg->msg0);
+	}
+}
+
+static int apple_rtkit_worker(void *data)
+{
+	struct apple_rtkit *rtk = data;
+	struct apple_mbox_msg m;
+
+	while (true) {
+		wait_event_interruptible(rtk->wq,
+					 kfifo_len(&rtk->msg_fifo) > 0);
+
+		if (kfifo_out(&rtk->msg_fifo, &m, 1) == 1)
+			apple_rtkit_rx(rtk, &m);
+	}
+
+	do_exit(0);
+}
+
+static void apple_rtkit_rx_callback(struct mbox_client *cl, void *mssg)
+{
+	struct apple_rtkit *rtk = container_of(cl, struct apple_rtkit, mbox_cl);
+	struct apple_mbox_msg *msg = mssg;
+	u8 ep = msg->msg1;
+
+	dma_rmb();
+
+	if (ep >= 0x20 && (rtk->ops->flags & APPLE_RTKIT_RECV_ATOMIC)) {
+		rtk->ops->recv_message(rtk->cookie, ep, msg->msg0);
+	} else {
+		kfifo_in(&rtk->msg_fifo, msg, 1);
+		wake_up(&rtk->wq);
+	}
+}
+
+int apple_rtkit_send_message(struct apple_rtkit *rtk, u8 ep, u64 message)
+{
+	struct apple_mbox_msg msg;
+	int ret;
+
+	if (WARN_ON(ep >= 0x20 && rtk->state != APPLE_RTKIT_STATE_RUNNING))
+		return -EINVAL;
+
+	msg.msg0 = (u64)message;
+	msg.msg1 = ep;
+	dma_wmb();
+	ret = mbox_send_message(rtk->mbox_chan, &msg);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_send_message);
+
+int apple_rtkit_start_ep(struct apple_rtkit *rtk, u8 endpoint)
+{
+	u64 msg;
+
+	if (WARN_ON(!test_bit(endpoint, rtk->endpoints)))
+		return -EINVAL;
+	if (WARN_ON(endpoint >= 0x20 &&
+		    rtk->state != APPLE_RTKIT_STATE_RUNNING))
+		return -EINVAL;
+
+	msg = FIELD_PREP(APPLE_RTKIT_MGMT_STARTEP_EP, endpoint);
+	msg |= APPLE_RTKIT_MGMT_STARTEP_FLAG;
+	apple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_STARTEP, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_start_ep);
+
+struct apple_rtkit *apple_rtkit_init(struct device *dev, void *cookie,
+				     struct resource *res,
+				     const char *mbox_name,
+				     int mbox_idx,
+				     const struct apple_rtkit_ops *ops)
+{
+	struct apple_rtkit *rtk;
+
+	if (!ops)
+		return ERR_PTR(-EINVAL);
+
+	if (!(ops->flags & APPLE_RTKIT_SHMEM_OWNER_LINUX) &&
+	    !(ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT))
+		return ERR_PTR(-EINVAL);
+
+	rtk = devm_kzalloc(dev, sizeof(*rtk), GFP_KERNEL);
+	if (!rtk)
+		return ERR_PTR(-ENOMEM);
+
+	rtk->dev = dev;
+	rtk->state = APPLE_RTKIT_STATE_INIT;
+	rtk->cookie = cookie;
+	rtk->ops = ops;
+	rtk->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(rtk->regs))
+		return rtk->regs;
+
+	INIT_KFIFO(rtk->msg_fifo);
+	init_waitqueue_head(&rtk->wq);
+	init_completion(&rtk->boot_completion);
+	// TODO: add a way to stop this thread
+	kthread_run(apple_rtkit_worker, rtk, "%s-rtkit-worker", dev_name(dev));
+
+	rtk->mbox_cl.dev = dev;
+	rtk->mbox_cl.tx_block = true;
+	rtk->mbox_cl.knows_txdone = false;
+	rtk->mbox_cl.rx_callback = &apple_rtkit_rx_callback;
+
+	if (mbox_name)
+		rtk->mbox_chan = mbox_request_channel_byname(&rtk->mbox_cl, mbox_name);
+	else
+		rtk->mbox_chan = mbox_request_channel(&rtk->mbox_cl, mbox_idx);
+
+	if (IS_ERR(rtk->mbox_chan))
+		return (struct apple_rtkit *)rtk->mbox_chan;
+
+
+	return rtk;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_init);
+
+int apple_rtkit_boot(struct apple_rtkit *rtk)
+{
+	int ret;
+	u32 cpu_ctrl;
+
+	if (rtk->state != APPLE_RTKIT_STATE_INIT)
+		return 0;
+	rtk->state = APPLE_RTKIT_STATE_BOOTING;
+
+	cpu_ctrl = readl_relaxed(rtk->regs + APPLE_RTKIT_CPU_CONTROL);
+	if (cpu_ctrl & APPLE_RTKIT_CPU_CONTROL_RUN) {
+		rtk_dbg("sending wakeup message\n");
+		ret = apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_MGMT,
+					       APPLE_RTKIT_MGMT_WAKEUP);
+	} else {
+		rtk_dbg("starting CPU\n");
+		cpu_ctrl |= APPLE_RTKIT_CPU_CONTROL_RUN;
+		writel_relaxed(cpu_ctrl, rtk->regs + APPLE_RTKIT_CPU_CONTROL);
+		ret = 0;
+	}
+
+	if (ret)
+		apple_rtkit_boot_abort(rtk, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_boot);
+
+int apple_rtkit_boot_wait(struct apple_rtkit *rtk, unsigned long timeout)
+{
+	int ret;
+	long t;
+
+	switch (rtk->state)
+	{
+	case APPLE_RTKIT_STATE_BOOTING:
+	case APPLE_RTKIT_STATE_INIT:
+		break;
+	case APPLE_RTKIT_STATE_RUNNING:
+		return 0;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	ret = apple_rtkit_boot(rtk);
+	if (ret)
+		return ret;
+
+	rtk_dbg("waiting for boot\n");
+
+
+	t = wait_for_completion_interruptible_timeout(&rtk->boot_completion, timeout);
+	if (t == -ERESTARTSYS)
+		return t;
+	else if (t == 0)
+		return -ETIME;
+
+	if (rtk->state == APPLE_RTKIT_STATE_RUNNING)
+		return 0;
+	return rtk->boot_result;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_boot_wait);
diff --git a/include/linux/apple-rtkit.h b/include/linux/apple-rtkit.h
new file mode 100644
index 000000000000..1b51bdb9fdf5
--- /dev/null
+++ b/include/linux/apple-rtkit.h
@@ -0,0 +1,152 @@
+#ifndef _LINUX_APPLE_RTKIT_H_
+#define _LINUX_APPLE_RTKIT_H_
+
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/mailbox_client.h>
+
+/*
+ * APPLE_RTKIT_SHMEM_OWNER_LINUX - shared memory buffers are allocated and
+ *                                 managed by Linux. ops->shmem_alloc and
+ *                                 ops->shmem_free can be used to override
+ *                                 dma_alloc/free_coherent.
+ * APPLE_RTKIT_SHMEM_OWNER_RTKIT - shared memory buffers are allocated and
+ *                                 managed by RTKit. ops->shmem_map and
+ *                                 ops->shmem_unmap must be defined.
+ * APPLE_RTKIT_RECV_ATOMIC       - ops->recv_message will be called from
+ *                                 atomic / interrupt context.
+ */
+#define APPLE_RTKIT_SHMEM_OWNER_LINUX BIT(0)
+#define APPLE_RTKIT_SHMEM_OWNER_RTKIT BIT(1)
+#define APPLE_RTKIT_RECV_ATOMIC BIT(2)
+
+/*
+ * Struct to represent implementation-specific RTKit operations.
+ *
+ * @flags:        Combination of flags defined above. Exactly one of
+ *                APPLE_RTKIT_SHMEM_OWNER_RTKIT or APPLE_RTKIT_SHMEM_OWNER_LINUX
+ *                must be set.
+ * @recv_message: Function called when a message from RTKit is recevied
+ *                on a non-system endpoint. Called from a worker thread unless
+ *                APPLE_RTKIT_RECV_ATOMIC is set.
+ * @shmem_map:    Used with APPLE_RTKIT_SHMEM_OWNER_RTKIT to map an
+ *                addressed returned by the co-processor into the kernel.
+ * @shmem_unmap:  Used with APPLE_RTKIT_SHMEM_OWNER_RTKIT to unmap a previous
+ *                mapping created with shmem_map again.
+ * @shmem_alloc:  Used with APPLE_RTKIT_SHMEM_OWNER_LINUX to allocate a shared
+ *                memory buffer for the co-processor. If not specified
+ *                dma_alloc_coherent is used.
+ * @shmem_free:   Used with APPLE_RTKIT_SHMEM_OWNER_LINUX to free a shared
+ *                memory buffer previously allocated with shmem_alloc. If not
+ *                specified dma_free_coherent is used.
+ */
+struct apple_rtkit_ops {
+	unsigned int flags;
+	void (*recv_message)(void *cookie, u8 endpoint, u64 message);
+	void __iomem *(*shmem_map)(void *cookie, dma_addr_t addr, size_t len);
+	void (*shmem_unmap)(void *cookie, void __iomem *ptr, dma_addr_t addr,
+			    size_t len);
+	void *(*shmem_alloc)(void *cookie, size_t size, dma_addr_t *dma_handle,
+			     gfp_t flag);
+	void (*shmem_free)(void *cookie, size_t size, void *cpu_addr,
+			   dma_addr_t *dma_handle);
+};
+
+struct apple_rtkit;
+
+#if CONFIG_APPLE_RTKIT
+
+/*
+ * Initializes the internal state required to handle RTKit. This
+ * should usually be called within _probe.
+ *
+ * @dev: Pointer to the device node this coprocessor is assocated with
+ * @cookie: opaque cookie passed to all functions defined in rtkit_ops
+ * @resource: resource containing the CPU_CONTROL register
+ * @mbox_name: mailbox name used to communicate with the co-processor
+ * @mbox_idx: mailbox index to be used if mbox_name is NULL
+ * @ops: pointer to rtkit_ops to be used for this co-processor
+ */
+struct apple_rtkit *apple_rtkit_init(struct device *dev, void *cookie,
+				     struct resource *res,
+				     const char *mbox_name,
+				     int mbox_idx,
+				     const struct apple_rtkit_ops *ops);
+
+void apple_rtkit_free(struct apple_rtkit *rtk);
+
+/*
+ * Turns on the co-processor and initialize the RTKit system endpoints.
+ * Has to be called before any messages can be sent or recevied and will return
+ * immediately. apple_rtkit_boot can be used afterwards to wait for the boot
+ * process to complete.
+ */
+int apple_rtkit_boot(struct apple_rtkit *rtk);
+
+/*
+ * Same as rtkit_boot but waits until the processor has booted successfully.
+ * Can be called after apple_rtkit_boot to wait for the boot process to finish.
+ */
+int apple_rtkit_boot_wait(struct apple_rtkit *rtk, unsigned long timeout);
+
+/*
+ * Puts the co-processor into hibernation mode.
+ * The processor loses almost all state and cannot be used anymore after this
+ * call. All shared memory buffers will be freed.
+ */
+int apple_rtkit_hibernate(struct apple_rtkit *rtk);
+
+/*
+ * Starts an endpoint. Must be called after boot but before any messages can be
+ * sent or received from that endpoint.
+ */
+int apple_rtkit_start_ep(struct apple_rtkit *rtk, u8 endpoint);
+
+/*
+ * Send a message to the given endpoint.
+ */
+int apple_rtkit_send_message(struct apple_rtkit *rtk, u8 ep, u64 message);
+
+#else
+
+static inline struct apple_rtkit *
+apple_rtkit_init(struct device *dev, void *cookie, struct resource *res,
+		 const char *mbox_name, const struct apple_rtkit_ops *ops)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void apple_rtkit_free(struct apple_rtkit *rtk)
+{
+}
+
+static inline int apple_rtkit_boot(struct apple_rtkit *rtk)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_boot_wait(struct apple_rtkit *rtk)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_hibernate(struct apple_rtkit *rtk)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_start_ep(struct apple_rtkit *rtk, u8 endpoint)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_send_message(struct apple_rtkit *rtk, u8 ep,
+					   u64 message)
+{
+	return -ENODEV;
+}
+
+#endif
+
+#endif
-- 
2.33.1

