From b8b5f5ad3a52b10e0a1736a5fdf986be2415676a Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Tue, 2 Nov 2021 18:10:51 +0100
Subject: [PATCH 01/83] dt-bindings: iommu: dart: add t6000 compatible

The M1 Max/Pro SoCs come with a new DART variant that is incompatible with
the previous one. Add a new compatible for those.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 Documentation/devicetree/bindings/iommu/apple,dart.yaml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/iommu/apple,dart.yaml b/Documentation/devicetree/bindings/iommu/apple,dart.yaml
index 94aa9e9afa59..ca2cbde9f3c9 100644
--- a/Documentation/devicetree/bindings/iommu/apple,dart.yaml
+++ b/Documentation/devicetree/bindings/iommu/apple,dart.yaml
@@ -22,7 +22,9 @@ description: |+
 
 properties:
   compatible:
-    const: apple,t8103-dart
+    enum:
+      - apple,t8103-dart
+      - apple,t6000-dart
 
   reg:
     maxItems: 1
-- 
2.34.0


From 6a5889f0ca308c1412b0559639dacdf1680d4821 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Wed, 17 Nov 2021 19:40:16 +0100
Subject: [PATCH 02/83] iommu/io-pgtable: Add DART subpage protection support

DART allows to only expose a subpage to the device. While this is an
optional feature on the M1 DARTs the new ones present on the Pro/Max
models require this field in every PTE.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/iommu/io-pgtable-arm.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c
index dd9e47189d0d..a8c660b8b3e9 100644
--- a/drivers/iommu/io-pgtable-arm.c
+++ b/drivers/iommu/io-pgtable-arm.c
@@ -10,6 +10,7 @@
 #define pr_fmt(fmt)	"arm-lpae io-pgtable: " fmt
 
 #include <linux/atomic.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/io-pgtable.h>
 #include <linux/kernel.h>
@@ -133,6 +134,9 @@
 #define APPLE_DART_PTE_PROT_NO_WRITE (1<<7)
 #define APPLE_DART_PTE_PROT_NO_READ (1<<8)
 
+#define APPLE_DART_PTE_SUBPAGE_START	GENMASK_ULL(63, 52)
+#define APPLE_DART_PTE_SUBPAGE_END	GENMASK_ULL(51, 40)
+
 /* IOPTE accessors */
 #define iopte_deref(pte,d) __va(iopte_to_paddr(pte, d))
 
@@ -273,6 +277,12 @@ static void __arm_lpae_init_pte(struct arm_lpae_io_pgtable *data,
 	else
 		pte |= ARM_LPAE_PTE_TYPE_BLOCK;
 
+	if (data->iop.fmt == APPLE_DART) {
+		/* subpage protection: always allow access to the entire page */
+		pte |= FIELD_PREP(APPLE_DART_PTE_SUBPAGE_START, 0);
+		pte |= FIELD_PREP(APPLE_DART_PTE_SUBPAGE_END, 0xfff);
+	}
+
 	for (i = 0; i < num_entries; i++)
 		ptep[i] = pte | paddr_to_iopte(paddr + i * sz, data);
 
-- 
2.34.0


From ce755ae868e930fc2e70f59ac008a0a9c8dc88cf Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Tue, 2 Nov 2021 18:10:53 +0100
Subject: [PATCH 03/83] iommu/io-pgtable: Add DART PTE support for t6000

The DARTs present in the M1 Pro/Max SoC support a 42bit physical address
space by shifting the paddr and extending its mask inside the PTE.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/iommu/io-pgtable-arm.c | 30 +++++++++++++++++++++++++++++-
 include/linux/io-pgtable.h     |  2 ++
 2 files changed, 31 insertions(+), 1 deletion(-)

diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c
index a8c660b8b3e9..be66774aaf70 100644
--- a/drivers/iommu/io-pgtable-arm.c
+++ b/drivers/iommu/io-pgtable-arm.c
@@ -137,6 +137,11 @@
 #define APPLE_DART_PTE_SUBPAGE_START	GENMASK_ULL(63, 52)
 #define APPLE_DART_PTE_SUBPAGE_END	GENMASK_ULL(51, 40)
 
+#define APPLE_DART_PADDR_MASK_PS_36BIT	GENMASK_ULL(35, 12)
+#define APPLE_DART_PADDR_SHIFT_PS_36BIT	(0)
+#define APPLE_DART_PADDR_MASK_PS_42BIT	GENMASK_ULL(37, 10)
+#define APPLE_DART_PADDR_SHIFT_PS_42BIT	(4)
+
 /* IOPTE accessors */
 #define iopte_deref(pte,d) __va(iopte_to_paddr(pte, d))
 
@@ -171,6 +176,13 @@ static arm_lpae_iopte paddr_to_iopte(phys_addr_t paddr,
 {
 	arm_lpae_iopte pte = paddr;
 
+	if (data->iop.fmt == APPLE_DART) {
+		pte = paddr >> data->iop.cfg.apple_dart_cfg.paddr_shift;
+		pte &= data->iop.cfg.apple_dart_cfg.paddr_mask;
+
+		return pte;
+	}
+
 	/* Of the bits which overlap, either 51:48 or 15:12 are always RES0 */
 	return (pte | (pte >> (48 - 12))) & ARM_LPAE_PTE_ADDR_MASK;
 }
@@ -180,6 +192,12 @@ static phys_addr_t iopte_to_paddr(arm_lpae_iopte pte,
 {
 	u64 paddr = pte & ARM_LPAE_PTE_ADDR_MASK;
 
+	if (data->iop.fmt == APPLE_DART) {
+		paddr = pte & data->iop.cfg.apple_dart_cfg.paddr_mask;
+		paddr <<= data->iop.cfg.apple_dart_cfg.paddr_shift;
+		return paddr;
+	}
+
 	if (ARM_LPAE_GRANULE(data) < SZ_64K)
 		return paddr;
 
@@ -1122,8 +1140,18 @@ apple_dart_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)
 	struct arm_lpae_io_pgtable *data;
 	int i;
 
-	if (cfg->oas > 36)
+	switch (cfg->oas) {
+	case 36:
+		cfg->apple_dart_cfg.paddr_shift = APPLE_DART_PADDR_SHIFT_PS_36BIT;
+		cfg->apple_dart_cfg.paddr_mask = APPLE_DART_PADDR_MASK_PS_36BIT;
+		break;
+	case 42:
+		cfg->apple_dart_cfg.paddr_shift = APPLE_DART_PADDR_SHIFT_PS_42BIT;
+		cfg->apple_dart_cfg.paddr_mask = APPLE_DART_PADDR_MASK_PS_42BIT;
+		break;
+	default:
 		return NULL;
+	}
 
 	data = arm_lpae_alloc_pgtable(cfg);
 	if (!data)
diff --git a/include/linux/io-pgtable.h b/include/linux/io-pgtable.h
index 86af6f0a00a2..4e26ebb0be93 100644
--- a/include/linux/io-pgtable.h
+++ b/include/linux/io-pgtable.h
@@ -136,6 +136,8 @@ struct io_pgtable_cfg {
 		struct {
 			u64 ttbr[4];
 			u32 n_ttbrs;
+			u32 paddr_shift;
+			u64 paddr_mask;
 		} apple_dart_cfg;
 	};
 };
-- 
2.34.0


From 53bf03dc830465bce4320e8524ff670570b6b81d Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Tue, 2 Nov 2021 18:10:52 +0100
Subject: [PATCH 04/83] iommu: dart: Support t6000 variant

The M1 Pro/Max SoCs come with a new variant of DART which supports a
larger physical address space with a slightly different PTE format.
Pass through the correct paddr address space size to the io-pgtable code
which will take care of the rest.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/iommu/apple-dart.c | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/drivers/iommu/apple-dart.c b/drivers/iommu/apple-dart.c
index 565ef5598811..c04648dfd747 100644
--- a/drivers/iommu/apple-dart.c
+++ b/drivers/iommu/apple-dart.c
@@ -81,10 +81,15 @@
 #define DART_TTBR_VALID BIT(31)
 #define DART_TTBR_SHIFT 12
 
+struct apple_dart_hw {
+	u32 oas;
+};
+
 /*
  * Private structure associated with each DART device.
  *
  * @dev: device struct
+ * @hw: SoC-specific hardware data
  * @regs: mapped MMIO region
  * @irq: interrupt number, can be shared with other DARTs
  * @clks: clocks associated with this DART
@@ -98,6 +103,7 @@
  */
 struct apple_dart {
 	struct device *dev;
+	const struct apple_dart_hw *hw;
 
 	void __iomem *regs;
 
@@ -421,7 +427,7 @@ static int apple_dart_finalize_domain(struct iommu_domain *domain,
 	pgtbl_cfg = (struct io_pgtable_cfg){
 		.pgsize_bitmap = dart->pgsize,
 		.ias = 32,
-		.oas = 36,
+		.oas = dart->hw->oas,
 		.coherent_walk = 1,
 		.iommu_dev = dart->dev,
 	};
@@ -855,6 +861,7 @@ static int apple_dart_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	dart->dev = dev;
+	dart->hw = of_device_get_match_data(dev);
 	spin_lock_init(&dart->lock);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -944,8 +951,16 @@ static int apple_dart_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct apple_dart_hw apple_dart_hw_t8103 = {
+	.oas = 36,
+};
+static const struct apple_dart_hw apple_dart_hw_t6000 = {
+	.oas = 42,
+};
+
 static const struct of_device_id apple_dart_of_match[] = {
-	{ .compatible = "apple,t8103-dart", .data = NULL },
+	{ .compatible = "apple,t8103-dart", .data = &apple_dart_hw_t8103 },
+	{ .compatible = "apple,t6000-dart", .data = &apple_dart_hw_t6000 },
 	{},
 };
 MODULE_DEVICE_TABLE(of, apple_dart_of_match);
-- 
2.34.0


From 98f3fd4f1e0950b9aa7b6aae2660061df1f2872f Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 19:05:58 +0900
Subject: [PATCH 05/83] irqchip/apple-aic: Add support for AICv2

This is found in t600x SoCs and no longer implement IPIs, so this also
adds support for FIQ-based "fast" IPIs.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/irqchip/irq-apple-aic.c | 342 ++++++++++++++++++++++++++------
 1 file changed, 286 insertions(+), 56 deletions(-)

diff --git a/drivers/irqchip/irq-apple-aic.c b/drivers/irqchip/irq-apple-aic.c
index 3759dc36cc8f..38aba30e2a00 100644
--- a/drivers/irqchip/irq-apple-aic.c
+++ b/drivers/irqchip/irq-apple-aic.c
@@ -62,17 +62,18 @@
 #include <dt-bindings/interrupt-controller/apple-aic.h>
 
 /*
- * AIC registers (MMIO)
+ * AIC v1 registers (MMIO)
  */
 
 #define AIC_INFO		0x0004
-#define AIC_INFO_NR_HW		GENMASK(15, 0)
+#define AIC_INFO_NR_IRQ		GENMASK(15, 0)
 
 #define AIC_CONFIG		0x0010
 
 #define AIC_WHOAMI		0x2000
 #define AIC_EVENT		0x2004
-#define AIC_EVENT_TYPE		GENMASK(31, 16)
+#define AIC_EVENT_GROUP		GENMASK(31, 24)
+#define AIC_EVENT_TYPE		GENMASK(23, 16)
 #define AIC_EVENT_NUM		GENMASK(15, 0)
 
 #define AIC_EVENT_TYPE_HW	1
@@ -101,12 +102,42 @@
 #define AIC_CPU_IPI_MASK_SET(cpu) (0x5024 + ((cpu) << 7))
 #define AIC_CPU_IPI_MASK_CLR(cpu) (0x5028 + ((cpu) << 7))
 
+/*
+ * AIC v2 registers (MMIO)
+ */
+
+#define AIC2_INFO		0x0004
+#define AIC2_INFO_NR_IRQ	GENMASK(15, 0)
+
+#define AIC2_INFO2		0x0008
+#define AIC2_INFO2_NR_GRP	GENMASK(15, 0)
+
+#define AIC2_CONFIG		0x0014
+#define AIC2_CONFIG_ENABLE	BIT(0)
+#define AIC2_CONFIG_PREFER_PCPU	BIT(28)
+
+#define AIC2_TIMEOUT		0x0028
+#define AIC2_CLUSTER_PRIO	0x0030
+#define AIC2_DELAY_GROUPS	0x0100
+
+#define AIC2_IRQ_CFG		0x2000
+#define AIC2_IRQ_CFG_TARGET	GENMASK(3, 0)
+#define AIC2_IRQ_CFG_DELAY_IDX	GENMASK(7, 5)
+#define AIC2_SW_SET		0x6000
+#define AIC2_SW_CLR		0x6200
+#define AIC2_MASK_SET		0x6400
+#define AIC2_MASK_CLR		0x6600
+#define AIC2_HW_STATE		0x6800
+
+#define AIC2_GROUP_SIZE		0x4a00
+
+#define AIC2_EVENT		0xc000
+
 #define MASK_REG(x)		(4 * ((x) >> 5))
 #define MASK_BIT(x)		BIT((x) & GENMASK(4, 0))
 
 /*
  * IMP-DEF sysregs that control FIQ sources
- * Note: sysreg-based IPIs are not supported yet.
  */
 
 /* Core PMC control register */
@@ -155,6 +186,10 @@
 #define SYS_IMP_APL_UPMSR_EL1		sys_reg(3, 7, 15, 6, 4)
 #define UPMSR_IACT			BIT(0)
 
+/* MPIDR fields */
+#define MPIDR_CPU			GENMASK(7, 0)
+#define MPIDR_CLUSTER			GENMASK(15, 8)
+
 #define AIC_NR_FIQ		4
 #define AIC_NR_SWIPI		32
 
@@ -173,12 +208,90 @@
 #define AIC_TMR_EL02_PHYS	AIC_TMR_GUEST_PHYS
 #define AIC_TMR_EL02_VIRT	AIC_TMR_GUEST_VIRT
 
+struct aic_info {
+	int version;
+
+	/* Register offsets */
+	u64 whoami;
+	u64 event;
+	u64 target_cpu;
+	u64 sw_set;
+	u64 sw_clr;
+	u64 mask_set;
+	u64 mask_clr;
+
+	u64 group_size;
+
+	/* Features */
+	bool fast_ipi;
+};
+
+static const struct aic_info aic1_info = {
+	.version	= 1,
+
+	.whoami		= AIC_WHOAMI,
+	.event		= AIC_EVENT,
+	.target_cpu	= AIC_TARGET_CPU,
+	.sw_set		= AIC_SW_SET,
+	.sw_clr		= AIC_SW_CLR,
+	.mask_set	= AIC_MASK_SET,
+	.mask_clr	= AIC_MASK_CLR,
+};
+
+static const struct aic_info aic1_fipi_info = {
+	.version	= 1,
+
+	.whoami		= AIC_WHOAMI,
+	.event		= AIC_EVENT,
+	.target_cpu	= AIC_TARGET_CPU,
+	.sw_set		= AIC_SW_SET,
+	.sw_clr		= AIC_SW_CLR,
+	.mask_set	= AIC_MASK_SET,
+	.mask_clr	= AIC_MASK_CLR,
+
+	.fast_ipi	= true,
+};
+
+static const struct aic_info aic2_info = {
+	.version	= 2,
+
+	.event		= AIC2_EVENT,
+	.sw_set		= AIC2_SW_SET,
+	.sw_clr		= AIC2_SW_CLR,
+	.mask_set	= AIC2_MASK_SET,
+	.mask_clr	= AIC2_MASK_CLR,
+	.group_size	= AIC2_GROUP_SIZE,
+
+	.fast_ipi	= true,
+};
+
+static const struct of_device_id aic_info_match[] = {
+	{
+		.compatible = "apple,t8103-aic",
+		.data = &aic1_fipi_info,
+	},
+	{
+		.compatible = "apple,aic",
+		.data = &aic1_info,
+	},
+	{
+		.compatible = "apple,aic2",
+		.data = &aic2_info,
+	},
+	{}
+};
+
 struct aic_irq_chip {
 	void __iomem *base;
 	struct irq_domain *hw_domain;
 	struct irq_domain *ipi_domain;
+
+	int nr_irq;
+	int nr_grp;
 	int nr_hw;
 	int ipi_hwirq;
+
+	struct aic_info info;
 };
 
 static DEFINE_PER_CPU(uint32_t, aic_fiq_unmasked);
@@ -206,18 +319,24 @@ static void aic_ic_write(struct aic_irq_chip *ic, u32 reg, u32 val)
 
 static void aic_irq_mask(struct irq_data *d)
 {
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
 	struct aic_irq_chip *ic = irq_data_get_irq_chip_data(d);
 
-	aic_ic_write(ic, AIC_MASK_SET + MASK_REG(irqd_to_hwirq(d)),
-		     MASK_BIT(irqd_to_hwirq(d)));
+	u32 off = (hwirq / ic->nr_irq) * ic->info.group_size;
+	u32 irq = hwirq % ic->nr_irq;
+
+	aic_ic_write(ic, off + ic->info.mask_set + MASK_REG(irq), MASK_BIT(irq));
 }
 
 static void aic_irq_unmask(struct irq_data *d)
 {
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
 	struct aic_irq_chip *ic = irq_data_get_irq_chip_data(d);
 
-	aic_ic_write(ic, AIC_MASK_CLR + MASK_REG(d->hwirq),
-		     MASK_BIT(irqd_to_hwirq(d)));
+	u32 off = (hwirq / ic->nr_irq) * ic->info.group_size;
+	u32 irq = hwirq % ic->nr_irq;
+
+	aic_ic_write(ic, off + ic->info.mask_clr + MASK_REG(irq), MASK_BIT(irq));
 }
 
 static void aic_irq_eoi(struct irq_data *d)
@@ -233,19 +352,20 @@ static void aic_irq_eoi(struct irq_data *d)
 static void __exception_irq_entry aic_handle_irq(struct pt_regs *regs)
 {
 	struct aic_irq_chip *ic = aic_irqc;
-	u32 event, type, irq;
+	u32 event, group, type, irq;
 
 	do {
 		/*
 		 * We cannot use a relaxed read here, as reads from DMA buffers
 		 * need to be ordered after the IRQ fires.
 		 */
-		event = readl(ic->base + AIC_EVENT);
+		event = readl(ic->base + ic->info.event);
+		group = FIELD_GET(AIC_EVENT_GROUP, event);
 		type = FIELD_GET(AIC_EVENT_TYPE, event);
 		irq = FIELD_GET(AIC_EVENT_NUM, event);
 
 		if (type == AIC_EVENT_TYPE_HW)
-			generic_handle_domain_irq(aic_irqc->hw_domain, irq);
+			generic_handle_domain_irq(aic_irqc->hw_domain, irq + ic->nr_irq * group);
 		else if (type == AIC_EVENT_TYPE_IPI && irq == 1)
 			aic_handle_ipi(regs);
 		else if (event != 0)
@@ -272,12 +392,15 @@ static int aic_irq_set_affinity(struct irq_data *d,
 	struct aic_irq_chip *ic = irq_data_get_irq_chip_data(d);
 	int cpu;
 
+	if (!ic->info.target_cpu)
+		return -EINVAL;
+
 	if (force)
 		cpu = cpumask_first(mask_val);
 	else
 		cpu = cpumask_any_and(mask_val, cpu_online_mask);
 
-	aic_ic_write(ic, AIC_TARGET_CPU + hwirq * 4, BIT(cpu));
+	aic_ic_write(ic, ic->info.target_cpu + hwirq * 4, BIT(cpu));
 	irq_data_update_effective_affinity(d, cpumask_of(cpu));
 
 	return IRQ_SET_MASK_OK;
@@ -301,6 +424,14 @@ static struct irq_chip aic_chip = {
 	.irq_set_type = aic_irq_set_type,
 };
 
+static struct irq_chip aic2_chip = {
+	.name = "AIC2",
+	.irq_mask = aic_irq_mask,
+	.irq_unmask = aic_irq_unmask,
+	.irq_eoi = aic_irq_eoi,
+	.irq_set_type = aic_irq_set_type,
+};
+
 /*
  * FIQ irqchip
  */
@@ -387,8 +518,12 @@ static void __exception_irq_entry aic_handle_fiq(struct pt_regs *regs)
 	 */
 
 	if (read_sysreg_s(SYS_IMP_APL_IPI_SR_EL1) & IPI_SR_PENDING) {
-		pr_err_ratelimited("Fast IPI fired. Acking.\n");
-		write_sysreg_s(IPI_SR_PENDING, SYS_IMP_APL_IPI_SR_EL1);
+		if (aic_irqc->info.fast_ipi) {
+			aic_handle_ipi(regs);
+		} else {
+			pr_err_ratelimited("Fast IPI fired. Acking.\n");
+			write_sysreg_s(IPI_SR_PENDING, SYS_IMP_APL_IPI_SR_EL1);
+		}
 	}
 
 	if (TIMER_FIRING(read_sysreg(cntp_ctl_el0)))
@@ -457,9 +592,14 @@ static int aic_irq_domain_map(struct irq_domain *id, unsigned int irq,
 {
 	struct aic_irq_chip *ic = id->host_data;
 
+	struct irq_chip *chip = &aic_chip;
+
+	if (ic->info.version == 2)
+		chip = &aic2_chip;
+
 	if (hw < ic->nr_hw) {
-		irq_domain_set_info(id, irq, hw, &aic_chip, id->host_data,
-				    handle_fasteoi_irq, NULL, NULL);
+		irq_domain_set_info(id, irq, hw, chip, id->host_data,
+				handle_fasteoi_irq, NULL, NULL);
 		irqd_set_single_target(irq_desc_get_irq_data(irq_to_desc(irq)));
 	} else {
 		irq_set_percpu_devid(irq);
@@ -476,27 +616,40 @@ static int aic_irq_domain_translate(struct irq_domain *id,
 				    unsigned int *type)
 {
 	struct aic_irq_chip *ic = id->host_data;
+	u32 *args;
+	u32 group = 0;
 
-	if (fwspec->param_count != 3 || !is_of_node(fwspec->fwnode))
+	if (fwspec->param_count < 3 || fwspec->param_count > 4 || !is_of_node(fwspec->fwnode))
 		return -EINVAL;
 
+	args = &fwspec->param[1];
+
+	if (fwspec->param_count == 4) {
+		group = args[0];
+		args++;
+	}
+
 	switch (fwspec->param[0]) {
 	case AIC_IRQ:
-		if (fwspec->param[1] >= ic->nr_hw)
+		if (group >= ic->nr_grp)
+			return -EINVAL;
+		if (args[0] >= ic->nr_irq)
 			return -EINVAL;
-		*hwirq = fwspec->param[1];
+		*hwirq = args[0] + group * ic->nr_irq;
 		break;
 	case AIC_FIQ:
-		if (fwspec->param[1] >= AIC_NR_FIQ)
+		if (group != 0)
+			return -EINVAL;
+		if (args[0] >= AIC_NR_FIQ)
 			return -EINVAL;
-		*hwirq = ic->nr_hw + fwspec->param[1];
+		*hwirq = ic->nr_hw + args[0];
 
 		/*
 		 * In EL1 the non-redirected registers are the guest's,
 		 * not EL2's, so remap the hwirqs to match.
 		 */
 		if (!is_kernel_in_hyp_mode()) {
-			switch (fwspec->param[1]) {
+			switch (args[0]) {
 			case AIC_TMR_GUEST_PHYS:
 				*hwirq = ic->nr_hw + AIC_TMR_EL0_PHYS;
 				break;
@@ -515,7 +668,7 @@ static int aic_irq_domain_translate(struct irq_domain *id,
 		return -EINVAL;
 	}
 
-	*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;
+	*type = args[1] & IRQ_TYPE_SENSE_MASK;
 
 	return 0;
 }
@@ -564,6 +717,21 @@ static const struct irq_domain_ops aic_irq_domain_ops = {
  * IPI irqchip
  */
 
+static void aic_ipi_send_fast(int cpu)
+{
+	u64 mpidr = cpu_logical_map(cpu);
+	u64 my_mpidr = cpu_logical_map(smp_processor_id());
+	u64 cluster = FIELD_GET(MPIDR_CLUSTER, mpidr);
+	u64 idx = FIELD_GET(MPIDR_CPU, mpidr);
+
+	if (FIELD_GET(MPIDR_CLUSTER, my_mpidr) == cluster)
+		write_sysreg_s(FIELD_PREP(IPI_RR_CPU, idx),
+			       SYS_IMP_APL_IPI_RR_LOCAL_EL1);
+	else
+		write_sysreg_s(FIELD_PREP(IPI_RR_CPU, idx) | FIELD_PREP(IPI_RR_CLUSTER, cluster),
+			       SYS_IMP_APL_IPI_RR_GLOBAL_EL1);
+}
+
 static void aic_ipi_mask(struct irq_data *d)
 {
 	u32 irq_bit = BIT(irqd_to_hwirq(d));
@@ -589,8 +757,12 @@ static void aic_ipi_unmask(struct irq_data *d)
 	 * If a pending vIPI was unmasked, raise a HW IPI to ourselves.
 	 * No barriers needed here since this is a self-IPI.
 	 */
-	if (atomic_read(this_cpu_ptr(&aic_vipi_flag)) & irq_bit)
-		aic_ic_write(ic, AIC_IPI_SEND, AIC_IPI_SEND_CPU(smp_processor_id()));
+	if (atomic_read(this_cpu_ptr(&aic_vipi_flag)) & irq_bit) {
+		if (ic->info.fast_ipi)
+			aic_ipi_send_fast(smp_processor_id());
+		else
+			aic_ic_write(ic, AIC_IPI_SEND, AIC_IPI_SEND_CPU(smp_processor_id()));
+	}
 }
 
 static void aic_ipi_send_mask(struct irq_data *d, const struct cpumask *mask)
@@ -618,8 +790,12 @@ static void aic_ipi_send_mask(struct irq_data *d, const struct cpumask *mask)
 		smp_mb__after_atomic();
 
 		if (!(pending & irq_bit) &&
-		    (atomic_read(per_cpu_ptr(&aic_vipi_enable, cpu)) & irq_bit))
-			send |= AIC_IPI_SEND_CPU(cpu);
+		    (atomic_read(per_cpu_ptr(&aic_vipi_enable, cpu)) & irq_bit)) {
+			if (ic->info.fast_ipi)
+				aic_ipi_send_fast(cpu);
+			else
+				send |= AIC_IPI_SEND_CPU(cpu);
+		}
 	}
 
 	/*
@@ -651,8 +827,16 @@ static void aic_handle_ipi(struct pt_regs *regs)
 	/*
 	 * Ack the IPI. We need to order this after the AIC event read, but
 	 * that is enforced by normal MMIO ordering guarantees.
+	 *
+	 * For the Fast IPI case, this needs to be ordered before the vIPI
+	 * handling below, so we need to isb();
 	 */
-	aic_ic_write(aic_irqc, AIC_IPI_ACK, AIC_IPI_OTHER);
+	if (aic_irqc->info.fast_ipi) {
+		write_sysreg_s(IPI_SR_PENDING, SYS_IMP_APL_IPI_SR_EL1);
+		isb();
+	} else {
+		aic_ic_write(aic_irqc, AIC_IPI_ACK, AIC_IPI_OTHER);
+	}
 
 	/*
 	 * The mask read does not need to be ordered. Only we can change
@@ -680,7 +864,8 @@ static void aic_handle_ipi(struct pt_regs *regs)
 	 * No ordering needed here; at worst this just changes the timing of
 	 * when the next IPI will be delivered.
 	 */
-	aic_ic_write(aic_irqc, AIC_IPI_MASK_CLR, AIC_IPI_OTHER);
+	if (!aic_irqc->info.fast_ipi)
+		aic_ic_write(aic_irqc, AIC_IPI_MASK_CLR, AIC_IPI_OTHER);
 }
 
 static int aic_ipi_alloc(struct irq_domain *d, unsigned int virq,
@@ -767,20 +952,26 @@ static int aic_init_cpu(unsigned int cpu)
 	/* Commit all of the above */
 	isb();
 
-	/*
-	 * Make sure the kernel's idea of logical CPU order is the same as AIC's
-	 * If we ever end up with a mismatch here, we will have to introduce
-	 * a mapping table similar to what other irqchip drivers do.
-	 */
-	WARN_ON(aic_ic_read(aic_irqc, AIC_WHOAMI) != smp_processor_id());
+	if (aic_irqc->info.whoami) {
+		/*
+		* Make sure the kernel's idea of logical CPU order is the same as AIC's
+		* If we ever end up with a mismatch here, we will have to introduce
+		* a mapping table similar to what other irqchip drivers do.
+		*/
+		WARN_ON(aic_ic_read(aic_irqc, aic_irqc->info.whoami) != smp_processor_id());
 
-	/*
-	 * Always keep IPIs unmasked at the hardware level (except auto-masking
-	 * by AIC during processing). We manage masks at the vIPI level.
-	 */
-	aic_ic_write(aic_irqc, AIC_IPI_ACK, AIC_IPI_SELF | AIC_IPI_OTHER);
-	aic_ic_write(aic_irqc, AIC_IPI_MASK_SET, AIC_IPI_SELF);
-	aic_ic_write(aic_irqc, AIC_IPI_MASK_CLR, AIC_IPI_OTHER);
+		/*
+		* Always keep IPIs unmasked at the hardware level (except auto-masking
+		* by AIC during processing). We manage masks at the vIPI level.
+		*/
+		aic_ic_write(aic_irqc, AIC_IPI_ACK, AIC_IPI_SELF | AIC_IPI_OTHER);
+		if (!aic_irqc->info.fast_ipi) {
+			aic_ic_write(aic_irqc, AIC_IPI_MASK_SET, AIC_IPI_SELF);
+			aic_ic_write(aic_irqc, AIC_IPI_MASK_CLR, AIC_IPI_OTHER);
+		} else {
+			aic_ic_write(aic_irqc, AIC_IPI_MASK_SET, AIC_IPI_SELF | AIC_IPI_OTHER);
+		}
+	}
 
 	/* Initialize the local mask state */
 	__this_cpu_write(aic_fiq_unmasked, 0);
@@ -796,10 +987,11 @@ static struct gic_kvm_info vgic_info __initdata = {
 
 static int __init aic_of_ic_init(struct device_node *node, struct device_node *parent)
 {
-	int i;
+	int i, grp;
+	u32 off;
 	void __iomem *regs;
-	u32 info;
 	struct aic_irq_chip *irqc;
+	const struct of_device_id *match;
 
 	regs = of_iomap(node, 0);
 	if (WARN_ON(!regs))
@@ -809,11 +1001,34 @@ static int __init aic_of_ic_init(struct device_node *node, struct device_node *p
 	if (!irqc)
 		return -ENOMEM;
 
-	aic_irqc = irqc;
 	irqc->base = regs;
 
-	info = aic_ic_read(irqc, AIC_INFO);
-	irqc->nr_hw = FIELD_GET(AIC_INFO_NR_HW, info);
+	match = of_match_node(aic_info_match, node);
+	if (!match)
+		return -ENODEV;
+
+	irqc->info = *(struct aic_info *)match->data;
+
+	aic_irqc = irqc;
+
+	switch (irqc->info.version) {
+	case 1: {
+		u32 info;
+		info = aic_ic_read(irqc, AIC_INFO);
+		irqc->nr_irq = FIELD_GET(AIC_INFO_NR_IRQ, info);
+		irqc->nr_grp = 1;
+		break;
+	}
+	case 2: {
+		u32 info, info2;
+		info = aic_ic_read(irqc, AIC2_INFO);
+		info2 = aic_ic_read(irqc, AIC2_INFO2);
+		irqc->nr_irq = FIELD_GET(AIC2_INFO_NR_IRQ, info);
+		irqc->nr_grp = FIELD_GET(AIC2_INFO2_NR_GRP, info2);
+		break;
+	}
+	}
+	irqc->nr_hw = irqc->nr_irq * irqc->nr_grp;
 
 	irqc->hw_domain = irq_domain_create_linear(of_node_to_fwnode(node),
 						   irqc->nr_hw + AIC_NR_FIQ,
@@ -836,26 +1051,41 @@ static int __init aic_of_ic_init(struct device_node *node, struct device_node *p
 	set_handle_irq(aic_handle_irq);
 	set_handle_fiq(aic_handle_fiq);
 
-	for (i = 0; i < BITS_TO_U32(irqc->nr_hw); i++)
-		aic_ic_write(irqc, AIC_MASK_SET + i * 4, U32_MAX);
-	for (i = 0; i < BITS_TO_U32(irqc->nr_hw); i++)
-		aic_ic_write(irqc, AIC_SW_CLR + i * 4, U32_MAX);
-	for (i = 0; i < irqc->nr_hw; i++)
-		aic_ic_write(irqc, AIC_TARGET_CPU + i * 4, 1);
+	off = 0;
+	for (grp = 0; grp < irqc->nr_grp; grp++) {
+		for (i = 0; i < BITS_TO_U32(irqc->nr_irq); i++)
+			aic_ic_write(irqc, off + irqc->info.mask_set + i * 4, U32_MAX);
+		for (i = 0; i < BITS_TO_U32(irqc->nr_irq); i++)
+			aic_ic_write(irqc, off + irqc->info.sw_clr + i * 4, U32_MAX);
+		if (irqc->info.target_cpu)
+			for (i = 0; i < irqc->nr_irq; i++)
+				aic_ic_write(irqc, off + irqc->info.target_cpu + i * 4, 1);
+		off += irqc->info.group_size;
+	}
+
+	if (irqc->info.version == 2) {
+		u32 config = aic_ic_read(irqc, AIC2_CONFIG);
+		config |= AIC2_CONFIG_ENABLE;
+		aic_ic_write(irqc, AIC2_CONFIG, config);
+	}
 
 	if (!is_kernel_in_hyp_mode())
 		pr_info("Kernel running in EL1, mapping interrupts");
 
+	if (irqc->info.fast_ipi)
+		pr_info("Using Fast IPIs");
+
 	cpuhp_setup_state(CPUHP_AP_IRQ_APPLE_AIC_STARTING,
 			  "irqchip/apple-aic/ipi:starting",
 			  aic_init_cpu, NULL);
 
 	vgic_set_kvm_info(&vgic_info);
 
-	pr_info("Initialized with %d IRQs, %d FIQs, %d vIPIs\n",
-		irqc->nr_hw, AIC_NR_FIQ, AIC_NR_SWIPI);
+	pr_info("Initialized with %d IRQs in %d group(s), %d FIQs, %d vIPIs",
+		irqc->nr_hw, irqc->nr_grp, AIC_NR_FIQ, AIC_NR_SWIPI);
 
 	return 0;
 }
 
-IRQCHIP_DECLARE(apple_m1_aic, "apple,aic", aic_of_ic_init);
+IRQCHIP_DECLARE(apple_aic, "apple,aic", aic_of_ic_init);
+IRQCHIP_DECLARE(apple_aic2, "apple,aic2", aic_of_ic_init);
-- 
2.34.0


From a9ab4273c9c5a089cc1cb7748ab129a9405e3eb6 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 19:07:41 +0900
Subject: [PATCH 06/83] arm64: dts: apple: Add initial t6000/t6001 DTs

t6000 is a cut-down version of t6001, so the former just includes the
latter and disables the missing bits (of which there are none, at the
moment).

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/t6000.dtsi |  16 +
 arch/arm64/boot/dts/apple/t6001.dtsi | 468 +++++++++++++++++++++++++++
 2 files changed, 484 insertions(+)
 create mode 100644 arch/arm64/boot/dts/apple/t6000.dtsi
 create mode 100644 arch/arm64/boot/dts/apple/t6001.dtsi

diff --git a/arch/arm64/boot/dts/apple/t6000.dtsi b/arch/arm64/boot/dts/apple/t6000.dtsi
new file mode 100644
index 000000000000..e7ca4e88c060
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t6000.dtsi
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * Apple T6000 "M1 Pro" SoC
+ *
+ * Other names: H13J, "Jade Chop"
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/* This chip is just a cut down version of t6001, so include it and disable the missing parts */
+
+#include "t6001.dtsi"
+
+/ {
+	compatible = "apple,t6000", "apple,arm-platform";
+};
diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
new file mode 100644
index 000000000000..2dc9e39c00d0
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -0,0 +1,468 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * Apple T6001 "M1 Max" SoC
+ *
+ * Other names: H13J, "Jade"
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+#include <dt-bindings/interrupt-controller/apple-aic.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pinctrl/apple.h>
+
+/ {
+	compatible = "apple,t6001", "apple,arm-platform";
+
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "apple,icestorm";
+			device_type = "cpu";
+			reg = <0x0 0x0>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu1: cpu@1 {
+			compatible = "apple,icestorm";
+			device_type = "cpu";
+			reg = <0x0 0x1>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu2: cpu@10100 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10100>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu3: cpu@10101 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10101>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu4: cpu@10102 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10102>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu5: cpu@10103 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10103>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu6: cpu@10200 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10200>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu7: cpu@10201 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10201>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu8: cpu@10202 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10202>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+
+		cpu9: cpu@10203 {
+			compatible = "apple,firestorm";
+			device_type = "cpu";
+			reg = <0x0 0x10203>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0 0>; /* To be filled by loader */
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&aic>;
+		interrupt-names = "phys", "virt", "hyp-phys", "hyp-virt";
+		interrupts = <AIC_FIQ 0 AIC_TMR_GUEST_PHYS IRQ_TYPE_LEVEL_HIGH>,
+			     <AIC_FIQ 0 AIC_TMR_GUEST_VIRT IRQ_TYPE_LEVEL_HIGH>,
+			     <AIC_FIQ 0 AIC_TMR_HV_PHYS IRQ_TYPE_LEVEL_HIGH>,
+			     <AIC_FIQ 0 AIC_TMR_HV_VIRT IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	clkref: clock-ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+		clock-output-names = "clkref";
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+
+		ranges;
+		nonposted-mmio;
+
+		aic: interrupt-controller@28e100000 {
+			compatible = "apple,t6000-aic", "apple,aic2";
+			#interrupt-cells = <4>;
+			interrupt-controller;
+			reg = <0x2 0x8e100000 0x0 0x10000>;
+		};
+
+		serial0: serial@39b200000 {
+			compatible = "apple,s5l-uart";
+			reg = <0x3 0x9b200000 0x0 0x1000>;
+			reg-io-width = <4>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1097 IRQ_TYPE_LEVEL_HIGH>;
+			/*
+			 * TODO: figure out the clocking properly, there may
+			 * be a third selectable clock.
+			 */
+			clocks = <&clkref>, <&clkref>;
+			clock-names = "uart", "clk_uart_baud0";
+			status = "disabled";
+		};
+
+		pinctrl_ap: pinctrl@39b028000 {
+			compatible = "apple,t8103-pinctrl", "apple,pinctrl";
+			reg = <0x3 0x9b028000 0x0 0x4000>;
+
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 427 IRQ_TYPE_LEVEL_HIGH>,
+			             <AIC_IRQ 0 428 IRQ_TYPE_LEVEL_HIGH>,
+			             <AIC_IRQ 0 429 IRQ_TYPE_LEVEL_HIGH>,
+			             <AIC_IRQ 0 430 IRQ_TYPE_LEVEL_HIGH>,
+			             <AIC_IRQ 0 431 IRQ_TYPE_LEVEL_HIGH>,
+			             <AIC_IRQ 0 432 IRQ_TYPE_LEVEL_HIGH>,
+			             <AIC_IRQ 0 433 IRQ_TYPE_LEVEL_HIGH>;
+
+			clocks = <&clkref>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl_ap 0 0 255>;
+			apple,npins = <255>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			i2c0_pins: i2c0-pins {
+				pinmux = <APPLE_PINMUX(92, 1)>,
+					<APPLE_PINMUX(93, 1)>;
+			};
+
+			pcie_pins: pcie-pins {
+				pinmux = <APPLE_PINMUX(0, 1)>,
+					 <APPLE_PINMUX(1, 1)>,
+					 <APPLE_PINMUX(2, 1)>,
+					 <APPLE_PINMUX(3, 1)>;
+			};
+		};
+
+		i2c0: i2c@39b040000 {
+			compatible = "apple,t8103-i2c";
+			reg = <0x3 0x9b040000 0x0 0x4000>;
+			clocks = <&clkref>, <&clkref>;
+			clock-names = "gate", "ref";
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1119 4>;
+			pinctrl-0 = <&i2c0_pins>;
+			pinctrl-names = "default";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+		};
+
+		pcie0_dart_0: dart@581008000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x5 0x81008000 0x0 0x4000>;
+			#iommu-cells = <1>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1271 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		pcie0_dart_1: dart@582008000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x5 0x82008000 0x0 0x4000>;
+			#iommu-cells = <1>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1274 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		pcie0_dart_2: dart@583008000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x5 0x83008000 0x0 0x4000>;
+			#iommu-cells = <1>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1277 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		pcie0_dart_3: dart@584008000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x5 0x84008000 0x0 0x4000>;
+			#iommu-cells = <1>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1280 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		pcie0: pcie@590000000 {
+			compatible = "apple,t8103-pcie", "apple,pcie";
+			device_type = "pci";
+
+			reg = <0x5 0x90000000 0x0 0x1000000>,
+			      <0x5 0x80000000 0x0 0x100000>,
+			      <0x5 0x81000000 0x0 0x4000>,
+			      <0x5 0x82000000 0x0 0x4000>,
+			      <0x5 0x83000000 0x0 0x4000>,
+			      <0x5 0x84000000 0x0 0x4000>;
+			reg-names = "config", "rc", "port0", "port1", "port2", "port3";
+
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1270 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 1273 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 1276 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 1279 IRQ_TYPE_LEVEL_HIGH>;
+
+			msi-controller;
+			msi-parent = <&pcie0>;
+			msi-ranges = <&aic AIC_IRQ 0 1581 IRQ_TYPE_EDGE_RISING 32>;
+
+
+			iommu-map = <0x100 &pcie0_dart_0 1 1>,
+				    <0x200 &pcie0_dart_1 1 1>,
+				    <0x300 &pcie0_dart_2 1 1>,
+				    <0x400 &pcie0_dart_3 1 1>;
+			iommu-map-mask = <0xff00>;
+
+			bus-range = <0 4>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			ranges = <0x43000000 0x5 0xa0000000 0x5 0xa0000000 0x0 0x20000000>,
+				 <0x02000000 0x0 0xc0000000 0x5 0xc0000000 0x0 0x40000000>;
+
+			pinctrl-0 = <&pcie_pins>;
+			pinctrl-names = "default";
+
+			port00: pci@0,0 {
+				device_type = "pci";
+				reg = <0x0 0x0 0x0 0x0 0x0>;
+				reset-gpios = <&pinctrl_ap 4 0>;
+				max-link-speed = <2>;
+
+				#address-cells = <3>;
+				#size-cells = <2>;
+				ranges;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 7>;
+				interrupt-map = <0 0 0 1 &port00 0 0 0 0>,
+						<0 0 0 2 &port00 0 0 0 1>,
+						<0 0 0 3 &port00 0 0 0 2>,
+						<0 0 0 4 &port00 0 0 0 3>;
+			};
+
+			port01: pci@1,0 {
+				device_type = "pci";
+				reg = <0x800 0x0 0x0 0x0 0x0>;
+				reset-gpios = <&pinctrl_ap 5 0>;
+				max-link-speed = <2>;
+
+				#address-cells = <3>;
+				#size-cells = <2>;
+				ranges;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 7>;
+				interrupt-map = <0 0 0 1 &port01 0 0 0 0>,
+						<0 0 0 2 &port01 0 0 0 1>,
+						<0 0 0 3 &port01 0 0 0 2>,
+						<0 0 0 4 &port01 0 0 0 3>;
+			};
+
+			port02: pci@2,0 {
+				device_type = "pci";
+				reg = <0x1000 0x0 0x0 0x0 0x0>;
+				reset-gpios = <&pinctrl_ap 6 0>;
+				max-link-speed = <1>;
+
+				#address-cells = <3>;
+				#size-cells = <2>;
+				ranges;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 7>;
+				interrupt-map = <0 0 0 1 &port02 0 0 0 0>,
+						<0 0 0 2 &port02 0 0 0 1>,
+						<0 0 0 3 &port02 0 0 0 2>,
+						<0 0 0 4 &port02 0 0 0 3>;
+			};
+
+			port03: pci@3,0 {
+				device_type = "pci";
+				reg = <0x1800 0x0 0x0 0x0 0x0>;
+				reset-gpios = <&pinctrl_ap 7 0>;
+				max-link-speed = <1>;
+
+				#address-cells = <3>;
+				#size-cells = <2>;
+				ranges;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 7>;
+				interrupt-map = <0 0 0 1 &port03 0 0 0 0>,
+						<0 0 0 2 &port03 0 0 0 1>,
+						<0 0 0 3 &port03 0 0 0 2>,
+						<0 0 0 4 &port03 0 0 0 3>;
+			};
+		};
+
+		dwc3_0_dart_0: iommu@702f00000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x7 0x02f00000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1194 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_0_dart_1: iommu@702f80000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x7 0x02f80000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1194 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_0: usb@702280000 {
+			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			reg = <0x7 0x02280000 0x0 0x100000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1190 IRQ_TYPE_LEVEL_HIGH>;
+			dr_mode = "otg";
+			usb-role-switch;
+			role-switch-default-mode = "host";
+			iommus = <&dwc3_0_dart_0 0>, <&dwc3_0_dart_1 1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		dwc3_1_dart_0: iommu@b02f00000 {
+			compatible = "apple,t6000-dart";
+			reg = <0xb 0x02f00000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1211 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_1_dart_1: iommu@b02f80000 {
+			compatible = "apple,t6000-dart";
+			reg = <0xb 0x02f80000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1211 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_1: usb@b02280000 {
+			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			reg = <0xb 0x02280000 0x0 0x100000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1207 IRQ_TYPE_LEVEL_HIGH>;
+			dr_mode = "otg";
+			usb-role-switch;
+			role-switch-default-mode = "host";
+			iommus = <&dwc3_1_dart_0 0>, <&dwc3_1_dart_1 1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		dwc3_2_dart_0: iommu@f02f00000 {
+			compatible = "apple,t6000-dart";
+			reg = <0xf 0x02f00000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1228 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_2_dart_1: iommu@f02f80000 {
+			compatible = "apple,t6000-dart";
+			reg = <0xf 0x02f80000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1228 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_2: usb@f02280000 {
+			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			reg = <0xf 0x02280000 0x0 0x100000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1224 IRQ_TYPE_LEVEL_HIGH>;
+			dr_mode = "otg";
+			usb-role-switch;
+			role-switch-default-mode = "host";
+			iommus = <&dwc3_2_dart_0 0>, <&dwc3_2_dart_1 1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		dwc3_3_dart_0: iommu@1302f00000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x13 0x02f00000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1245 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_3_dart_1: iommu@1302f80000 {
+			compatible = "apple,t6000-dart";
+			reg = <0x13 0x02f80000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1245 IRQ_TYPE_LEVEL_HIGH>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_3: usb@1302280000 {
+			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			reg = <0x13 0x02280000 0x0 0x100000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1241 IRQ_TYPE_LEVEL_HIGH>;
+			dr_mode = "otg";
+			usb-role-switch;
+			role-switch-default-mode = "host";
+			iommus = <&dwc3_3_dart_0 0>, <&dwc3_3_dart_1 1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+};
-- 
2.34.0


From b4d1c14f0522b8bfc17cccb5f1b17a4b9a0bbff9 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 19:08:25 +0900
Subject: [PATCH 07/83] arm64: dts: apple: Add J314 and J316 devicetrees

These are the 14-inch and 16-inch 2021 MacBooks, in both M1 Pro and M1
Max variants (t6000 and t6001).

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/Makefile            |   4 +
 arch/arm64/boot/dts/apple/t6000-j314s.dts     |  18 ++
 arch/arm64/boot/dts/apple/t6000-j316s.dts     |  18 ++
 arch/arm64/boot/dts/apple/t6001-j314c.dts     |  18 ++
 arch/arm64/boot/dts/apple/t6001-j316c.dts     |  18 ++
 .../arm64/boot/dts/apple/t600x-j314-j316.dtsi | 205 ++++++++++++++++++
 6 files changed, 281 insertions(+)
 create mode 100644 arch/arm64/boot/dts/apple/t6000-j314s.dts
 create mode 100644 arch/arm64/boot/dts/apple/t6000-j316s.dts
 create mode 100644 arch/arm64/boot/dts/apple/t6001-j314c.dts
 create mode 100644 arch/arm64/boot/dts/apple/t6001-j316c.dts
 create mode 100644 arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi

diff --git a/arch/arm64/boot/dts/apple/Makefile b/arch/arm64/boot/dts/apple/Makefile
index cbbd701ebf05..8a94ff229ff9 100644
--- a/arch/arm64/boot/dts/apple/Makefile
+++ b/arch/arm64/boot/dts/apple/Makefile
@@ -1,2 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 dtb-$(CONFIG_ARCH_APPLE) += t8103-j274.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t6000-j314s.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t6001-j314c.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t6000-j316s.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t6001-j316c.dtb
diff --git a/arch/arm64/boot/dts/apple/t6000-j314s.dts b/arch/arm64/boot/dts/apple/t6000-j314s.dts
new file mode 100644
index 000000000000..c9e192848fe3
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t6000-j314s.dts
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * MacBook Pro (14-inch, M1 Pro, 2021)
+ *
+ * target-type: J314s
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t6000.dtsi"
+#include "t600x-j314-j316.dtsi"
+
+/ {
+	compatible = "apple,j314s", "apple,t6000", "apple,arm-platform";
+	model = "Apple MacBook Pro (14-inch, M1 Pro, 2021)";
+};
diff --git a/arch/arm64/boot/dts/apple/t6000-j316s.dts b/arch/arm64/boot/dts/apple/t6000-j316s.dts
new file mode 100644
index 000000000000..ff1803ce2300
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t6000-j316s.dts
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * MacBook Pro (16-inch, M1 Pro, 2021)
+ *
+ * target-type: J316s
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t6000.dtsi"
+#include "t600x-j314-j316.dtsi"
+
+/ {
+	compatible = "apple,j316s", "apple,t6000", "apple,arm-platform";
+	model = "Apple MacBook Pro (16-inch, M1 Pro, 2021)";
+};
diff --git a/arch/arm64/boot/dts/apple/t6001-j314c.dts b/arch/arm64/boot/dts/apple/t6001-j314c.dts
new file mode 100644
index 000000000000..1761d15b98c1
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t6001-j314c.dts
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * MacBook Pro (14-inch, M1 Max, 2021)
+ *
+ * target-type: J314c
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t6001.dtsi"
+#include "t600x-j314-j316.dtsi"
+
+/ {
+	compatible = "apple,j314c", "apple,t6001", "apple,arm-platform";
+	model = "Apple MacBook Pro (14-inch, M1 Max, 2021)";
+};
diff --git a/arch/arm64/boot/dts/apple/t6001-j316c.dts b/arch/arm64/boot/dts/apple/t6001-j316c.dts
new file mode 100644
index 000000000000..750e9beeffc0
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t6001-j316c.dts
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * MacBook Pro (16-inch, M1 Max, 2021)
+ *
+ * target-type: J316c
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t6001.dtsi"
+#include "t600x-j314-j316.dtsi"
+
+/ {
+	compatible = "apple,j316c", "apple,t6001", "apple,arm-platform";
+	model = "Apple MacBook Pro (16-inch, M1 Max, 2021)";
+};
diff --git a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
new file mode 100644
index 000000000000..beacabb1ff07
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
@@ -0,0 +1,205 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * MacBook Pro (14/16-inch, 2021)
+ *
+ * This file contains the parts common to J314 and J316 devices with both t6000 and t6001.
+ *
+ * target-type: J314s / J314c / J316s / J316c
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/ {
+	aliases {
+		serial0 = &serial0;
+		wifi0 = &wifi0;
+	};
+
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		stdout-path = "serial0";
+
+		framebuffer0: framebuffer@0 {
+			compatible = "apple,simple-framebuffer", "simple-framebuffer";
+			reg = <0 0 0 0>; /* To be filled by loader */
+			/* Format properties will be added by loader */
+			status = "disabled";
+		};
+	};
+
+	memory@10000000000 {
+		device_type = "memory";
+		reg = <0x100 0 0x2 0>; /* To be filled by loader */
+	};
+};
+
+&serial0 {
+	status = "okay";
+};
+
+/* USB Type C */
+&i2c0 {
+	hpm0: tps6598x@38 {
+		compatible = "apple,cd321x";
+		reg = <0x38>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <174 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+
+		typec0: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C Left Rear";
+			power-role = "dual";
+			data-role = "dual";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					typec0_con_hs: endpoint {
+						remote-endpoint = <&typec0_usb_hs>;
+					};
+				};
+			};
+		};
+	};
+
+	hpm1: tps6598x@3f {
+		compatible = "apple,cd321x";
+		reg = <0x3f>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <174 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+
+		typec1: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C Left Front";
+			power-role = "dual";
+			data-role = "dual";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					typec1_con_hs: endpoint {
+						remote-endpoint = <&typec1_usb_hs>;
+					};
+				};
+			};
+		};
+	};
+
+	hpm2: tps6598x@3b {
+		compatible = "apple,cd321x";
+		reg = <0x3b>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <174 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+
+		typec2: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C Right";
+			power-role = "dual";
+			data-role = "dual";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					typec2_con_hs: endpoint {
+						remote-endpoint = <&typec2_usb_hs>;
+					};
+				};
+			};
+		};
+	};
+
+	/* MagSafe port */
+	hpm5: tps6598x@3a {
+		compatible = "apple,cd321x";
+		reg = <0x3a>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <174 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+	};
+};
+
+/* PCIe devices */
+&port00 {
+	/* WLAN */
+	bus-range = <1 1>;
+	wifi0: pci@0,0 {
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+		/* To be filled by the loader */
+		local-mac-address = [00 10 18 00 00 10];
+	};
+};
+
+&port01 {
+	/* SD card reader */
+	bus-range = <2 2>;
+	max-link-speed = <1>;
+	sdhci0: pci@0,0 {
+		reg = <0x20000 0x0 0x0 0x0 0x0>;
+		cd-inverted;
+		wp-inverted;
+	};
+};
+
+&pcie0_dart_2 {
+	status = "disabled";
+};
+
+&pcie0_dart_3 {
+	status = "disabled";
+};
+
+/delete-node/ &port02;
+/delete-node/ &port03;
+
+/* USB controllers */
+&dwc3_0 {
+	port@0 {
+		reg = <0>;
+		typec0_usb_hs: endpoint {
+			remote-endpoint = <&typec0_con_hs>;
+		};
+	};
+};
+
+&dwc3_1 {
+	port@0 {
+		reg = <0>;
+		typec1_usb_hs: endpoint {
+			remote-endpoint = <&typec1_con_hs>;
+		};
+	};
+};
+
+&dwc3_2 {
+	port@0 {
+		reg = <0>;
+		typec2_usb_hs: endpoint {
+			remote-endpoint = <&typec2_con_hs>;
+		};
+	};
+};
+
+/* ATC3 is used for DisplayPort -> HDMI only */
+&dwc3_3_dart_0 {
+	status = "disabled";
+};
+
+&dwc3_3_dart_1 {
+	status = "disabled";
+};
+
+&dwc3_3 {
+	status = "disabled";
+};
-- 
2.34.0


From f21e59cd111661ba0bce961a5bb58687abfe324e Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 3 Nov 2021 04:24:10 +0900
Subject: [PATCH 08/83] io-pgtable-arm: Fix table descriptor paddr formatting

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/iommu/io-pgtable-arm.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c
index be66774aaf70..0c3208438c26 100644
--- a/drivers/iommu/io-pgtable-arm.c
+++ b/drivers/iommu/io-pgtable-arm.c
@@ -343,12 +343,12 @@ static int arm_lpae_init_pte(struct arm_lpae_io_pgtable *data,
 static arm_lpae_iopte arm_lpae_install_table(arm_lpae_iopte *table,
 					     arm_lpae_iopte *ptep,
 					     arm_lpae_iopte curr,
-					     struct io_pgtable_cfg *cfg)
+					     struct arm_lpae_io_pgtable *data)
 {
 	arm_lpae_iopte old, new;
 
-	new = __pa(table) | ARM_LPAE_PTE_TYPE_TABLE;
-	if (cfg->quirks & IO_PGTABLE_QUIRK_ARM_NS)
+	new = paddr_to_iopte(__pa(table), data) | ARM_LPAE_PTE_TYPE_TABLE;
+	if (data->iop.cfg.quirks & IO_PGTABLE_QUIRK_ARM_NS)
 		new |= ARM_LPAE_PTE_NSTABLE;
 
 	/*
@@ -360,11 +360,11 @@ static arm_lpae_iopte arm_lpae_install_table(arm_lpae_iopte *table,
 
 	old = cmpxchg64_relaxed(ptep, curr, new);
 
-	if (cfg->coherent_walk || (old & ARM_LPAE_PTE_SW_SYNC))
+	if (data->iop.cfg.coherent_walk || (old & ARM_LPAE_PTE_SW_SYNC))
 		return old;
 
 	/* Even if it's not ours, there's no point waiting; just kick it */
-	__arm_lpae_sync_pte(ptep, 1, cfg);
+	__arm_lpae_sync_pte(ptep, 1, &data->iop.cfg);
 	if (old == curr)
 		WRITE_ONCE(*ptep, new | ARM_LPAE_PTE_SW_SYNC);
 
@@ -408,7 +408,7 @@ static int __arm_lpae_map(struct arm_lpae_io_pgtable *data, unsigned long iova,
 		if (!cptep)
 			return -ENOMEM;
 
-		pte = arm_lpae_install_table(cptep, ptep, 0, cfg);
+		pte = arm_lpae_install_table(cptep, ptep, 0, data);
 		if (pte)
 			__arm_lpae_free_pages(cptep, tblsz, cfg);
 	} else if (!cfg->coherent_walk && !(pte & ARM_LPAE_PTE_SW_SYNC)) {
@@ -620,7 +620,7 @@ static size_t arm_lpae_split_blk_unmap(struct arm_lpae_io_pgtable *data,
 		__arm_lpae_init_pte(data, blk_paddr, pte, lvl, 1, &tablep[i]);
 	}
 
-	pte = arm_lpae_install_table(tablep, ptep, blk_pte, cfg);
+	pte = arm_lpae_install_table(tablep, ptep, blk_pte, data);
 	if (pte != blk_pte) {
 		__arm_lpae_free_pages(tablep, tablesz, cfg);
 		/*
-- 
2.34.0


From b4349ea2f292e0e1dc9ee72d5108ea187d89aa4f Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 16:40:28 +0900
Subject: [PATCH 09/83] PCI: apple: Fix REFCLK1 enable/poll logic

REFCLK1 has req/ack bits just like REFCLK0

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/pci/controller/pcie-apple.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/drivers/pci/controller/pcie-apple.c b/drivers/pci/controller/pcie-apple.c
index 1bf4d75b61be..e1b96c2e669a 100644
--- a/drivers/pci/controller/pcie-apple.c
+++ b/drivers/pci/controller/pcie-apple.c
@@ -42,8 +42,9 @@
 #define   CORE_FABRIC_STAT_MASK		0x001F001F
 #define CORE_LANE_CFG(port)		(0x84000 + 0x4000 * (port))
 #define   CORE_LANE_CFG_REFCLK0REQ	BIT(0)
-#define   CORE_LANE_CFG_REFCLK1		BIT(1)
+#define   CORE_LANE_CFG_REFCLK1REQ	BIT(1)
 #define   CORE_LANE_CFG_REFCLK0ACK	BIT(2)
+#define   CORE_LANE_CFG_REFCLK1ACK	BIT(3)
 #define   CORE_LANE_CFG_REFCLKEN	(BIT(9) | BIT(10))
 #define CORE_LANE_CTL(port)		(0x84004 + 0x4000 * (port))
 #define   CORE_LANE_CTL_CFGACC		BIT(15)
@@ -482,9 +483,9 @@ static int apple_pcie_setup_refclk(struct apple_pcie *pcie,
 	if (res < 0)
 		return res;
 
-	rmw_set(CORE_LANE_CFG_REFCLK1, pcie->base + CORE_LANE_CFG(port->idx));
+	rmw_set(CORE_LANE_CFG_REFCLK1REQ, pcie->base + CORE_LANE_CFG(port->idx));
 	res = readl_relaxed_poll_timeout(pcie->base + CORE_LANE_CFG(port->idx),
-					 stat, stat & CORE_LANE_CFG_REFCLK1,
+					 stat, stat & CORE_LANE_CFG_REFCLK1ACK,
 					 100, 50000);
 
 	if (res < 0)
-- 
2.34.0


From 0e089844310e78bc887f976ef5c81ca70ebcba02 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 16:43:13 +0900
Subject: [PATCH 10/83] PCI: apple: Enable clock gating

These pokes are not required to make the PCIe port work, but it sounds
like this should save some power at least.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/pci/controller/pcie-apple.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/pci/controller/pcie-apple.c b/drivers/pci/controller/pcie-apple.c
index e1b96c2e669a..f98551336b42 100644
--- a/drivers/pci/controller/pcie-apple.c
+++ b/drivers/pci/controller/pcie-apple.c
@@ -554,6 +554,9 @@ static int apple_pcie_setup_port(struct apple_pcie *pcie,
 		return ret;
 	}
 
+	rmw_clear(PORT_REFCLK_CGDIS, port->base + PORT_REFCLK);
+	rmw_clear(PORT_APPCLK_CGDIS, port->base + PORT_APPCLK);
+
 	ret = apple_pcie_port_setup_irq(port);
 	if (ret)
 		return ret;
-- 
2.34.0


From a155669ebf8286ed412c08bca109774a7db9de42 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Sun, 7 Nov 2021 11:21:19 +0100
Subject: [PATCH 11/83] dt-bindings: usb: Add Apple dwc3 bindings

Apple Silicon SoCs such as the M1 have multiple USB controllers based on
the Synopsys DesignWare USB3 controller.
References to the ATC PHY required for SuperSpeed are left out for now
until support has been upstreamed as well.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 .../devicetree/bindings/usb/apple,dwc3.yaml   | 64 +++++++++++++++++++
 MAINTAINERS                                   |  1 +
 2 files changed, 65 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/usb/apple,dwc3.yaml

diff --git a/Documentation/devicetree/bindings/usb/apple,dwc3.yaml b/Documentation/devicetree/bindings/usb/apple,dwc3.yaml
new file mode 100644
index 000000000000..fb3b3489e6b2
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/apple,dwc3.yaml
@@ -0,0 +1,64 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/apple,dwc3.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Apple Silicon DWC3 USB controller
+
+maintainers:
+  - Sven Peter <sven@svenpeter.dev>
+
+description:
+  On Apple Silicon SoCs such as the M1 each Type-C port has a corresponding
+  USB controller based on the Synopsys DesignWare USB3 controller.
+
+  The common content of this binding is defined in snps,dwc3.yaml.
+
+allOf:
+  - $ref: snps,dwc3.yaml#
+
+select:
+  properties:
+    compatible:
+      contains:
+        const: apple,dwc3
+  required:
+    - compatible
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - apple,t8103-dwc3
+          - apple,t6000-dwc3
+      - const: apple,dwc3
+      - const: snps,dwc3
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+unevaluatedProperties: false
+
+required:
+  - compatible
+  - reg
+  - interrupts
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/apple-aic.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+    usb@82280000 {
+      compatible = "apple,t8103-dwc3", "apple,dwc3", "snps,dwc3";
+      reg = <0x82280000 0x10000>;
+      interrupts = <AIC_IRQ 777 IRQ_TYPE_LEVEL_HIGH>;
+
+      dr_mode = "otg";
+      usb-role-switch;
+      role-switch-default-mode = "host";
+    };
diff --git a/MAINTAINERS b/MAINTAINERS
index 5250298d2817..29314357908c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1750,6 +1750,7 @@ F:	Documentation/devicetree/bindings/interrupt-controller/apple,aic.yaml
 F:	Documentation/devicetree/bindings/mailbox/apple,mailbox.yaml
 F:	Documentation/devicetree/bindings/pci/apple,pcie.yaml
 F:	Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
+F:	Documentation/devicetree/bindings/usb/apple,dwc3.yaml
 F:	arch/arm64/boot/dts/apple/
 F:	drivers/i2c/busses/i2c-pasemi-core.c
 F:	drivers/i2c/busses/i2c-pasemi-platform.c
-- 
2.34.0


From 870493239cc227d42c66280f96c20ddd540f58f6 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Sun, 7 Nov 2021 11:21:20 +0100
Subject: [PATCH 12/83] usb: dwc3: Add role switch reset quirk for Apple DWC3

As mad as it sounds, the dwc3 controller present on the Apple M1 must be
reset and reinitialized whenever a device is unplugged from the root port.
The only reliable unplug/plug notification available comes from the USB
PD controller through the role-switch infrastructure.

This is required for at least two reasons:

  - The USB2 D+/D- lines are connected through a stateful eUSB2 repeater
    which in turn is controlled by a variant of the TI TPS6598x USB PD
    chip. When the USB PD controller detects a hotplug event it resets
    the eUSB2 repeater. Afterwards, no new device is recognized before
    the DWC3 core and PHY are reset as well.

  - It's possible to completely break the dwc3 controller by switching
    it to device mode and unplugging the cable at just the wrong time.
    Even a CORESOFTRESET is not enough to allow new devices again.
    The only workaround is to trigger a hard reset of the entire
    dwc3 core.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/usb/dwc3/core.c | 39 ++++++++++++++++++++++++++++++++++++---
 drivers/usb/dwc3/core.h |  6 ++++++
 drivers/usb/dwc3/drd.c  |  7 +++++++
 3 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 643239d7d370..97b6e6a743c9 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -116,6 +116,8 @@ void dwc3_set_prtcap(struct dwc3 *dwc, u32 mode)
 }
 
 static int dwc3_core_soft_reset(struct dwc3 *dwc);
+static void dwc3_core_exit(struct dwc3 *dwc);
+static int dwc3_core_init_for_resume(struct dwc3 *dwc);
 
 static void __dwc3_set_mode(struct work_struct *work)
 {
@@ -131,10 +133,11 @@ static void __dwc3_set_mode(struct work_struct *work)
 	if (dwc->current_dr_role == DWC3_GCTL_PRTCAP_OTG)
 		dwc3_otg_update(dwc, 0);
 
-	if (!dwc->desired_dr_role)
+	if (!dwc->desired_dr_role && !dwc->role_switch_reset_quirk)
 		goto out;
 
-	if (dwc->desired_dr_role == dwc->current_dr_role)
+	if (dwc->desired_dr_role == dwc->current_dr_role &&
+			!dwc->role_switch_reset_quirk)
 		goto out;
 
 	if (dwc->desired_dr_role == DWC3_GCTL_PRTCAP_OTG && dwc->edev)
@@ -159,6 +162,34 @@ static void __dwc3_set_mode(struct work_struct *work)
 		break;
 	}
 
+	if (dwc->role_switch_reset_quirk) {
+		if (dwc->current_dr_role) {
+			dwc->current_dr_role = 0;
+			dwc3_core_exit(dwc);
+		}
+
+		if (dwc->desired_dr_role) {
+			/*
+			 * the first call to __dwc3_set_mode comes from
+			 * dwc3_drd_init. In that case dwc3_core_init has been
+			 * called but dwc->current_dr_role is zero such that
+			 * we must not reinitialize the core again here.
+			 */
+			if (dwc->role_switch_reset_quirk_initialized) {
+				ret = dwc3_core_init_for_resume(dwc);
+				if (ret) {
+					dev_err(dwc->dev,
+					    "failed to reinitialize core\n");
+					goto out;
+				}
+			}
+
+			dwc->role_switch_reset_quirk_initialized = 1;
+		} else {
+			goto out;
+		}
+	}
+
 	/* For DRD host or device mode only */
 	if (dwc->desired_dr_role != DWC3_GCTL_PRTCAP_OTG) {
 		reg = dwc3_readl(dwc->regs, DWC3_GCTL);
@@ -1615,6 +1646,8 @@ static int dwc3_probe(struct platform_device *pdev)
 		else
 			dwc->num_clks = ret;
 
+		if (of_device_is_compatible(dev->of_node, "apple,dwc3"))
+			dwc->role_switch_reset_quirk = true;
 	}
 
 	ret = reset_control_deassert(dwc->reset);
@@ -1744,7 +1777,6 @@ static int dwc3_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
 static int dwc3_core_init_for_resume(struct dwc3 *dwc)
 {
 	int ret;
@@ -1771,6 +1803,7 @@ static int dwc3_core_init_for_resume(struct dwc3 *dwc)
 	return ret;
 }
 
+#ifdef CONFIG_PM
 static int dwc3_suspend_common(struct dwc3 *dwc, pm_message_t msg)
 {
 	unsigned long	flags;
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 620c8d3914d7..86312e27fcd6 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -1087,6 +1087,9 @@ struct dwc3_scratchpad_array {
  *	3	- Reserved
  * @dis_metastability_quirk: set to disable metastability quirk.
  * @dis_split_quirk: set to disable split boundary.
+ * @role_switch_reset_quirk: set to force reinitialization after any role switch
+ * @role_switch_reset_quirk_initialized: set to true after the first role switch
+ *			which is triggered from dwc3_drd_init directly
  * @imod_interval: set the interrupt moderation interval in 250ns
  *			increments or 0 to disable.
  * @max_cfg_eps: current max number of IN eps used across all USB configs.
@@ -1300,6 +1303,9 @@ struct dwc3 {
 	unsigned		dis_split_quirk:1;
 	unsigned		async_callbacks:1;
 
+	unsigned		role_switch_reset_quirk:1;
+	unsigned		role_switch_reset_quirk_initialized:1;
+
 	u16			imod_interval;
 
 	int			max_cfg_eps;
diff --git a/drivers/usb/dwc3/drd.c b/drivers/usb/dwc3/drd.c
index d7f76835137f..403e88a72f0e 100644
--- a/drivers/usb/dwc3/drd.c
+++ b/drivers/usb/dwc3/drd.c
@@ -506,6 +506,9 @@ static int dwc3_usb_role_switch_set(struct usb_role_switch *sw,
 		break;
 	}
 
+	if (dwc->role_switch_reset_quirk && role == USB_ROLE_NONE)
+		mode = 0;
+
 	dwc3_set_mode(dwc, mode);
 	return 0;
 }
@@ -534,6 +537,10 @@ static enum usb_role dwc3_usb_role_switch_get(struct usb_role_switch *sw)
 			role = USB_ROLE_DEVICE;
 		break;
 	}
+
+	if (dwc->role_switch_reset_quirk && !dwc->current_dr_role)
+		role = USB_ROLE_NONE;
+
 	spin_unlock_irqrestore(&dwc->lock, flags);
 	return role;
 }
-- 
2.34.0


From 2f69d10360532afabda159e8ecc9f8f14de4b3fc Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 19:38:21 +0900
Subject: [PATCH 13/83] usb: typec: tipd: Fix typo in cd321x_switch_power_state

SPSS -> SSPS

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/usb/typec/tipd/core.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/usb/typec/tipd/core.c b/drivers/usb/typec/tipd/core.c
index fb8ef12bbe9c..4da5a0b2aed2 100644
--- a/drivers/usb/typec/tipd/core.c
+++ b/drivers/usb/typec/tipd/core.c
@@ -653,7 +653,7 @@ static int cd321x_switch_power_state(struct tps6598x *tps, u8 target_state)
 	if (state == target_state)
 		return 0;
 
-	ret = tps6598x_exec_cmd(tps, "SPSS", sizeof(u8), &target_state, 0, NULL);
+	ret = tps6598x_exec_cmd(tps, "SSPS", sizeof(u8), &target_state, 0, NULL);
 	if (ret)
 		return ret;
 
-- 
2.34.0


From 7af4ef002c5344684b7dc24e0ebab31eda0dba52 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 19:41:06 +0900
Subject: [PATCH 14/83] usb: typec: tipd: Fix initialization sequence for
 cd321x

Power state switch needs to happen first, as that kickstarts the
firmware.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/usb/typec/tipd/core.c | 33 ++++++++++++++++-----------------
 1 file changed, 16 insertions(+), 17 deletions(-)

diff --git a/drivers/usb/typec/tipd/core.c b/drivers/usb/typec/tipd/core.c
index 4da5a0b2aed2..6d27a5b5e3ca 100644
--- a/drivers/usb/typec/tipd/core.c
+++ b/drivers/usb/typec/tipd/core.c
@@ -707,6 +707,7 @@ static int tps6598x_probe(struct i2c_client *client)
 	u32 conf;
 	u32 vid;
 	int ret;
+	u64 mask1;
 
 	tps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);
 	if (!tps)
@@ -730,11 +731,6 @@ static int tps6598x_probe(struct i2c_client *client)
 	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
 		tps->i2c_protocol = true;
 
-	/* Make sure the controller has application firmware running */
-	ret = tps6598x_check_mode(tps);
-	if (ret)
-		return ret;
-
 	if (np && of_device_is_compatible(np, "apple,cd321x")) {
 		/* Switch CD321X chips to the correct system power state */
 		ret = cd321x_switch_power_state(tps, TPS_SYSTEM_POWER_STATE_S0);
@@ -742,24 +738,27 @@ static int tps6598x_probe(struct i2c_client *client)
 			return ret;
 
 		/* CD321X chips have all interrupts masked initially */
-		ret = tps6598x_write64(tps, TPS_REG_INT_MASK1,
-					APPLE_CD_REG_INT_POWER_STATUS_UPDATE |
-					APPLE_CD_REG_INT_DATA_STATUS_UPDATE |
-					APPLE_CD_REG_INT_PLUG_EVENT);
-		if (ret)
-			return ret;
+		mask1 = APPLE_CD_REG_INT_POWER_STATUS_UPDATE |
+			APPLE_CD_REG_INT_DATA_STATUS_UPDATE |
+			APPLE_CD_REG_INT_PLUG_EVENT;
 
 		irq_handler = cd321x_interrupt;
 	} else {
 		/* Enable power status, data status and plug event interrupts */
-		ret = tps6598x_write64(tps, TPS_REG_INT_MASK1,
-				       TPS_REG_INT_POWER_STATUS_UPDATE |
-				       TPS_REG_INT_DATA_STATUS_UPDATE |
-				       TPS_REG_INT_PLUG_EVENT);
-		if (ret)
-			return ret;
+		mask1 = TPS_REG_INT_POWER_STATUS_UPDATE |
+			TPS_REG_INT_DATA_STATUS_UPDATE |
+			TPS_REG_INT_PLUG_EVENT;
 	}
 
+	/* Make sure the controller has application firmware running */
+	ret = tps6598x_check_mode(tps);
+	if (ret)
+		return ret;
+
+	ret = tps6598x_write64(tps, TPS_REG_INT_MASK1, mask1);
+	if (ret)
+		return ret;
+
 	ret = tps6598x_read32(tps, TPS_REG_STATUS, &status);
 	if (ret < 0)
 		return ret;
-- 
2.34.0


From 095726770a814fec0f8a7f9dbf3f326dfdb29bce Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 18:59:46 +0900
Subject: [PATCH 15/83] mmc: sdhci-pci-gli: GL9755: Support for CD/WP inversion
 on OF platforms

This is required on some Apple ARM64 laptops using this controller.
As is typical on DT platforms, pull these quirks from the device tree
using the standard mmc bindings.

See Documentation/devicetree/bindings/mmc/mmc-controller.yaml

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/mmc/host/sdhci-pci-gli.c | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/drivers/mmc/host/sdhci-pci-gli.c b/drivers/mmc/host/sdhci-pci-gli.c
index 4fd99c1e82ba..ad742743a494 100644
--- a/drivers/mmc/host/sdhci-pci-gli.c
+++ b/drivers/mmc/host/sdhci-pci-gli.c
@@ -12,6 +12,7 @@
 #include <linux/pci.h>
 #include <linux/mmc/mmc.h>
 #include <linux/delay.h>
+#include <linux/of.h>
 #include "sdhci.h"
 #include "sdhci-pci.h"
 #include "cqhci.h"
@@ -114,8 +115,10 @@
 #define   GLI_9755_WT_EN_OFF    0x0
 
 #define PCI_GLI_9755_PECONF   0x44
-#define   PCI_GLI_9755_LFCLK    GENMASK(14, 12)
-#define   PCI_GLI_9755_DMACLK   BIT(29)
+#define   PCI_GLI_9755_LFCLK          GENMASK(14, 12)
+#define   PCI_GLI_9755_DMACLK         BIT(29)
+#define   PCI_GLI_9755_INVERT_CD      BIT(30)
+#define   PCI_GLI_9755_INVERT_WP      BIT(31)
 
 #define PCI_GLI_9755_CFG2          0x48
 #define   PCI_GLI_9755_CFG2_L1DLY    GENMASK(28, 24)
@@ -570,6 +573,18 @@ static void gl9755_hw_setting(struct sdhci_pci_slot *slot)
 	gl9755_wt_on(pdev);
 
 	pci_read_config_dword(pdev, PCI_GLI_9755_PECONF, &value);
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node) {
+		/*
+		 * Apple ARM64 platforms using these chips may have
+		 * inverted CD/WP detection.
+		 */
+		if (of_property_read_bool(pdev->dev.of_node, "cd-inverted"))
+			value |= PCI_GLI_9755_INVERT_CD;
+		if (of_property_read_bool(pdev->dev.of_node, "wp-inverted"))
+			value |= PCI_GLI_9755_INVERT_WP;
+	}
+#endif
 	value &= ~PCI_GLI_9755_LFCLK;
 	value &= ~PCI_GLI_9755_DMACLK;
 	pci_write_config_dword(pdev, PCI_GLI_9755_PECONF, value);
-- 
2.34.0


From 4bd1bcd5856c73109ed5c2f4ac2ab970654701bd Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 19:01:43 +0900
Subject: [PATCH 16/83] mmc: sdhci-pci-gli: GL9755: Issue 8/16-bit MMIO reads
 as 32-bit reads.

For some reason, <32-bit reads do not work on Apple ARM64 platforms with
these chips (even though they do on other PCIe devices). Issue them as
32-bit reads instead. This is done unconditionally, as it shouldn't hurt
even if not necessary.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/mmc/host/sdhci-pci-gli.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/drivers/mmc/host/sdhci-pci-gli.c b/drivers/mmc/host/sdhci-pci-gli.c
index ad742743a494..31547fed0952 100644
--- a/drivers/mmc/host/sdhci-pci-gli.c
+++ b/drivers/mmc/host/sdhci-pci-gli.c
@@ -906,7 +906,26 @@ static int gli_probe_slot_gl9763e(struct sdhci_pci_slot *slot)
 	return 0;
 }
 
+#define REG_OFFSET_IN_BITS(reg) ((reg) << 3 & 0x18)
+
+static u16 sdhci_gli_readw(struct sdhci_host *host, int reg)
+{
+	u32 val = readl(host->ioaddr + (reg & ~3));
+	u16 word;
+	word = (val >> REG_OFFSET_IN_BITS(reg)) & 0xffff;
+	return word;
+}
+
+static u8 sdhci_gli_readb(struct sdhci_host *host, int reg)
+{
+	u32 val = readl(host->ioaddr + (reg & ~3));
+	u8 byte = (val >> REG_OFFSET_IN_BITS(reg)) & 0xff;
+	return byte;
+}
+
 static const struct sdhci_ops sdhci_gl9755_ops = {
+	.read_w			= sdhci_gli_readw,
+	.read_b			= sdhci_gli_readb,
 	.set_clock		= sdhci_gl9755_set_clock,
 	.enable_dma		= sdhci_pci_enable_dma,
 	.set_bus_width		= sdhci_set_bus_width,
-- 
2.34.0


From a449c42f0e7482528fb128271baf1b9f02fca6a2 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Thu, 19 Aug 2021 17:38:29 +0200
Subject: [PATCH 17/83] WIP: soc: apple: rtkit: Add RTKit library

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/soc/Kconfig             |   1 +
 drivers/soc/Makefile            |   1 +
 drivers/soc/apple/Kconfig       |  17 +
 drivers/soc/apple/Makefile      |   3 +
 drivers/soc/apple/apple-rtkit.c | 645 ++++++++++++++++++++++++++++++++
 include/linux/apple-rtkit.h     | 152 ++++++++
 6 files changed, 819 insertions(+)
 create mode 100644 drivers/soc/apple/Kconfig
 create mode 100644 drivers/soc/apple/Makefile
 create mode 100644 drivers/soc/apple/apple-rtkit.c
 create mode 100644 include/linux/apple-rtkit.h

diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index e8a30c4c5aec..a8562678c437 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -3,6 +3,7 @@ menu "SOC (System On Chip) specific Drivers"
 
 source "drivers/soc/actions/Kconfig"
 source "drivers/soc/amlogic/Kconfig"
+source "drivers/soc/apple/Kconfig"
 source "drivers/soc/aspeed/Kconfig"
 source "drivers/soc/atmel/Kconfig"
 source "drivers/soc/bcm/Kconfig"
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index a05e9fbcd3e0..adb30c2d4fea 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -4,6 +4,7 @@
 #
 
 obj-$(CONFIG_ARCH_ACTIONS)	+= actions/
+obj-$(CONFIG_ARCH_APPLE)	+= apple/
 obj-y				+= aspeed/
 obj-$(CONFIG_ARCH_AT91)		+= atmel/
 obj-y				+= bcm/
diff --git a/drivers/soc/apple/Kconfig b/drivers/soc/apple/Kconfig
new file mode 100644
index 000000000000..778745219d9f
--- /dev/null
+++ b/drivers/soc/apple/Kconfig
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-only
+if ARCH_APPLE || COMPILE_TEST
+menu "Apple SoC drivers"
+
+config APPLE_RTKIT
+	bool "Apple RTKit co-processor IPC protocol"
+	depends on ARCH_APPLE || COMPILE_TEST
+	default ARCH_APPLE
+	help
+	  Apple SoCs such as the M1 come with various co-processors running
+	  their proprietary RTKit operating system. This option enables support
+	  for the common IPC protocl used by these.
+
+	  Say 'y' here if you have an Apple SoC.
+
+endmenu
+endif
diff --git a/drivers/soc/apple/Makefile b/drivers/soc/apple/Makefile
new file mode 100644
index 000000000000..be42b7f7519d
--- /dev/null
+++ b/drivers/soc/apple/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_APPLE_RTKIT) += apple-rtkit.o
diff --git a/drivers/soc/apple/apple-rtkit.c b/drivers/soc/apple/apple-rtkit.c
new file mode 100644
index 000000000000..086ebcf2e2f2
--- /dev/null
+++ b/drivers/soc/apple/apple-rtkit.c
@@ -0,0 +1,645 @@
+// SPDX-License-Identifier: GPL-2.0-only OR MIT
+
+#include <linux/apple-rtkit.h>
+#include <linux/apple-mailbox.h>
+#include <linux/bitfield.h>
+#include <linux/bitmap.h>
+#include <linux/completion.h>
+#include <linux/kthread.h>
+#include <linux/kfifo.h>
+#include <linux/dma-mapping.h>
+#include <linux/mailbox_client.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+
+#define rtk_err(format, arg...) dev_err(rtk->dev, "RTKit: " format, ##arg)
+#define rtk_warn(format, arg...) dev_warn(rtk->dev, "RTKit: " format, ##arg)
+#define rtk_info(format, arg...) dev_info(rtk->dev, "RTKit: " format, ##arg)
+#define rtk_dbg(format, arg...) dev_dbg(rtk->dev, "RTKit: " format, ##arg)
+
+struct apple_rtkit_shmem {
+	void *buffer;
+	void __iomem *iomem;
+	size_t size;
+	dma_addr_t iova;
+};
+
+enum { APPLE_RTKIT_STATE_INIT,
+       APPLE_RTKIT_STATE_BOOTING,
+       APPLE_RTKIT_STATE_RUNNING,
+       APPLE_RTKIT_STATE_BOOT_FAILED,
+};
+
+struct apple_rtkit {
+	void *cookie;
+	const struct apple_rtkit_ops *ops;
+	struct device *dev;
+	void __iomem *regs;
+	struct mbox_client mbox_cl;
+	struct mbox_chan *mbox_chan;
+	struct completion boot_completion;
+	unsigned state;
+	int boot_result;
+	int version;
+
+	struct wait_queue_head wq;
+	DECLARE_KFIFO(msg_fifo, struct apple_mbox_msg, 64);
+
+	DECLARE_BITMAP(endpoints, 0x100);
+
+	struct apple_rtkit_shmem ioreport_buffer;
+	struct apple_rtkit_shmem crashlog_buffer;
+
+	struct apple_rtkit_shmem syslog_buffer;
+	char *syslog_msg_buffer;
+	size_t syslog_n_entries;
+	size_t syslog_msg_size;
+};
+
+#define APPLE_RTKIT_CPU_CONTROL 0x44
+#define APPLE_RTKIT_CPU_CONTROL_RUN BIT(4)
+
+#define APPLE_RTKIT_EP_MGMT 0
+#define APPLE_RTKIT_EP_CRASHLOG 1
+#define APPLE_RTKIT_EP_SYSLOG 2
+#define APPLE_RTKIT_EP_DEBUG 3
+#define APPLE_RTKIT_EP_IOREPORT 4
+
+#define APPLE_RTKIT_MGMT_WAKEUP 0x60000000000220
+
+#define APPLE_RTKIT_MGMT_TYPE GENMASK(59, 52)
+
+#define APPLE_RTKIT_MGMT_HELLO 1
+#define APPLE_RTKIT_MGMT_HELLO_REPLY 2
+#define APPLE_RTKIT_MGMT_HELLO_MINVER GENMASK(15, 0)
+#define APPLE_RTKIT_MGMT_HELLO_MAXVER GENMASK(31, 16)
+
+#define APPLE_RTKIT_MGMT_EPMAP 8
+#define APPLE_RTKIT_MGMT_EPMAP_LAST BIT(51)
+#define APPLE_RTKIT_MGMT_EPMAP_BASE GENMASK(34, 32)
+#define APPLE_RTKIT_MGMT_EPMAP_BITMAP GENMASK(31, 0)
+
+#define APPLE_RTKIT_MGMT_EPMAP_REPLY 8
+#define APPLE_RTKIT_MGMT_EPMAP_REPLY_MORE BIT(0)
+
+#define APPLE_RTKIT_MGMT_STARTEP 5
+#define APPLE_RTKIT_MGMT_STARTEP_EP GENMASK(39, 32)
+#define APPLE_RTKIT_MGMT_STARTEP_FLAG BIT(1)
+
+#define APPLE_RTKIT_MGMT_BOOT_DONE 7
+#define APPLE_RTKIT_MGMT_BOOT_DONE_UNK GENMASK(15, 0)
+
+#define APPLE_RTKIT_MGMT_BOOT_DONE2 0xb
+
+#define APPLE_RTKIT_CRASHLOG_CRASH 1
+
+#define APPLE_RTKIT_BUFFER_REQUEST 1
+#define APPLE_RTKIT_BUFFER_REQUEST_SIZE GENMASK(51, 44)
+#define APPLE_RTKIT_BUFFER_REQUEST_IOVA GENMASK(41, 0)
+
+#define APPLE_RTKIT_SYSLOG_TYPE GENMASK(59, 52)
+
+#define APPLE_RTKIT_SYSLOG_LOG 5
+
+#define APPLE_RTKIT_SYSLOG_INIT 8
+#define APPLE_RTKIT_SYSLOG_N_ENTRIES GENMASK(7, 0)
+#define APPLE_RTKIT_SYSLOG_MSG_SIZE GENMASK(31, 24)
+
+#define APPLE_RTKIT_MIN_SUPPORTED_VERSION 11
+#define APPLE_RTKIT_MAX_SUPPORTED_VERSION 12
+
+static void apple_rtkit_boot_abort(struct apple_rtkit *rtk, int res)
+{
+	WARN_ON(rtk->state != APPLE_RTKIT_STATE_BOOTING);
+	rtk->state = APPLE_RTKIT_STATE_BOOT_FAILED;
+	rtk->boot_result = res;
+	mbox_free_channel(rtk->mbox_chan);
+	complete(&rtk->boot_completion);
+}
+
+static void apple_rtkit_management_send(struct apple_rtkit *rtk, u8 type,
+					u64 msg)
+{
+	msg &= ~APPLE_RTKIT_MGMT_TYPE;
+	msg |= FIELD_PREP(APPLE_RTKIT_MGMT_TYPE, type);
+	apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_MGMT, msg);
+}
+
+static void apple_rtkit_management_rx_hello(struct apple_rtkit *rtk, u64 msg)
+{
+	u64 reply;
+
+	int min_ver = FIELD_GET(APPLE_RTKIT_MGMT_HELLO_MINVER, msg);
+	int max_ver = FIELD_GET(APPLE_RTKIT_MGMT_HELLO_MAXVER, msg);
+	int want_ver = min(APPLE_RTKIT_MAX_SUPPORTED_VERSION, max_ver);
+
+	rtk_dbg("Min ver %d, max ver %d\n", min_ver, max_ver);
+
+	if (min_ver > APPLE_RTKIT_MAX_SUPPORTED_VERSION) {
+		rtk_err("Firmware min version %d is too new\n", min_ver);
+		apple_rtkit_boot_abort(rtk, -ENOTSUPP);
+		return;
+	}
+
+	if (max_ver < APPLE_RTKIT_MIN_SUPPORTED_VERSION) {
+		rtk_err("Firmware max version %d is too old\n", max_ver);
+		apple_rtkit_boot_abort(rtk, -ENOTSUPP);
+		return;
+	}
+
+	rtk_info("Initializing (protocol version %d)\n", want_ver);
+	rtk->version = want_ver;
+
+	reply = FIELD_PREP(APPLE_RTKIT_MGMT_HELLO_MINVER, want_ver) |
+		FIELD_PREP(APPLE_RTKIT_MGMT_HELLO_MAXVER, want_ver);
+
+	apple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_HELLO_REPLY, reply);
+}
+
+static void apple_rtkit_management_rx_epmap(struct apple_rtkit *rtk, u64 msg)
+{
+	int i, ep;
+	u64 reply;
+
+	for (i = 0; i < 32; ++i) {
+		u32 bitmap = FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BITMAP, msg);
+		u32 base = FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BASE, msg);
+		if (bitmap & BIT(i))
+			set_bit(32 * base + i, rtk->endpoints);
+	}
+
+	reply = FIELD_PREP(APPLE_RTKIT_MGMT_EPMAP_BASE,
+			   FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BASE, msg));
+	if (msg & APPLE_RTKIT_MGMT_EPMAP_LAST)
+		reply |= APPLE_RTKIT_MGMT_EPMAP_LAST;
+	else
+		reply |= APPLE_RTKIT_MGMT_EPMAP_REPLY_MORE;
+
+	apple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_EPMAP_REPLY, reply);
+
+	if (msg & APPLE_RTKIT_MGMT_EPMAP_LAST) {
+		for_each_set_bit (ep, rtk->endpoints, 0x100) {
+			switch (ep) {
+			/* the management endpoint is started by default */
+			case APPLE_RTKIT_EP_MGMT:
+				break;
+
+			/*
+                         * we need to start at least these system endpoints or
+                         * RTKit refuses to boot
+                         */
+			case APPLE_RTKIT_EP_SYSLOG:
+			case APPLE_RTKIT_EP_CRASHLOG:
+			case APPLE_RTKIT_EP_DEBUG:
+			case APPLE_RTKIT_EP_IOREPORT:
+				apple_rtkit_start_ep(rtk, ep);
+				break;
+
+			/*
+                         * everything above 0x20 is an app-specific endpoint
+                         * which can be started later by the driver itself
+                         */
+			case 0x20 ... 0xff:
+				break;
+
+			default:
+				rtk_warn("Unknown system ep: %d\n", ep);
+			}
+		}
+	}
+}
+
+static void apple_rtkit_management_rx_boot_done(struct apple_rtkit *rtk,
+						u64 msg)
+{
+	u64 reply;
+	reply = FIELD_PREP(APPLE_RTKIT_MGMT_BOOT_DONE_UNK, 0x20);
+	apple_rtkit_management_send(rtk, 0xb, reply);
+}
+
+static void apple_rtkit_management_rx_boot_done2(struct apple_rtkit *rtk,
+						 u64 msg)
+{
+	rtk->state = APPLE_RTKIT_STATE_RUNNING;
+	complete_all(&rtk->boot_completion);
+	rtk_info("system endpoints successfuly initialized!");
+}
+
+static void apple_rtkit_management_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_MGMT_TYPE, msg);
+
+	switch (type) {
+	case APPLE_RTKIT_MGMT_HELLO:
+		apple_rtkit_management_rx_hello(rtk, msg);
+		break;
+	case APPLE_RTKIT_MGMT_EPMAP:
+		apple_rtkit_management_rx_epmap(rtk, msg);
+		break;
+	case APPLE_RTKIT_MGMT_BOOT_DONE:
+		apple_rtkit_management_rx_boot_done(rtk, msg);
+		break;
+	case APPLE_RTKIT_MGMT_BOOT_DONE2:
+		apple_rtkit_management_rx_boot_done2(rtk, msg);
+		break;
+	}
+}
+
+static void
+apple_rtkit_common_rx_get_buffer_linux(struct apple_rtkit *rtk,
+				       struct apple_rtkit_shmem *buffer, u8 ep,
+				       u64 msg)
+{
+	size_t size = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_SIZE, msg) << 12;
+	dma_addr_t iova = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_IOVA, msg);
+	u64 reply;
+
+	rtk_dbg("DMA buffer request for 0x%zx bytes\n", size);
+
+	if (rtk->ops->shmem_alloc)
+		buffer->buffer = rtk->ops->shmem_alloc(rtk->cookie, size, &iova,
+						       GFP_KERNEL);
+	else
+		buffer->buffer =
+			dma_alloc_coherent(rtk->dev, size, &iova, GFP_KERNEL);
+
+	if (!buffer->buffer) {
+		rtk_warn("couldn't allocate 0x%zx bytes.\n", size);
+		apple_rtkit_boot_abort(rtk, -ENOMEM);
+		return;
+	}
+
+	buffer->size = size;
+	buffer->iova = iova;
+
+	reply = FIELD_PREP(APPLE_RTKIT_SYSLOG_TYPE, APPLE_RTKIT_BUFFER_REQUEST);
+	reply |=
+		FIELD_PREP(APPLE_RTKIT_BUFFER_REQUEST_SIZE, buffer->size >> 12);
+	reply |= FIELD_PREP(APPLE_RTKIT_BUFFER_REQUEST_IOVA, buffer->iova);
+	apple_rtkit_send_message(rtk, ep, reply);
+}
+
+static void
+apple_rtkit_common_rx_get_buffer_rtkit(struct apple_rtkit *rtk,
+				       struct apple_rtkit_shmem *buffer, u8 ep,
+				       u64 msg)
+{
+	size_t size = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_SIZE, msg) << 12;
+	dma_addr_t iova = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_IOVA, msg);
+
+	rtk_dbg("shmem buffer request for 0x%zx bytes at 0x%llx\n", size, iova);
+
+	buffer->size = size;
+	buffer->iova = iova;
+	buffer->iomem = rtk->ops->shmem_map(rtk->cookie, iova, size);
+
+	if (!buffer->iomem) {
+		buffer->size = 0;
+		buffer->iova = 0;
+		rtk_warn("failed to map 0x%zx bytes at 0x%llx\n", size, iova);
+		apple_rtkit_boot_abort(rtk, -ENOMEM);
+	}
+}
+
+static void apple_rtkit_common_rx_get_buffer(struct apple_rtkit *rtk,
+					     struct apple_rtkit_shmem *buffer,
+					     u8 ep, u64 msg)
+{
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT)
+		return apple_rtkit_common_rx_get_buffer_rtkit(rtk, buffer, ep,
+							      msg);
+	else if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_LINUX)
+		return apple_rtkit_common_rx_get_buffer_linux(rtk, buffer, ep,
+							      msg);
+}
+
+static void apple_rtkit_crashlog_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);
+
+	if (type != APPLE_RTKIT_CRASHLOG_CRASH) {
+		rtk_warn("Unknown crashlog message: %llx\n", msg);
+		return;
+	}
+
+	if (!rtk->crashlog_buffer.size)
+		return apple_rtkit_common_rx_get_buffer(rtk,
+							&rtk->crashlog_buffer,
+							APPLE_RTKIT_EP_CRASHLOG,
+							msg);
+
+	rtk_err("co-processor has crashed.\n");
+}
+
+static void apple_rtkit_ioreport_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);
+
+	switch (type) {
+	case APPLE_RTKIT_BUFFER_REQUEST:
+		apple_rtkit_common_rx_get_buffer(rtk, &rtk->ioreport_buffer,
+						 APPLE_RTKIT_EP_IOREPORT, msg);
+		break;
+	/* unknown, must be ACKed */
+	case 0x8:
+	case 0xc:
+		apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_IOREPORT, msg);
+		break;
+	default:
+		rtk_warn("Unknown ioreport message: %llx\n", msg);
+	}
+}
+
+static void apple_rtkit_syslog_rx_init(struct apple_rtkit *rtk, u64 msg)
+{
+	rtk->syslog_n_entries = FIELD_GET(APPLE_RTKIT_SYSLOG_N_ENTRIES, msg);
+	rtk->syslog_msg_size = FIELD_GET(APPLE_RTKIT_SYSLOG_MSG_SIZE, msg);
+
+	rtk->syslog_msg_buffer =
+		devm_kzalloc(rtk->dev, rtk->syslog_msg_size, GFP_KERNEL);
+
+	rtk_dbg("syslog initialized: entries: %zd, msg_size: %zd\n",
+		rtk->syslog_n_entries, rtk->syslog_msg_size);
+}
+
+static void apple_rtkit_memcpy(struct apple_rtkit *rtk, void *dst,
+			       struct apple_rtkit_shmem *bfr, size_t offset,
+			       size_t len)
+{
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT)
+		memcpy_fromio(dst, bfr->iomem + offset, len);
+	else
+		memcpy(dst, bfr->buffer + offset, len);
+}
+
+static void apple_rtkit_syslog_rx_log(struct apple_rtkit *rtk, u64 msg)
+{
+	u32 idx = msg & 0xff;
+	char log_context[24];
+	size_t entry_size = 0x20 + rtk->syslog_msg_size;
+
+	if (!rtk->syslog_buffer.size) {
+		rtk_warn(
+			"received syslog message but syslog_buffer.size is zero");
+		goto done;
+	}
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_LINUX &&
+	    !rtk->syslog_buffer.buffer) {
+		rtk_warn(
+			"received syslog message but have no syslog_buffer.buffer");
+		goto done;
+	}
+	if (rtk->ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT &&
+	    !rtk->syslog_buffer.iomem) {
+		rtk_warn(
+			"received syslog message but have no syslog_buffer.iomem");
+		goto done;
+	}
+	if (idx > rtk->syslog_n_entries) {
+		rtk_warn("syslog index %d out of range", idx);
+		goto done;
+	}
+
+	apple_rtkit_memcpy(rtk, log_context, &rtk->syslog_buffer,
+			   idx * entry_size + 8, sizeof(log_context));
+	apple_rtkit_memcpy(rtk, rtk->syslog_msg_buffer, &rtk->syslog_buffer,
+			   idx * entry_size + 8 + sizeof(log_context),
+			   rtk->syslog_msg_size);
+
+	log_context[sizeof(log_context) - 1] = 0;
+	rtk->syslog_msg_buffer[rtk->syslog_msg_size - 1] = 0;
+	rtk_info("syslog message: %s: %s", log_context, rtk->syslog_msg_buffer);
+
+done:
+	apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_SYSLOG, msg);
+}
+
+static void apple_rtkit_syslog_rx(struct apple_rtkit *rtk, u64 msg)
+{
+	u8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);
+
+	switch (type) {
+	case APPLE_RTKIT_BUFFER_REQUEST:
+		apple_rtkit_common_rx_get_buffer(rtk, &rtk->syslog_buffer,
+						 APPLE_RTKIT_EP_SYSLOG, msg);
+		break;
+	case APPLE_RTKIT_SYSLOG_INIT:
+		apple_rtkit_syslog_rx_init(rtk, msg);
+		break;
+	case APPLE_RTKIT_SYSLOG_LOG:
+		apple_rtkit_syslog_rx_log(rtk, msg);
+		break;
+	default:
+		rtk_warn("Unknown syslog message: %llx\n", msg);
+	}
+}
+
+static void apple_rtkit_rx(struct apple_rtkit *rtk, struct apple_mbox_msg *msg)
+{
+	u8 ep = msg->msg1;
+
+	switch (ep) {
+	case APPLE_RTKIT_EP_MGMT:
+		apple_rtkit_management_rx(rtk, msg->msg0);
+		break;
+	case APPLE_RTKIT_EP_CRASHLOG:
+		apple_rtkit_crashlog_rx(rtk, msg->msg0);
+		break;
+	case APPLE_RTKIT_EP_SYSLOG:
+		apple_rtkit_syslog_rx(rtk, msg->msg0);
+		break;
+	case APPLE_RTKIT_EP_IOREPORT:
+		apple_rtkit_ioreport_rx(rtk, msg->msg0);
+		break;
+	case 0x20 ... 0xff:
+		rtk->ops->recv_message(rtk->cookie, ep, msg->msg0);
+		break;
+	default:
+		rtk_warn("message to unknown endpoint %02x: %llx\n", ep,
+			 msg->msg0);
+	}
+}
+
+static int apple_rtkit_worker(void *data)
+{
+	struct apple_rtkit *rtk = data;
+	struct apple_mbox_msg m;
+
+	while (true) {
+		wait_event_interruptible(rtk->wq,
+					 kfifo_len(&rtk->msg_fifo) > 0);
+
+		if (kfifo_out(&rtk->msg_fifo, &m, 1) == 1)
+			apple_rtkit_rx(rtk, &m);
+	}
+
+	do_exit(0);
+}
+
+static void apple_rtkit_rx_callback(struct mbox_client *cl, void *mssg)
+{
+	struct apple_rtkit *rtk = container_of(cl, struct apple_rtkit, mbox_cl);
+	struct apple_mbox_msg *msg = mssg;
+	u8 ep = msg->msg1;
+
+	dma_rmb();
+
+	if (ep >= 0x20 && (rtk->ops->flags & APPLE_RTKIT_RECV_ATOMIC)) {
+		rtk->ops->recv_message(rtk->cookie, ep, msg->msg0);
+	} else {
+		kfifo_in(&rtk->msg_fifo, msg, 1);
+		wake_up(&rtk->wq);
+	}
+}
+
+int apple_rtkit_send_message(struct apple_rtkit *rtk, u8 ep, u64 message)
+{
+	struct apple_mbox_msg msg;
+	int ret;
+
+	if (WARN_ON(ep >= 0x20 && rtk->state != APPLE_RTKIT_STATE_RUNNING))
+		return -EINVAL;
+
+	msg.msg0 = (u64)message;
+	msg.msg1 = ep;
+	dma_wmb();
+	ret = mbox_send_message(rtk->mbox_chan, &msg);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_send_message);
+
+int apple_rtkit_start_ep(struct apple_rtkit *rtk, u8 endpoint)
+{
+	u64 msg;
+
+	if (WARN_ON(!test_bit(endpoint, rtk->endpoints)))
+		return -EINVAL;
+	if (WARN_ON(endpoint >= 0x20 &&
+		    rtk->state != APPLE_RTKIT_STATE_RUNNING))
+		return -EINVAL;
+
+	msg = FIELD_PREP(APPLE_RTKIT_MGMT_STARTEP_EP, endpoint);
+	msg |= APPLE_RTKIT_MGMT_STARTEP_FLAG;
+	apple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_STARTEP, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_start_ep);
+
+struct apple_rtkit *apple_rtkit_init(struct device *dev, void *cookie,
+				     struct resource *res,
+				     const char *mbox_name,
+				     int mbox_idx,
+				     const struct apple_rtkit_ops *ops)
+{
+	struct apple_rtkit *rtk;
+
+	if (!ops)
+		return ERR_PTR(-EINVAL);
+
+	if (!(ops->flags & APPLE_RTKIT_SHMEM_OWNER_LINUX) &&
+	    !(ops->flags & APPLE_RTKIT_SHMEM_OWNER_RTKIT))
+		return ERR_PTR(-EINVAL);
+
+	rtk = devm_kzalloc(dev, sizeof(*rtk), GFP_KERNEL);
+	if (!rtk)
+		return ERR_PTR(-ENOMEM);
+
+	rtk->dev = dev;
+	rtk->state = APPLE_RTKIT_STATE_INIT;
+	rtk->cookie = cookie;
+	rtk->ops = ops;
+	rtk->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(rtk->regs))
+		return rtk->regs;
+
+	INIT_KFIFO(rtk->msg_fifo);
+	init_waitqueue_head(&rtk->wq);
+	init_completion(&rtk->boot_completion);
+	// TODO: add a way to stop this thread
+	kthread_run(apple_rtkit_worker, rtk, "%s-rtkit-worker", dev_name(dev));
+
+	rtk->mbox_cl.dev = dev;
+	rtk->mbox_cl.tx_block = true;
+	rtk->mbox_cl.knows_txdone = false;
+	rtk->mbox_cl.rx_callback = &apple_rtkit_rx_callback;
+
+	if (mbox_name)
+		rtk->mbox_chan = mbox_request_channel_byname(&rtk->mbox_cl, mbox_name);
+	else
+		rtk->mbox_chan = mbox_request_channel(&rtk->mbox_cl, mbox_idx);
+
+	if (IS_ERR(rtk->mbox_chan))
+		return (struct apple_rtkit *)rtk->mbox_chan;
+
+
+	return rtk;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_init);
+
+int apple_rtkit_boot(struct apple_rtkit *rtk)
+{
+	int ret;
+	u32 cpu_ctrl;
+
+	if (rtk->state != APPLE_RTKIT_STATE_INIT)
+		return 0;
+	rtk->state = APPLE_RTKIT_STATE_BOOTING;
+
+	cpu_ctrl = readl_relaxed(rtk->regs + APPLE_RTKIT_CPU_CONTROL);
+	if (cpu_ctrl & APPLE_RTKIT_CPU_CONTROL_RUN) {
+		rtk_dbg("sending wakeup message\n");
+		ret = apple_rtkit_send_message(rtk, APPLE_RTKIT_EP_MGMT,
+					       APPLE_RTKIT_MGMT_WAKEUP);
+	} else {
+		rtk_dbg("starting CPU\n");
+		cpu_ctrl |= APPLE_RTKIT_CPU_CONTROL_RUN;
+		writel_relaxed(cpu_ctrl, rtk->regs + APPLE_RTKIT_CPU_CONTROL);
+		ret = 0;
+	}
+
+	if (ret)
+		apple_rtkit_boot_abort(rtk, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_boot);
+
+int apple_rtkit_boot_wait(struct apple_rtkit *rtk, unsigned long timeout)
+{
+	int ret;
+	long t;
+
+	switch (rtk->state)
+	{
+	case APPLE_RTKIT_STATE_BOOTING:
+	case APPLE_RTKIT_STATE_INIT:
+		break;
+	case APPLE_RTKIT_STATE_RUNNING:
+		return 0;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	ret = apple_rtkit_boot(rtk);
+	if (ret)
+		return ret;
+
+	rtk_dbg("waiting for boot\n");
+
+
+	t = wait_for_completion_interruptible_timeout(&rtk->boot_completion, timeout);
+	if (t == -ERESTARTSYS)
+		return t;
+	else if (t == 0)
+		return -ETIME;
+
+	if (rtk->state == APPLE_RTKIT_STATE_RUNNING)
+		return 0;
+	return rtk->boot_result;
+}
+EXPORT_SYMBOL_GPL(apple_rtkit_boot_wait);
diff --git a/include/linux/apple-rtkit.h b/include/linux/apple-rtkit.h
new file mode 100644
index 000000000000..1b51bdb9fdf5
--- /dev/null
+++ b/include/linux/apple-rtkit.h
@@ -0,0 +1,152 @@
+#ifndef _LINUX_APPLE_RTKIT_H_
+#define _LINUX_APPLE_RTKIT_H_
+
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/mailbox_client.h>
+
+/*
+ * APPLE_RTKIT_SHMEM_OWNER_LINUX - shared memory buffers are allocated and
+ *                                 managed by Linux. ops->shmem_alloc and
+ *                                 ops->shmem_free can be used to override
+ *                                 dma_alloc/free_coherent.
+ * APPLE_RTKIT_SHMEM_OWNER_RTKIT - shared memory buffers are allocated and
+ *                                 managed by RTKit. ops->shmem_map and
+ *                                 ops->shmem_unmap must be defined.
+ * APPLE_RTKIT_RECV_ATOMIC       - ops->recv_message will be called from
+ *                                 atomic / interrupt context.
+ */
+#define APPLE_RTKIT_SHMEM_OWNER_LINUX BIT(0)
+#define APPLE_RTKIT_SHMEM_OWNER_RTKIT BIT(1)
+#define APPLE_RTKIT_RECV_ATOMIC BIT(2)
+
+/*
+ * Struct to represent implementation-specific RTKit operations.
+ *
+ * @flags:        Combination of flags defined above. Exactly one of
+ *                APPLE_RTKIT_SHMEM_OWNER_RTKIT or APPLE_RTKIT_SHMEM_OWNER_LINUX
+ *                must be set.
+ * @recv_message: Function called when a message from RTKit is recevied
+ *                on a non-system endpoint. Called from a worker thread unless
+ *                APPLE_RTKIT_RECV_ATOMIC is set.
+ * @shmem_map:    Used with APPLE_RTKIT_SHMEM_OWNER_RTKIT to map an
+ *                addressed returned by the co-processor into the kernel.
+ * @shmem_unmap:  Used with APPLE_RTKIT_SHMEM_OWNER_RTKIT to unmap a previous
+ *                mapping created with shmem_map again.
+ * @shmem_alloc:  Used with APPLE_RTKIT_SHMEM_OWNER_LINUX to allocate a shared
+ *                memory buffer for the co-processor. If not specified
+ *                dma_alloc_coherent is used.
+ * @shmem_free:   Used with APPLE_RTKIT_SHMEM_OWNER_LINUX to free a shared
+ *                memory buffer previously allocated with shmem_alloc. If not
+ *                specified dma_free_coherent is used.
+ */
+struct apple_rtkit_ops {
+	unsigned int flags;
+	void (*recv_message)(void *cookie, u8 endpoint, u64 message);
+	void __iomem *(*shmem_map)(void *cookie, dma_addr_t addr, size_t len);
+	void (*shmem_unmap)(void *cookie, void __iomem *ptr, dma_addr_t addr,
+			    size_t len);
+	void *(*shmem_alloc)(void *cookie, size_t size, dma_addr_t *dma_handle,
+			     gfp_t flag);
+	void (*shmem_free)(void *cookie, size_t size, void *cpu_addr,
+			   dma_addr_t *dma_handle);
+};
+
+struct apple_rtkit;
+
+#if CONFIG_APPLE_RTKIT
+
+/*
+ * Initializes the internal state required to handle RTKit. This
+ * should usually be called within _probe.
+ *
+ * @dev: Pointer to the device node this coprocessor is assocated with
+ * @cookie: opaque cookie passed to all functions defined in rtkit_ops
+ * @resource: resource containing the CPU_CONTROL register
+ * @mbox_name: mailbox name used to communicate with the co-processor
+ * @mbox_idx: mailbox index to be used if mbox_name is NULL
+ * @ops: pointer to rtkit_ops to be used for this co-processor
+ */
+struct apple_rtkit *apple_rtkit_init(struct device *dev, void *cookie,
+				     struct resource *res,
+				     const char *mbox_name,
+				     int mbox_idx,
+				     const struct apple_rtkit_ops *ops);
+
+void apple_rtkit_free(struct apple_rtkit *rtk);
+
+/*
+ * Turns on the co-processor and initialize the RTKit system endpoints.
+ * Has to be called before any messages can be sent or recevied and will return
+ * immediately. apple_rtkit_boot can be used afterwards to wait for the boot
+ * process to complete.
+ */
+int apple_rtkit_boot(struct apple_rtkit *rtk);
+
+/*
+ * Same as rtkit_boot but waits until the processor has booted successfully.
+ * Can be called after apple_rtkit_boot to wait for the boot process to finish.
+ */
+int apple_rtkit_boot_wait(struct apple_rtkit *rtk, unsigned long timeout);
+
+/*
+ * Puts the co-processor into hibernation mode.
+ * The processor loses almost all state and cannot be used anymore after this
+ * call. All shared memory buffers will be freed.
+ */
+int apple_rtkit_hibernate(struct apple_rtkit *rtk);
+
+/*
+ * Starts an endpoint. Must be called after boot but before any messages can be
+ * sent or received from that endpoint.
+ */
+int apple_rtkit_start_ep(struct apple_rtkit *rtk, u8 endpoint);
+
+/*
+ * Send a message to the given endpoint.
+ */
+int apple_rtkit_send_message(struct apple_rtkit *rtk, u8 ep, u64 message);
+
+#else
+
+static inline struct apple_rtkit *
+apple_rtkit_init(struct device *dev, void *cookie, struct resource *res,
+		 const char *mbox_name, const struct apple_rtkit_ops *ops)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void apple_rtkit_free(struct apple_rtkit *rtk)
+{
+}
+
+static inline int apple_rtkit_boot(struct apple_rtkit *rtk)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_boot_wait(struct apple_rtkit *rtk)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_hibernate(struct apple_rtkit *rtk)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_start_ep(struct apple_rtkit *rtk, u8 endpoint)
+{
+	return -ENODEV;
+}
+
+static inline int apple_rtkit_send_message(struct apple_rtkit *rtk, u8 ep,
+					   u64 message)
+{
+	return -ENODEV;
+}
+
+#endif
+
+#endif
-- 
2.34.0


From 045fc0f1437328d32ef94138868a85f3e8275aea Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Tue, 24 Aug 2021 15:05:58 +0200
Subject: [PATCH 18/83] dt-bindings: soc: apple: Add Apple SART bindings

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 .../bindings/soc/apple/apple,sart.yaml        | 43 +++++++++++++++++++
 1 file changed, 43 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/soc/apple/apple,sart.yaml

diff --git a/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
new file mode 100644
index 000000000000..5114c2bd415f
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
@@ -0,0 +1,43 @@
+# SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/soc/apple/apple,sart.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Apple SART DMA address filter
+
+maintainers:
+  - Sven Peter <sven@svenpeter.dev>
+
+description:
+  Apple SART is a simple address filter for some DMA transactions.
+  Regions of physical memory must be added to the SART's allow
+  list before before any DMA can target these. Unlike a proper
+  IOMMU no remapping can be done and special support in the
+  consumer driver is required since not all DMA transactions of
+  a single device are subject to SART filtering.
+
+properties:
+  compatible:
+    const: apple,t8103-sart
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    description:
+      Reference to the clock gate phandle(s) if required before accessing
+      the MMIO region of this SART.
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+        sart@7bc50000 {
+                compatible = "apple,t8103-sart";
+                reg = <0x2 0x7bc50000 0x0 0x10000>;
+        };
-- 
2.34.0


From a581046740017e2083ab1d38c06e99e2a0b9963e Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Tue, 24 Aug 2021 09:56:22 +0200
Subject: [PATCH 19/83] soc: apple: sart: Add SART driver

The NVMe co-processor on the Apple M1 uses a DMA address filter called
SART for some DMA transactions. This adds a simple driver used to
configure the memory regions from which DMA transactions are allowed.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/soc/apple/Kconfig      |  11 ++
 drivers/soc/apple/Makefile     |   1 +
 drivers/soc/apple/apple-sart.c | 272 +++++++++++++++++++++++++++++++++
 include/linux/apple-sart.h     |  51 +++++++
 4 files changed, 335 insertions(+)
 create mode 100644 drivers/soc/apple/apple-sart.c
 create mode 100644 include/linux/apple-sart.h

diff --git a/drivers/soc/apple/Kconfig b/drivers/soc/apple/Kconfig
index 778745219d9f..89bec8919eca 100644
--- a/drivers/soc/apple/Kconfig
+++ b/drivers/soc/apple/Kconfig
@@ -13,5 +13,16 @@ config APPLE_RTKIT
 
 	  Say 'y' here if you have an Apple SoC.
 
+
+config APPLE_SART
+	bool "Apple SART DMA address filter"
+	depends on ARCH_APPLE || COMPILE_TEST
+	default ARCH_APPLE
+	help
+	  Apple SART is a simple DMA address filter used on Apple SoCs such
+	  as the M1. It is usually required for the NVMe coprocessor.
+
+	  Say 'y' here if you have an Apple SoC.
+
 endmenu
 endif
diff --git a/drivers/soc/apple/Makefile b/drivers/soc/apple/Makefile
index be42b7f7519d..68d562898f32 100644
--- a/drivers/soc/apple/Makefile
+++ b/drivers/soc/apple/Makefile
@@ -1,3 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0+
 
 obj-$(CONFIG_APPLE_RTKIT) += apple-rtkit.o
+obj-$(CONFIG_APPLE_SART) += apple-sart.o
diff --git a/drivers/soc/apple/apple-sart.c b/drivers/soc/apple/apple-sart.c
new file mode 100644
index 000000000000..d28ef1e9d4f4
--- /dev/null
+++ b/drivers/soc/apple/apple-sart.c
@@ -0,0 +1,272 @@
+// SPDX-License-Identifier: GPL-2.0-only OR MIT
+/*
+ * Apple SART device driver
+ * Copyright (C) 2021 The Asahi Linux Contributors
+ *
+ * Apple SART is a simple address filter for some DMA transactions.
+ * Regions of physical memory must be added to the SART's allow
+ * list before before any DMA can target these. Unlike a proper
+ * IOMMU no remapping can be done and special support in the
+ * consumer driver is required since not all DMA transactions of
+ * a single device are subject to SART filtering.
+ */
+
+#include <linux/apple-sart.h>
+#include <linux/atomic.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+
+#define APPLE_SART_CONFIG(idx) (0x00 + 4 * (idx))
+#define APPLE_SART_CONFIG_FLAGS GENMASK(31, 24)
+#define APPLE_SART_CONFIG_SIZE GENMASK(23, 0)
+#define APPLE_SART_CONFIG_SIZE_SHIFT 12
+
+#define APPLE_SART_CONFIG_FLAGS_ALLOW 0xff
+
+#define APPLE_SART_PADDR(idx) (0x40 + 4 * (idx))
+#define APPLE_SART_PADDR_SHIFT 12
+
+#define APPLE_SART_MAX_ENTRIES 16
+
+/*
+ * Private structure attached to the SART device struct as drvdata.
+ *
+ * @dev: device pointer
+ * @regs: Mapped SART MMIO region
+ * @clks: List of clock gates for this SART
+ * @num_clks: Number of clock gates for this SART
+ * @protected_entries: Bitmask of entries configured by the bootloader which
+ * 		       must not be changed by this driver.
+ * @used_entries: Bitmask of entries currently in use.
+ */
+struct apple_sart {
+	struct device *dev;
+	void __iomem *regs;
+
+	struct clk_bulk_data *clks;
+	int num_clks;
+
+	unsigned long protected_entries;
+	unsigned long used_entries;
+};
+
+static int apple_sart_probe(struct platform_device *pdev)
+{
+	int i, ret;
+	struct apple_sart *sart;
+	struct device *dev = &pdev->dev;
+
+	sart = devm_kzalloc(dev, sizeof(*sart), GFP_KERNEL);
+	if (!sart)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, sart);
+
+	sart->dev = dev;
+
+	sart->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(sart->regs))
+		return PTR_ERR(sart->regs);
+
+	ret = devm_clk_bulk_get_all(dev, &sart->clks);
+	if (ret < 0)
+		return ret;
+	sart->num_clks = ret;
+
+	ret = clk_bulk_prepare_enable(sart->num_clks, sart->clks);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
+		u32 cfg = readl_relaxed(sart->regs + APPLE_SART_CONFIG(i));
+		u8 flags = FIELD_GET(APPLE_SART_CONFIG_FLAGS, cfg);
+		size_t size = FIELD_GET(APPLE_SART_CONFIG_SIZE, cfg)
+			      << APPLE_SART_CONFIG_SIZE_SHIFT;
+		phys_addr_t paddr =
+			readl_relaxed(sart->regs + APPLE_SART_PADDR(i));
+		paddr <<= APPLE_SART_PADDR_SHIFT;
+
+		if (!flags)
+			continue;
+
+		dev_dbg(sart->dev,
+			"SART bootloader entry: index %02d; flags: 0x%02x; paddr: 0x%llx; size: 0x%zx\n",
+			i, flags, paddr, size);
+		set_bit(i, &sart->protected_entries);
+	}
+
+	return 0;
+}
+
+/*
+ * Get a reference to the SART attached to dev.
+ *
+ * Looks for the phandle reference in apple,sart and returns a pointer
+ * to the corresponding apple_sart struct to be used with
+ * apple_sart_add_allowed_region and apple_sart_remove_allowed_region.
+ */
+struct apple_sart *apple_sart_get(struct device *dev)
+{
+	struct device_node *sart_node;
+	struct platform_device *sart_pdev;
+
+	sart_node = of_parse_phandle(dev->of_node, "apple,sart", 0);
+	if (!sart_node)
+		return ERR_PTR(ENODEV);
+
+	sart_pdev = of_find_device_by_node(sart_node);
+	of_node_put(sart_node);
+
+	if (!sart_pdev)
+		return ERR_PTR(ENODEV);
+
+	device_link_add(dev, &sart_pdev->dev,
+			DL_FLAG_PM_RUNTIME | DL_FLAG_AUTOREMOVE_SUPPLIER);
+
+	return dev_get_drvdata(&sart_pdev->dev);
+}
+EXPORT_SYMBOL(apple_sart_get);
+
+/*
+ * Adds the region [paddr, paddr+size] to the DMA allow list.
+ *
+ * @sart: SART reference
+ * @paddr: Start address of the region to be used for DMA
+ * @size: Size of the region to be used for DMA.
+ */
+int apple_sart_add_allowed_region(struct apple_sart *sart, phys_addr_t paddr,
+				  size_t size)
+{
+	int i;
+
+	if (size & ((1 << APPLE_SART_CONFIG_SIZE_SHIFT) - 1))
+		return -EINVAL;
+	if (paddr & ((1 << APPLE_SART_PADDR_SHIFT) - 1))
+		return -EINVAL;
+
+	dev_dbg(sart->dev,
+		"will add [paddr: 0x%llx, size: 0x%zx] to allowed regions\n",
+		paddr, size);
+
+	size >>= APPLE_SART_CONFIG_SIZE_SHIFT;
+	paddr >>= APPLE_SART_PADDR_SHIFT;
+
+	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
+		u32 config;
+
+		if (test_bit(i, &sart->protected_entries))
+			continue;
+		if (test_and_set_bit(i, &sart->used_entries))
+			continue;
+
+		config = FIELD_PREP(APPLE_SART_CONFIG_FLAGS,
+				    APPLE_SART_CONFIG_FLAGS_ALLOW);
+		config |= FIELD_PREP(APPLE_SART_CONFIG_SIZE, size);
+
+		writel_relaxed(paddr, sart->regs + APPLE_SART_PADDR(i));
+		writel_relaxed(config, sart->regs + APPLE_SART_CONFIG(i));
+
+		dev_dbg(sart->dev, "wrote [0x%llx, 0x%x] to %02d\n", paddr,
+			config, i);
+		return 0;
+	}
+
+	dev_warn(sart->dev,
+		 "no free entries left to add [paddr: 0x%llx, size: 0x%zx]\n",
+		 paddr, size);
+
+	return -EBUSY;
+}
+EXPORT_SYMBOL(apple_sart_add_allowed_region);
+
+/*
+ * Removes the region [paddr, paddr+size] from the DMA allow list.
+ *
+ * Note that exact same paddr and size used for apple_sart_add_allowed_region
+ * have to be passed.
+ *
+ * @sart: SART reference
+ * @paddr: Start address of the region no longer used for DMA
+ * @size: Size of the region no longer used for DMA.
+ */
+int apple_sart_remove_allowed_region(struct apple_sart *sart, phys_addr_t paddr,
+				     size_t size)
+{
+	int i;
+
+	if (size & ((1 << APPLE_SART_CONFIG_SIZE_SHIFT) - 1))
+		return -EINVAL;
+	if (paddr & ((1 << APPLE_SART_PADDR_SHIFT) - 1))
+		return -EINVAL;
+
+	dev_dbg(sart->dev,
+		"will remove [paddr: 0x%llx, size: 0x%zx] from allowed regions\n",
+		paddr, size);
+
+	size >>= APPLE_SART_CONFIG_SIZE_SHIFT;
+	paddr >>= APPLE_SART_PADDR_SHIFT;
+
+	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
+		u32 config;
+
+		if (test_bit(i, &sart->protected_entries))
+			continue;
+		if (!test_bit(i, &sart->used_entries))
+			continue;
+
+		config = readl_relaxed(sart->regs + APPLE_SART_PADDR(i));
+		if (FIELD_GET(APPLE_SART_CONFIG_SIZE, config) != size)
+			continue;
+		if (readl_relaxed(sart->regs + APPLE_SART_PADDR(i)) != paddr)
+			continue;
+
+		writel_relaxed(0, sart->regs + APPLE_SART_CONFIG(i));
+		writel_relaxed(0, sart->regs + APPLE_SART_PADDR(i));
+		clear_bit(i, &sart->used_entries);
+		dev_dbg(sart->dev, "cleared entry %02d\n", i);
+		return 0;
+	}
+
+	dev_warn(sart->dev, "entry [paddr: 0x%llx, size: 0x%zx] not found\n",
+		 paddr, size);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(apple_sart_remove_allowed_region);
+
+static void apple_sart_shutdown(struct platform_device *pdev)
+{
+	struct apple_sart *sart = dev_get_drvdata(&pdev->dev);
+	int i;
+
+	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
+		if (test_bit(i, &sart->protected_entries))
+			continue;
+		writel_relaxed(0, sart->regs + APPLE_SART_CONFIG(i));
+		writel_relaxed(0, sart->regs + APPLE_SART_PADDR(i));
+	}
+}
+
+static const struct of_device_id apple_sart_of_match[] = {
+	{ .compatible = "apple,t8103-sart", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, apple_sart_of_match);
+
+static struct platform_driver apple_sart_driver = {
+	.driver = {
+		.name = "apple-sart",
+		.of_match_table = apple_sart_of_match,
+	},
+	.probe = apple_sart_probe,
+	.shutdown = apple_sart_shutdown,
+};
+module_platform_driver(apple_sart_driver);
+
+MODULE_LICENSE("Dual MIT/GPL");
+MODULE_AUTHOR("Sven Peter <sven@svenpeter.dev>");
+MODULE_DESCRIPTION("Apple SART driver");
diff --git a/include/linux/apple-sart.h b/include/linux/apple-sart.h
new file mode 100644
index 000000000000..905460bee4d2
--- /dev/null
+++ b/include/linux/apple-sart.h
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: GPL-2.0-only OR MIT
+/*
+ * Apple SART device driver
+ * Copyright (C) 2021 The Asahi Linux Contributors
+ *
+ * Apple SART is a simple address filter for DMA transactions.
+ * Regions of physical memory must be added to the SART's allow
+ * list before before any DMA can target these. Unlike a proper
+ * IOMMU no remapping can be done.
+ */
+
+#ifndef _LINUX_APPLE_SART_H_
+#define _LINUX_APPLE_SART_H_
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/types.h>
+
+struct apple_sart;
+
+#ifdef CONFIG_APPLE_SART
+
+struct apple_sart *apple_sart_get(struct device *dev);
+int apple_sart_add_allowed_region(struct apple_sart *sart, phys_addr_t paddr,
+				  size_t size);
+int apple_sart_remove_allowed_region(struct apple_sart *sart, phys_addr_t paddr,
+				     size_t size);
+
+#else
+
+static inline struct apple_sart *apple_sart_get(struct device *dev)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline int apple_sart_add_allowed_region(struct apple_sart *sart,
+						phys_addr_t paddr, size_t size)
+{
+	return -ENODEV;
+}
+
+static inline int apple_sart_remove_allowed_region(struct apple_sart *sart,
+						   phys_addr_t paddr,
+						   size_t size)
+{
+	return -ENODEV;
+}
+
+#endif
+
+#endif
-- 
2.34.0


From 9deec0dc4a598afad8c0cd8631cc88204c9906e1 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Thu, 19 Aug 2021 17:38:32 +0200
Subject: [PATCH 20/83] nvme: add NVME_QUIRK_NO_SCAN_NS_LIST

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 drivers/nvme/host/core.c | 2 ++
 drivers/nvme/host/nvme.h | 7 +++++++
 2 files changed, 9 insertions(+)

diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 4b5de8f5435a..3d95d863c2b5 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -4027,6 +4027,8 @@ static int nvme_scan_ns_list(struct nvme_ctrl *ctrl)
 	u32 prev = 0;
 	int ret = 0, i;
 
+	if (ctrl->quirks & NVME_QUIRK_NO_SCAN_NS_LIST)
+		return -EOPNOTSUPP;
 	if (nvme_ctrl_limited_cns(ctrl))
 		return -EOPNOTSUPP;
 
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index b334af8aa264..c9268742902b 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -144,6 +144,13 @@ enum nvme_quirks {
 	 * encoding the generation sequence number.
 	 */
 	NVME_QUIRK_SKIP_CID_GEN			= (1 << 17),
+
+	/*
+	 * The controller does not properly handle SCAN NS LIST
+	 * commands.
+	 */
+	NVME_QUIRK_NO_SCAN_NS_LIST		= (1 << 18),
+
 };
 
 /*
-- 
2.34.0


From 9908b49dee9c8e4a27a56c26acddbd8454b4fe1d Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Thu, 19 Aug 2021 17:38:34 +0200
Subject: [PATCH 21/83] WIP: nvme: Add Apple ANS2 NVMe host driver

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 arch/arm64/boot/dts/apple/t8103.dtsi |   27 +
 drivers/nvme/host/Kconfig            |   16 +
 drivers/nvme/host/Makefile           |    1 +
 drivers/nvme/host/apple-ans.c        | 1864 ++++++++++++++++++++++++++
 4 files changed, 1908 insertions(+)
 create mode 100644 drivers/nvme/host/apple-ans.c

diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index fc8b2bb06ffe..ea1b90fbf31a 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -338,5 +338,32 @@ port02: pci@2,0 {
 						<0 0 0 4 &port02 0 0 0 3>;
 			};
 		};
+		ans: mbox@277408000 {
+			compatible = "apple,t8103-asc-mailbox";
+			reg = <0x2 0x77408000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 583 IRQ_TYPE_LEVEL_HIGH>,
+				<AIC_IRQ 584 IRQ_TYPE_LEVEL_HIGH>,
+				<AIC_IRQ 585 IRQ_TYPE_LEVEL_HIGH>,
+				<AIC_IRQ 586 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "send-empty", "send-not-empty",
+				"recv-empty", "recv-not-empty";
+			#mbox-cells = <0>;
+		};
+
+		sart: sart@27bc50000 {
+			compatible = "apple,t8103-sart";
+			reg = <0x2 0x7bc50000 0x0 0x10000>;
+		};
+
+		ans2: nvme@27bcc0000 {
+			compatible = "apple,t8103-ans-nvme";
+			reg = <0x2 0x7bcc0000 0x0 0x40000>, <0x2 0x77400000 0x0 0x4000>;
+			reg-names = "nvme", "coproc";
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 590 IRQ_TYPE_LEVEL_HIGH>;
+			mboxes = <&ans>;
+			apple,sart = <&sart>;
+		 };
 	};
 };
diff --git a/drivers/nvme/host/Kconfig b/drivers/nvme/host/Kconfig
index dc0450ca23a3..948b2239f27e 100644
--- a/drivers/nvme/host/Kconfig
+++ b/drivers/nvme/host/Kconfig
@@ -15,6 +15,22 @@ config BLK_DEV_NVME
 	  To compile this driver as a module, choose M here: the
 	  module will be called nvme.
 
+config BLK_DEV_NVME_APPLE
+	tristate "Apple ANS2 NVM Express block device"
+	depends on (ARCH_APPLE && BLOCK) && !COMPILE_TEST
+	select NVME_CORE
+	select APPLE_RTKIT
+	select APPLE_SART
+        default ARCH_APPLE
+	help
+	  The NVM Express driver is for drives found in Apple SoCs such
+	  as the M1. These SoCs require to establish communication with a
+	  co-processor called ANS before a NVM Express MMIO interface is
+	  exposed.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called nvme.
+
 config NVME_MULTIPATH
 	bool "NVMe multipath support"
 	depends on NVME_CORE
diff --git a/drivers/nvme/host/Makefile b/drivers/nvme/host/Makefile
index dfaacd472e5d..e79ca8ca0b15 100644
--- a/drivers/nvme/host/Makefile
+++ b/drivers/nvme/host/Makefile
@@ -4,6 +4,7 @@ ccflags-y				+= -I$(src)
 
 obj-$(CONFIG_NVME_CORE)			+= nvme-core.o
 obj-$(CONFIG_BLK_DEV_NVME)		+= nvme.o
+obj-$(CONFIG_BLK_DEV_NVME_APPLE)	+= apple-ans.o
 obj-$(CONFIG_NVME_FABRICS)		+= nvme-fabrics.o
 obj-$(CONFIG_NVME_RDMA)			+= nvme-rdma.o
 obj-$(CONFIG_NVME_FC)			+= nvme-fc.o
diff --git a/drivers/nvme/host/apple-ans.c b/drivers/nvme/host/apple-ans.c
new file mode 100644
index 000000000000..f74dd8bb198c
--- /dev/null
+++ b/drivers/nvme/host/apple-ans.c
@@ -0,0 +1,1864 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Apple ANS NVM Express device driver
+ * Copyright (C) 2021 The Asahi Linux Contributors
+ *
+ * This file is essentially a simplified version of the
+ * NVM Express device driver (pci.c) with much less features
+ * (hmb, shadow doorbell, poll queues etc.) but as a platform
+ * device with Apple-specific quirks.
+ *
+ * The NVM Express device driver (pci.c) is
+ * Copyright (c) 2011-2014, Intel Corporation
+ */
+
+#include <linux/apple-rtkit.h>
+#include <linux/apple-sart.h>
+#include <linux/async.h>
+#include <linux/blkdev.h>
+#include <linux/blk-mq.h>
+#include <linux/blk-integrity.h>
+#include <linux/dmapool.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/once.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
+#include <linux/iopoll.h>
+
+#include "trace.h"
+#include "nvme.h"
+
+#define SQ_SIZE(q)	((q)->q_depth << (q)->sqes)
+#define CQ_SIZE(q)	((q)->q_depth * sizeof(struct nvme_completion))
+
+/*
+ * These can be higher, but we need to ensure that any command doesn't
+ * require an sg allocation that needs more than a page of data.
+ */
+#define NVME_MAX_KB_SZ	4096
+#define NVME_MAX_SEGS	127
+
+#define APPLE_ANS_BOOT_TIMEOUT msecs_to_jiffies(1000)
+
+/* Apple ANS2 registers */
+#define APPLE_ANS2_QUEUE_DEPTH 64
+#define APPLE_ANS2_MAX_PEND_CMDS 64
+#define APPLE_NVMMU_NUM_TCBS 64
+
+#define APPLE_ANS2_LINEAR_ASQ_DB 0x2490c
+#define APPLE_ANS2_LINEAR_IOSQ_DB 0x24910
+
+#define APPLE_NVMMU_NUM 0x28100
+#define APPLE_NVMMU_BASE_ASQ 0x28108
+#define APPLE_NVMMU_BASE_IOSQ 0x28110
+#define APPLE_NVMMU_TCB_INVAL 0x28118
+#define APPLE_NVMMU_TCB_STAT 0x28120
+#define APPLE_NVMMU_TCB_SIZE                                                   \
+	(sizeof(struct apple_nvmmu_tcb) * APPLE_NVMMU_NUM_TCBS)
+
+#define APPLE_ANS2_MAX_PEND_CMDS_CTRL 0x1210
+
+#define APPLE_ANS2_BOOT_STATUS 0x1300
+#define APPLE_ANS2_BOOT_STATUS_OK 0xde71ce55
+
+#define APPLE_ANS2_UNKNOWN_CTRL 0x24008
+#define APPLE_ANS2_PRP_NULL_CHECK BIT(11)
+
+#define APPLE_ANS2_LINEAR_SQ_CTRL 0x24908
+#define APPLE_ANS2_LINEAR_SQ_EN BIT(0)
+
+#define APPLE_ANS2_TCB_DMA_FROM_DEVICE BIT(0)
+#define APPLE_ANS2_TCB_DMA_TO_DEVICE BIT(1)
+
+struct apple_nvme_dev;
+struct apple_nvme_queue;
+
+static void apple_nvme_dev_disable(struct apple_nvme_dev *dev, bool shutdown);
+static bool __apple_nvme_disable_io_queues(struct apple_nvme_dev *dev, u8 opcode);
+
+/*
+ * Represents an NVM Express device.  Each nvme_dev is a PCI function.
+ */
+struct apple_nvme_dev {
+	struct apple_nvme_queue *adminq;
+	struct apple_nvme_queue *ioq;
+	struct blk_mq_tag_set tagset;
+	struct blk_mq_tag_set admin_tagset;
+	u32 __iomem *dbs;
+	struct device *dev;
+	struct dma_pool *prp_page_pool;
+	struct dma_pool *prp_small_pool;
+	bool adminq_online;
+	bool ioq_online;
+	u32 db_stride;
+	void __iomem *nvme_mmio;
+	int platform_irq;
+	struct work_struct remove_work;
+	struct mutex shutdown_lock;
+	struct nvme_ctrl ctrl;
+
+	mempool_t *iod_mempool;
+
+	/* Apple ANS2 support */
+	struct apple_rtkit *rtk;
+	struct apple_sart *sart;
+};
+
+static inline struct apple_nvme_dev *to_apple_nvme_dev(struct nvme_ctrl *ctrl)
+{
+	return container_of(ctrl, struct apple_nvme_dev, ctrl);
+}
+
+/*
+ * An NVM Express queue.  Each device has at least two (one for admin
+ * commands and one for I/O commands).
+ */
+struct apple_nvme_queue {
+	struct apple_nvme_dev *dev;
+	spinlock_t sq_lock;
+	void *sq_cmds;
+	struct nvme_completion *cqes;
+	dma_addr_t sq_dma_addr;
+	dma_addr_t cq_dma_addr;
+	u32 __iomem *q_db;
+	u32 q_depth;
+	u16 cq_head;
+	u8 cq_phase;
+	u8 sqes;
+	unsigned long flags;
+#define NVMEQ_ENABLED		0
+#define NVMEQ_SQ_CMB		1
+#define NVMEQ_DELETE_ERROR	2
+	struct completion delete_done;
+
+	u32 __iomem *ans2_q_db;
+	void __iomem *nvmmu_base;
+	void *ans2_tcb_ptr;
+	dma_addr_t ans2_tcb_dma_addr;
+
+	bool is_adminq;
+};
+
+/*
+ * The nvme_iod describes the data in an I/O.
+ *
+ * The sg pointer contains the list of PRP/SGL chunk allocations in addition
+ * to the actual struct scatterlist.
+ */
+struct apple_nvme_iod {
+	struct nvme_request req;
+	struct nvme_command cmd;
+	struct apple_nvme_queue *nvmeq;
+	int aborted;
+	int npages;		/* In the PRP list. 0 means small pool in use */
+	int nents;		/* Used in scatterlist */
+	dma_addr_t first_dma;
+	unsigned int dma_len;	/* length of single DMA segment mapping */
+	dma_addr_t meta_dma;
+	struct scatterlist *sg;
+};
+
+/* Apple ANS2 support */
+struct apple_nvmmu_tcb {
+	u8 opcode;
+	u8 dma_flags;
+	u8 command_id;
+	u8 _unk0;
+	u32 length;
+	u64 _unk1[2];
+	u64 prp1;
+	u64 prp2;
+	u64 _unk2[2];
+	u8 aes_iv[8];
+	u8 _aes_unk[64];
+};
+
+static void apple_nvmmu_inval(struct apple_nvme_queue *nvmeq, unsigned tag)
+{
+	struct apple_nvme_dev *dev = nvmeq->dev;
+	struct apple_nvmmu_tcb *tcb;
+
+	tcb = nvmeq->ans2_tcb_ptr + tag * sizeof(struct apple_nvmmu_tcb);
+	memset(tcb, 0, sizeof(*tcb));
+
+	writel(tag, dev->nvme_mmio + APPLE_NVMMU_TCB_INVAL);
+	if (readl(dev->nvme_mmio + APPLE_NVMMU_TCB_STAT))
+		dev_warn(dev->dev, "NVMMU TCB invalidation failed\n");
+}
+
+/*
+ * Will slightly overestimate the number of pages needed.  This is OK
+ * as it only leads to a small amount of wasted memory for the lifetime of
+ * the I/O.
+ */
+static int apple_nvme_npages_prp(void)
+{
+	unsigned nprps = DIV_ROUND_UP(NVME_MAX_KB_SZ + NVME_CTRL_PAGE_SIZE,
+				      NVME_CTRL_PAGE_SIZE);
+	return DIV_ROUND_UP(8 * nprps, PAGE_SIZE - 8);
+}
+
+static size_t apple_nvme_iod_alloc_size(void)
+{
+	size_t npages = apple_nvme_npages_prp();
+
+	return sizeof(__le64 *) * npages +
+		sizeof(struct scatterlist) * NVME_MAX_SEGS;
+}
+
+static int apple_nvme_admin_init_hctx(struct blk_mq_hw_ctx *hctx, void *data,
+				unsigned int hctx_idx)
+{
+	struct apple_nvme_dev *dev = data;
+
+	WARN_ON(hctx_idx != 0);
+	WARN_ON(dev->admin_tagset.tags[0] != hctx->tags);
+
+	hctx->driver_data = dev->adminq;
+	return 0;
+}
+
+static int apple_nvme_init_hctx(struct blk_mq_hw_ctx *hctx, void *data,
+			  unsigned int hctx_idx)
+{
+	struct apple_nvme_dev *dev = data;
+
+	WARN_ON(hctx_idx != 0);
+	WARN_ON(dev->tagset.tags[0] != hctx->tags);
+
+	hctx->driver_data = dev->ioq;
+	return 0;
+}
+
+static int apple_nvme_init_request(struct blk_mq_tag_set *set, struct request *req,
+			     unsigned int hctx_idx, unsigned int numa_node)
+{
+	struct apple_nvme_dev *dev = set->driver_data;
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	struct apple_nvme_queue *nvmeq = NULL;
+
+	if (set == &dev->tagset)
+		nvmeq = dev->ioq;
+	else if (set == &dev->admin_tagset)
+		nvmeq = dev->adminq;
+
+	BUG_ON(!nvmeq);
+	iod->nvmeq = nvmeq;
+
+	nvme_req(req)->ctrl = &dev->ctrl;
+	nvme_req(req)->cmd = &iod->cmd;
+	return 0;
+}
+
+/**
+ * apple_nvme_submit_cmd() - Copy a command into a queue and ring the doorbell
+ * @nvmeq: The queue to use
+ * @cmd: The command to send
+ */
+static void apple_nvme_submit_cmd(struct apple_nvme_queue *nvmeq, struct nvme_command *cmd)
+{
+	u32 tag = nvme_tag_from_cid(cmd->common.command_id);
+	struct apple_nvmmu_tcb *tcb;
+
+	tcb = nvmeq->ans2_tcb_ptr + tag * sizeof(struct apple_nvmmu_tcb);
+	memset(tcb, 0, sizeof(*tcb));
+
+	tcb->opcode = cmd->common.opcode;
+	tcb->prp1 = cmd->common.dptr.prp1;
+	tcb->prp2 = cmd->common.dptr.prp2;
+	tcb->length = cmd->rw.length;
+	tcb->command_id = tag;
+
+	if (nvme_is_write(cmd))
+		tcb->dma_flags = APPLE_ANS2_TCB_DMA_TO_DEVICE;
+	else
+		tcb->dma_flags = APPLE_ANS2_TCB_DMA_FROM_DEVICE;
+
+	memcpy(nvmeq->sq_cmds + (tag << nvmeq->sqes), cmd, sizeof(*cmd));
+	writel(tag, nvmeq->ans2_q_db);
+}
+
+static void **apple_nvme_iod_list(struct request *req)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	return (void **)(iod->sg + blk_rq_nr_phys_segments(req));
+}
+
+static void apple_nvme_free_prps(struct apple_nvme_dev *dev, struct request *req)
+{
+	const int last_prp = NVME_CTRL_PAGE_SIZE / sizeof(__le64) - 1;
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	dma_addr_t dma_addr = iod->first_dma;
+	int i;
+
+	for (i = 0; i < iod->npages; i++) {
+		__le64 *prp_list = apple_nvme_iod_list(req)[i];
+		dma_addr_t next_dma_addr = le64_to_cpu(prp_list[last_prp]);
+
+		dma_pool_free(dev->prp_page_pool, prp_list, dma_addr);
+		dma_addr = next_dma_addr;
+	}
+}
+
+static void apple_nvme_unmap_sg(struct apple_nvme_dev *dev, struct request *req)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+
+	dma_unmap_sg(dev->dev, iod->sg, iod->nents, rq_dma_dir(req));
+}
+
+static void apple_nvme_unmap_data(struct apple_nvme_dev *dev, struct request *req)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+
+	if (iod->dma_len) {
+		dma_unmap_page(dev->dev, iod->first_dma, iod->dma_len,
+			       rq_dma_dir(req));
+		return;
+	}
+
+	WARN_ON_ONCE(!iod->nents);
+
+	apple_nvme_unmap_sg(dev, req);
+	if (iod->npages == 0)
+		dma_pool_free(dev->prp_small_pool, apple_nvme_iod_list(req)[0],
+			      iod->first_dma);
+	else
+		apple_nvme_free_prps(dev, req);
+	mempool_free(iod->sg, dev->iod_mempool);
+}
+
+static void apple_nvme_print_sgl(struct scatterlist *sgl, int nents)
+{
+	int i;
+	struct scatterlist *sg;
+
+	for_each_sg(sgl, sg, nents, i) {
+		dma_addr_t phys = sg_phys(sg);
+		pr_warn("sg[%d] phys_addr:%pad offset:%d length:%d "
+			"dma_address:%pad dma_length:%d\n",
+			i, &phys, sg->offset, sg->length, &sg_dma_address(sg),
+			sg_dma_len(sg));
+	}
+}
+
+static blk_status_t apple_nvme_setup_prps(struct apple_nvme_dev *dev,
+		struct request *req, struct nvme_rw_command *cmnd)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	struct dma_pool *pool;
+	int length = blk_rq_payload_bytes(req);
+	struct scatterlist *sg = iod->sg;
+	int dma_len = sg_dma_len(sg);
+	u64 dma_addr = sg_dma_address(sg);
+	int offset = dma_addr & (NVME_CTRL_PAGE_SIZE - 1);
+	__le64 *prp_list;
+	void **list = apple_nvme_iod_list(req);
+	dma_addr_t prp_dma;
+	int nprps, i;
+
+	length -= (NVME_CTRL_PAGE_SIZE - offset);
+	if (length <= 0) {
+		iod->first_dma = 0;
+		goto done;
+	}
+
+	dma_len -= (NVME_CTRL_PAGE_SIZE - offset);
+	if (dma_len) {
+		dma_addr += (NVME_CTRL_PAGE_SIZE - offset);
+	} else {
+		sg = sg_next(sg);
+		dma_addr = sg_dma_address(sg);
+		dma_len = sg_dma_len(sg);
+	}
+
+	if (length <= NVME_CTRL_PAGE_SIZE) {
+		iod->first_dma = dma_addr;
+		goto done;
+	}
+
+	nprps = DIV_ROUND_UP(length, NVME_CTRL_PAGE_SIZE);
+	if (nprps <= (256 / 8)) {
+		pool = dev->prp_small_pool;
+		iod->npages = 0;
+	} else {
+		pool = dev->prp_page_pool;
+		iod->npages = 1;
+	}
+
+	prp_list = dma_pool_alloc(pool, GFP_ATOMIC, &prp_dma);
+	if (!prp_list) {
+		iod->first_dma = dma_addr;
+		iod->npages = -1;
+		return BLK_STS_RESOURCE;
+	}
+	list[0] = prp_list;
+	iod->first_dma = prp_dma;
+	i = 0;
+	for (;;) {
+		if (i == NVME_CTRL_PAGE_SIZE >> 3) {
+			__le64 *old_prp_list = prp_list;
+			prp_list = dma_pool_alloc(pool, GFP_ATOMIC, &prp_dma);
+			if (!prp_list)
+				goto free_prps;
+			list[iod->npages++] = prp_list;
+			prp_list[0] = old_prp_list[i - 1];
+			old_prp_list[i - 1] = cpu_to_le64(prp_dma);
+			i = 1;
+		}
+		prp_list[i++] = cpu_to_le64(dma_addr);
+		dma_len -= NVME_CTRL_PAGE_SIZE;
+		dma_addr += NVME_CTRL_PAGE_SIZE;
+		length -= NVME_CTRL_PAGE_SIZE;
+		if (length <= 0)
+			break;
+		if (dma_len > 0)
+			continue;
+		if (unlikely(dma_len < 0))
+			goto bad_sgl;
+		sg = sg_next(sg);
+		dma_addr = sg_dma_address(sg);
+		dma_len = sg_dma_len(sg);
+	}
+done:
+	cmnd->dptr.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
+	cmnd->dptr.prp2 = cpu_to_le64(iod->first_dma);
+	return BLK_STS_OK;
+free_prps:
+	apple_nvme_free_prps(dev, req);
+	return BLK_STS_RESOURCE;
+bad_sgl:
+	WARN(DO_ONCE(apple_nvme_print_sgl, iod->sg, iod->nents),
+			"Invalid SGL for payload:%d nents:%d\n",
+			blk_rq_payload_bytes(req), iod->nents);
+	return BLK_STS_IOERR;
+}
+
+static blk_status_t apple_nvme_setup_prp_simple(struct apple_nvme_dev *dev,
+		struct request *req, struct nvme_rw_command *cmnd,
+		struct bio_vec *bv)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	unsigned int offset = bv->bv_offset & (NVME_CTRL_PAGE_SIZE - 1);
+	unsigned int first_prp_len = NVME_CTRL_PAGE_SIZE - offset;
+
+	iod->first_dma = dma_map_bvec(dev->dev, bv, rq_dma_dir(req), 0);
+	if (dma_mapping_error(dev->dev, iod->first_dma))
+		return BLK_STS_RESOURCE;
+	iod->dma_len = bv->bv_len;
+
+	cmnd->dptr.prp1 = cpu_to_le64(iod->first_dma);
+	if (bv->bv_len > first_prp_len)
+		cmnd->dptr.prp2 = cpu_to_le64(iod->first_dma + first_prp_len);
+	return BLK_STS_OK;
+}
+
+static blk_status_t apple_nvme_map_data(struct apple_nvme_dev *dev, struct request *req,
+		struct nvme_command *cmnd)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	blk_status_t ret = BLK_STS_RESOURCE;
+	int nr_mapped;
+
+	if (blk_rq_nr_phys_segments(req) == 1) {
+		struct bio_vec bv = req_bvec(req);
+
+		if (bv.bv_offset + bv.bv_len <= NVME_CTRL_PAGE_SIZE * 2)
+			return apple_nvme_setup_prp_simple(dev, req,
+						     &cmnd->rw, &bv);
+	}
+
+	iod->dma_len = 0;
+	iod->sg = mempool_alloc(dev->iod_mempool, GFP_ATOMIC);
+	if (!iod->sg)
+		return BLK_STS_RESOURCE;
+	sg_init_table(iod->sg, blk_rq_nr_phys_segments(req));
+	iod->nents = blk_rq_map_sg(req->q, req, iod->sg);
+	if (!iod->nents)
+		goto out_free_sg;
+
+	nr_mapped = dma_map_sg_attrs(dev->dev, iod->sg, iod->nents,
+				     rq_dma_dir(req), DMA_ATTR_NO_WARN);
+	if (!nr_mapped)
+		goto out_free_sg;
+
+	ret = apple_nvme_setup_prps(dev, req, &cmnd->rw);
+	if (ret != BLK_STS_OK)
+		goto out_unmap_sg;
+	return BLK_STS_OK;
+
+out_unmap_sg:
+	apple_nvme_unmap_sg(dev, req);
+out_free_sg:
+	mempool_free(iod->sg, dev->iod_mempool);
+	return ret;
+}
+
+static blk_status_t apple_nvme_map_metadata(struct apple_nvme_dev *dev, struct request *req,
+		struct nvme_command *cmnd)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+
+	iod->meta_dma = dma_map_bvec(dev->dev, rq_integrity_vec(req),
+			rq_dma_dir(req), 0);
+	if (dma_mapping_error(dev->dev, iod->meta_dma))
+		return BLK_STS_IOERR;
+	cmnd->rw.metadata = cpu_to_le64(iod->meta_dma);
+	return BLK_STS_OK;
+}
+
+/*
+ * NOTE: ns is NULL when called on the admin queue.
+ */
+static blk_status_t apple_nvme_queue_rq(struct blk_mq_hw_ctx *hctx,
+			 const struct blk_mq_queue_data *bd)
+{
+	struct nvme_ns *ns = hctx->queue->queuedata;
+	struct apple_nvme_queue *nvmeq = hctx->driver_data;
+	struct apple_nvme_dev *dev = nvmeq->dev;
+	struct request *req = bd->rq;
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	struct nvme_command *cmnd = &iod->cmd;
+	blk_status_t ret;
+
+	iod->aborted = 0;
+	iod->npages = -1;
+	iod->nents = 0;
+
+	/*
+	 * We should not need to do this, but we're still using this to
+	 * ensure we can drain requests on a dying queue.
+	 */
+	if (unlikely(!test_bit(NVMEQ_ENABLED, &nvmeq->flags)))
+		return BLK_STS_IOERR;
+
+	if (!nvme_check_ready(&dev->ctrl, req, true))
+		return nvme_fail_nonready_command(&dev->ctrl, req);
+
+	ret = nvme_setup_cmd(ns, req);
+	if (ret)
+		return ret;
+
+	if (blk_rq_nr_phys_segments(req)) {
+		ret = apple_nvme_map_data(dev, req, cmnd);
+		if (ret)
+			goto out_free_cmd;
+	}
+
+	if (blk_integrity_rq(req)) {
+		ret = apple_nvme_map_metadata(dev, req, cmnd);
+		if (ret)
+			goto out_unmap_data;
+	}
+
+	blk_mq_start_request(req);
+	apple_nvme_submit_cmd(nvmeq, cmnd);
+	return BLK_STS_OK;
+out_unmap_data:
+	apple_nvme_unmap_data(dev, req);
+out_free_cmd:
+	nvme_cleanup_cmd(req);
+	return ret;
+}
+
+static void apple_nvme_common_complete_rq(struct request *req)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	struct apple_nvme_dev *dev = iod->nvmeq->dev;
+
+	if (blk_integrity_rq(req))
+		dma_unmap_page(dev->dev, iod->meta_dma,
+			       rq_integrity_vec(req)->bv_len, rq_data_dir(req));
+	if (blk_rq_nr_phys_segments(req))
+		apple_nvme_unmap_data(dev, req);
+	nvme_complete_rq(req);
+}
+
+/* We read the CQE phase first to check if the rest of the entry is valid */
+static inline bool apple_nvme_cqe_pending(struct apple_nvme_queue *nvmeq)
+{
+	struct nvme_completion *hcqe = &nvmeq->cqes[nvmeq->cq_head];
+
+	return (le16_to_cpu(READ_ONCE(hcqe->status)) & 1) == nvmeq->cq_phase;
+}
+
+static inline void apple_nvme_ring_cq_doorbell(struct apple_nvme_queue *nvmeq)
+{
+	writel(nvmeq->cq_head, nvmeq->q_db + nvmeq->dev->db_stride);
+}
+
+static inline struct blk_mq_tags *apple_nvme_queue_tagset(struct apple_nvme_queue *nvmeq)
+{
+	if (nvmeq->is_adminq)
+		return nvmeq->dev->admin_tagset.tags[0];
+	else
+		return nvmeq->dev->tagset.tags[0];
+}
+
+static inline int apple_nvme_queue_id(struct apple_nvme_queue *nvmeq)
+{
+	return nvmeq->is_adminq ? 0 : 1;
+}
+
+static inline void apple_nvme_handle_cqe(struct apple_nvme_queue *nvmeq, u16 idx)
+{
+	struct nvme_completion *cqe = &nvmeq->cqes[idx];
+	__u16 command_id = READ_ONCE(cqe->command_id);
+	struct request *req;
+
+	apple_nvmmu_inval(nvmeq, nvme_tag_from_cid(command_id));
+
+	/*
+	 * AEN requests are special as they don't time out and can
+	 * survive any kind of queue freeze and often don't respond to
+	 * aborts.  We don't even bother to allocate a struct request
+	 * for them but rather special case them here.
+	 */
+	if (unlikely(nvme_is_aen_req(apple_nvme_queue_id(nvmeq), command_id))) {
+		nvme_complete_async_event(&nvmeq->dev->ctrl,
+				cqe->status, &cqe->result);
+		return;
+	}
+
+	req = nvme_find_rq(apple_nvme_queue_tagset(nvmeq), command_id);
+	if (unlikely(!req)) {
+		dev_warn(nvmeq->dev->ctrl.device,
+			"invalid id %d completed on queue %d\n",
+			command_id, le16_to_cpu(cqe->sq_id));
+		return;
+	}
+
+	if (!nvme_try_complete_req(req, cqe->status, cqe->result))
+		apple_nvme_common_complete_rq(req);
+}
+
+static inline void apple_nvme_update_cq_head(struct apple_nvme_queue *nvmeq)
+{
+	u32 tmp = nvmeq->cq_head + 1;
+
+	if (tmp == nvmeq->q_depth) {
+		nvmeq->cq_head = 0;
+		nvmeq->cq_phase ^= 1;
+	} else {
+		nvmeq->cq_head = tmp;
+	}
+}
+
+static inline int nvme_process_cq(struct apple_nvme_queue *nvmeq)
+{
+	int found = 0;
+
+	while (apple_nvme_cqe_pending(nvmeq)) {
+		found++;
+		/*
+		 * load-load control dependency between phase and the rest of
+		 * the cqe requires a full read memory barrier
+		 */
+		dma_rmb();
+		apple_nvme_handle_cqe(nvmeq, nvmeq->cq_head);
+		apple_nvme_update_cq_head(nvmeq);
+	}
+
+	if (found)
+		apple_nvme_ring_cq_doorbell(nvmeq);
+	return found;
+}
+
+static irqreturn_t apple_nvme_irq(int irq, void *data)
+{
+	struct apple_nvme_dev *dev = data;
+	bool handled = false;
+
+	if (dev->adminq_online && nvme_process_cq(dev->adminq))
+		handled = true;
+	if (dev->ioq_online && nvme_process_cq(dev->ioq))
+		handled = true;
+
+	if (handled)
+		return IRQ_HANDLED;
+	return IRQ_NONE;
+}
+
+/*
+ * Poll for completions for any interrupt driven queue
+ * Can be called from any context.
+ */
+static void apple_nvme_poll_irqdisable(struct apple_nvme_queue *nvmeq)
+{
+	disable_irq(nvmeq->dev->platform_irq);
+	nvme_process_cq(nvmeq);
+	enable_irq(nvmeq->dev->platform_irq);
+}
+
+static void apple_nvme_submit_async_event(struct nvme_ctrl *ctrl)
+{
+	struct apple_nvme_dev *dev = to_apple_nvme_dev(ctrl);
+	struct nvme_command c = { };
+
+	c.common.opcode = nvme_admin_async_event;
+	c.common.command_id = NVME_AQ_BLK_MQ_DEPTH;
+	apple_nvme_submit_cmd(dev->adminq, &c);
+}
+
+static int apple_adapter_delete_queue(struct apple_nvme_dev *dev, u8 opcode)
+{
+	struct nvme_command c = { };
+
+	c.delete_queue.opcode = opcode;
+	/* we only have a single IO queue */
+	c.delete_queue.qid = cpu_to_le16(1);
+
+	return nvme_submit_sync_cmd(dev->ctrl.admin_q, &c, NULL, 0);
+}
+
+static int apple_adapter_alloc_cq(struct apple_nvme_dev *dev,
+		struct apple_nvme_queue *nvmeq)
+{
+	struct nvme_command c = { };
+	int flags = NVME_QUEUE_PHYS_CONTIG | NVME_CQ_IRQ_ENABLED;
+
+	/*
+	 * Note: we (ab)use the fact that the prp fields survive if no data
+	 * is attached to the request.
+	 */
+	c.create_cq.opcode = nvme_admin_create_cq;
+	c.create_cq.prp1 = cpu_to_le64(nvmeq->cq_dma_addr);
+	c.create_cq.cqid = cpu_to_le16(1);
+	c.create_cq.qsize = cpu_to_le16(nvmeq->q_depth - 1);
+	c.create_cq.cq_flags = cpu_to_le16(flags);
+	c.create_cq.irq_vector = cpu_to_le16(0);
+
+	return nvme_submit_sync_cmd(dev->ctrl.admin_q, &c, NULL, 0);
+}
+
+static int apple_adapter_alloc_sq(struct apple_nvme_dev *dev,
+						struct apple_nvme_queue *nvmeq)
+{
+	struct nvme_command c = { };
+	int flags = NVME_QUEUE_PHYS_CONTIG;
+
+	/*
+	 * Note: we (ab)use the fact that the prp fields survive if no data
+	 * is attached to the request.
+	 */
+	c.create_sq.opcode = nvme_admin_create_sq;
+	c.create_sq.prp1 = cpu_to_le64(nvmeq->sq_dma_addr);
+	c.create_sq.sqid = cpu_to_le16(1);
+	c.create_sq.qsize = cpu_to_le16(nvmeq->q_depth - 1);
+	c.create_sq.sq_flags = cpu_to_le16(flags);
+	c.create_sq.cqid = cpu_to_le16(1);
+
+	return nvme_submit_sync_cmd(dev->ctrl.admin_q, &c, NULL, 0);
+}
+
+static int apple_adapter_delete_cq(struct apple_nvme_dev *dev)
+{
+	return apple_adapter_delete_queue(dev, nvme_admin_delete_cq);
+}
+
+static int apple_adapter_delete_sq(struct apple_nvme_dev *dev)
+{
+	return apple_adapter_delete_queue(dev, nvme_admin_delete_sq);
+}
+
+static void apple_abort_endio(struct request *req, blk_status_t error)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	struct apple_nvme_queue *nvmeq = iod->nvmeq;
+
+	dev_warn(nvmeq->dev->ctrl.device,
+		 "Abort status: 0x%x", nvme_req(req)->status);
+	atomic_inc(&nvmeq->dev->ctrl.abort_limit);
+	blk_mq_free_request(req);
+}
+
+static bool apple_nvme_should_reset(struct apple_nvme_dev *dev, u32 csts)
+{
+	/* If there is a reset/reinit ongoing, we shouldn't reset again. */
+	switch (dev->ctrl.state) {
+	case NVME_CTRL_RESETTING:
+	case NVME_CTRL_CONNECTING:
+		return false;
+	default:
+		break;
+	}
+
+	/* We shouldn't reset unless the controller is on fatal error state
+	 */
+	if (!(csts & NVME_CSTS_CFS))
+		return false;
+
+	return true;
+}
+
+static void apple_nvme_warn_reset(struct apple_nvme_dev *dev, u32 csts)
+{
+	dev_warn(dev->ctrl.device,
+		 "controller is down; will reset: CSTS=0x%x\n", csts);
+}
+
+static enum blk_eh_timer_return apple_nvme_timeout(struct request *req, bool reserved)
+{
+	struct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);
+	struct apple_nvme_queue *nvmeq = iod->nvmeq;
+	struct apple_nvme_dev *dev = nvmeq->dev;
+	struct request *abort_req;
+	struct nvme_command cmd = { };
+	u32 csts = readl(dev->nvme_mmio + NVME_REG_CSTS);
+
+	/*
+	 * Reset immediately if the controller is failed
+	 */
+	if (apple_nvme_should_reset(dev, csts)) {
+		apple_nvme_warn_reset(dev, csts);
+		apple_nvme_dev_disable(dev, false);
+		nvme_reset_ctrl(&dev->ctrl);
+		return BLK_EH_DONE;
+	}
+
+	/*
+	 * Did we miss an interrupt?
+	 */
+	apple_nvme_poll_irqdisable(nvmeq);
+
+	if (blk_mq_request_completed(req)) {
+		dev_warn(dev->ctrl.device,
+			 "I/O %d QID %d timeout, completion polled\n",
+			 req->tag, apple_nvme_queue_id(nvmeq));
+		return BLK_EH_DONE;
+	}
+
+	/*
+	 * Shutdown immediately if controller times out while starting. The
+	 * reset work will see the pci device disabled when it gets the forced
+	 * cancellation error. All outstanding requests are completed on
+	 * shutdown, so we return BLK_EH_DONE.
+	 */
+	switch (dev->ctrl.state) {
+	case NVME_CTRL_CONNECTING:
+		nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_DELETING);
+		fallthrough;
+	case NVME_CTRL_DELETING:
+		dev_warn_ratelimited(dev->ctrl.device,
+			 "I/O %d QID %d timeout, disable controller\n",
+			 req->tag, apple_nvme_queue_id(nvmeq));
+		nvme_req(req)->flags |= NVME_REQ_CANCELLED;
+		apple_nvme_dev_disable(dev, true);
+		return BLK_EH_DONE;
+	case NVME_CTRL_RESETTING:
+		return BLK_EH_RESET_TIMER;
+	default:
+		break;
+	}
+
+	/*
+	 * Shutdown the controller immediately and schedule a reset if the
+	 * command was already aborted once before and still hasn't been
+	 * returned to the driver, or if this is the admin queue.
+	 */
+	if (nvmeq->is_adminq || iod->aborted) {
+		dev_warn(dev->ctrl.device,
+			 "I/O %d QID %d timeout, reset controller\n",
+			 req->tag, apple_nvme_queue_id(nvmeq));
+		nvme_req(req)->flags |= NVME_REQ_CANCELLED;
+		apple_nvme_dev_disable(dev, false);
+		nvme_reset_ctrl(&dev->ctrl);
+
+		return BLK_EH_DONE;
+	}
+
+	if (atomic_dec_return(&dev->ctrl.abort_limit) < 0) {
+		atomic_inc(&dev->ctrl.abort_limit);
+		return BLK_EH_RESET_TIMER;
+	}
+	iod->aborted = 1;
+
+	cmd.abort.opcode = nvme_admin_abort_cmd;
+	cmd.abort.cid = req->tag;
+	cmd.abort.sqid = cpu_to_le16(1);
+
+	dev_warn(nvmeq->dev->ctrl.device,
+		"I/O %d timeout, aborting\n",
+		 req->tag);
+
+	abort_req = nvme_alloc_request(dev->ctrl.admin_q, &cmd,
+			BLK_MQ_REQ_NOWAIT);
+	if (IS_ERR(abort_req)) {
+		atomic_inc(&dev->ctrl.abort_limit);
+		return BLK_EH_RESET_TIMER;
+	}
+
+	abort_req->end_io_data = NULL;
+	blk_execute_rq_nowait(NULL, abort_req, 0, apple_abort_endio);
+
+	/*
+	 * The aborted req will be completed on receiving the abort req.
+	 * We enable the timer again. If hit twice, it'll cause a device reset,
+	 * as the device then is in a faulty state.
+	 */
+	return BLK_EH_RESET_TIMER;
+}
+
+static void apple_nvme_free_queue(struct apple_nvme_queue *nvmeq)
+{
+	dma_free_coherent(nvmeq->dev->dev, CQ_SIZE(nvmeq), (void *)nvmeq->cqes,
+			  nvmeq->cq_dma_addr);
+	if (!nvmeq->sq_cmds)
+		return;
+
+	dma_free_coherent(nvmeq->dev->dev, APPLE_NVMMU_TCB_SIZE,
+			  nvmeq->ans2_tcb_ptr, nvmeq->ans2_tcb_dma_addr);
+	dma_free_coherent(nvmeq->dev->dev, SQ_SIZE(nvmeq), nvmeq->sq_cmds,
+			  nvmeq->sq_dma_addr);
+}
+
+/**
+ * apple_nvme_suspend_queue - put queue into suspended state
+ * @nvmeq: queue to suspend
+ */
+static int apple_nvme_suspend_queue(struct apple_nvme_queue *nvmeq)
+{
+	if (!test_and_clear_bit(NVMEQ_ENABLED, &nvmeq->flags))
+		return 1;
+
+	/* ensure that apple_nvme_queue_rq() sees NVMEQ_ENABLED cleared */
+	mb();
+
+	if (nvmeq->is_adminq && nvmeq->dev->ctrl.admin_q)
+		blk_mq_quiesce_queue(nvmeq->dev->ctrl.admin_q);
+	if (nvmeq->is_adminq)
+		nvmeq->dev->adminq_online = false;
+	else
+		nvmeq->dev->ioq_online = false;
+	return 0;
+}
+
+static void apple_nvme_disable_admin_queue(struct apple_nvme_dev *dev, bool shutdown)
+{
+	if (shutdown)
+		nvme_shutdown_ctrl(&dev->ctrl);
+	else
+		nvme_disable_ctrl(&dev->ctrl);
+
+	apple_nvme_poll_irqdisable(dev->adminq);
+}
+
+static int apple_nvme_alloc_queue(struct apple_nvme_dev *dev, bool is_adminq)
+{
+	struct apple_nvme_queue *nvmeq;
+
+	if (is_adminq) {
+		nvmeq = dev->adminq;
+		nvmeq->sqes = NVME_ADM_SQES;
+		nvmeq->q_depth = NVME_AQ_DEPTH;
+	} else {
+		nvmeq = dev->ioq;
+		nvmeq->sqes = NVME_NVM_IOSQES;
+		nvmeq->q_depth = APPLE_ANS2_QUEUE_DEPTH;
+	}
+
+	nvmeq->cqes = dma_alloc_coherent(dev->dev, CQ_SIZE(nvmeq),
+					 &nvmeq->cq_dma_addr, GFP_KERNEL);
+	if (!nvmeq->cqes)
+		goto free_nvmeq;
+
+	nvmeq->ans2_tcb_ptr =
+		dma_alloc_coherent(dev->dev, APPLE_NVMMU_TCB_SIZE,
+				   &nvmeq->ans2_tcb_dma_addr, GFP_KERNEL);
+	if (!nvmeq->ans2_tcb_ptr)
+		goto free_cqdma;
+
+	lo_hi_writeq(nvmeq->ans2_tcb_dma_addr, nvmeq->nvmmu_base);
+
+	nvmeq->sq_cmds = dma_alloc_coherent(dev->dev, SQ_SIZE(nvmeq),
+				&nvmeq->sq_dma_addr, GFP_KERNEL);
+	if (!nvmeq->sq_cmds)
+		goto free_ans2;
+
+	nvmeq->dev = dev;
+	spin_lock_init(&nvmeq->sq_lock);
+	nvmeq->cq_head = 0;
+	nvmeq->cq_phase = 1;
+	nvmeq->q_db = &dev->dbs[apple_nvme_queue_id(nvmeq) * 2 * dev->db_stride];
+	dev->ctrl.queue_count++;
+
+	return 0;
+
+ free_ans2:
+	lo_hi_writeq(0, nvmeq->nvmmu_base);
+	dma_free_coherent(dev->dev, APPLE_NVMMU_TCB_SIZE,
+			  nvmeq->ans2_tcb_ptr,
+			  nvmeq->ans2_tcb_dma_addr);
+ free_cqdma:
+	dma_free_coherent(dev->dev, CQ_SIZE(nvmeq), (void *)nvmeq->cqes,
+			  nvmeq->cq_dma_addr);
+ free_nvmeq:
+	return -ENOMEM;
+}
+
+static void apple_nvme_init_queue(struct apple_nvme_queue *nvmeq)
+{
+	struct apple_nvme_dev *dev = nvmeq->dev;
+
+	nvmeq->cq_head = 0;
+	nvmeq->cq_phase = 1;
+	nvmeq->q_db = &dev->dbs[apple_nvme_queue_id(nvmeq) * 2 * dev->db_stride];
+	memset((void *)nvmeq->cqes, 0, CQ_SIZE(nvmeq));
+	wmb(); /* ensure the first interrupt sees the initialization */
+}
+
+static int apple_nvme_map_queues(struct blk_mq_tag_set *set)
+{
+	if (WARN_ON(set->nr_maps != 2))
+		return -EINVAL;
+
+	set->map[HCTX_TYPE_DEFAULT].nr_queues = 1;
+	set->map[HCTX_TYPE_READ].nr_queues = 0;
+
+	return 0;
+}
+
+static const struct blk_mq_ops apple_nvme_mq_admin_ops = {
+	.queue_rq	= apple_nvme_queue_rq,
+	.complete	= apple_nvme_common_complete_rq,
+	.init_hctx	= apple_nvme_admin_init_hctx,
+	.init_request	= apple_nvme_init_request,
+	.timeout	= apple_nvme_timeout,
+};
+
+static const struct blk_mq_ops apple_nvme_mq_ops = {
+	.queue_rq	= apple_nvme_queue_rq,
+	.complete	= apple_nvme_common_complete_rq,
+	.init_hctx	= apple_nvme_init_hctx,
+	.init_request	= apple_nvme_init_request,
+	.timeout	= apple_nvme_timeout,
+        .map_queues     = apple_nvme_map_queues,
+};
+
+static void apple_nvme_dev_remove_admin(struct apple_nvme_dev *dev)
+{
+	if (dev->ctrl.admin_q && !blk_queue_dying(dev->ctrl.admin_q)) {
+		/*
+		 * If the controller was reset during removal, it's possible
+		 * user requests may be waiting on a stopped queue. Start the
+		 * queue to flush these to completion.
+		 */
+		blk_mq_unquiesce_queue(dev->ctrl.admin_q);
+		blk_cleanup_queue(dev->ctrl.admin_q);
+		blk_mq_free_tag_set(&dev->admin_tagset);
+	}
+}
+
+static int apple_nvme_alloc_admin_tags(struct apple_nvme_dev *dev)
+{
+	if (!dev->ctrl.admin_q) {
+		dev->admin_tagset.ops = &apple_nvme_mq_admin_ops;
+		dev->admin_tagset.nr_hw_queues = 1;
+
+		dev->admin_tagset.queue_depth = NVME_AQ_MQ_TAG_DEPTH;
+		dev->admin_tagset.timeout = NVME_ADMIN_TIMEOUT;
+		dev->admin_tagset.numa_node = dev->ctrl.numa_node;
+		dev->admin_tagset.cmd_size = sizeof(struct apple_nvme_iod);
+		dev->admin_tagset.flags = BLK_MQ_F_NO_SCHED;
+		dev->admin_tagset.driver_data = dev;
+
+		if (blk_mq_alloc_tag_set(&dev->admin_tagset))
+			return -ENOMEM;
+		dev->ctrl.admin_tagset = &dev->admin_tagset;
+
+		dev->ctrl.admin_q = blk_mq_init_queue(&dev->admin_tagset);
+		if (IS_ERR(dev->ctrl.admin_q)) {
+			blk_mq_free_tag_set(&dev->admin_tagset);
+			return -ENOMEM;
+		}
+		if (!blk_get_queue(dev->ctrl.admin_q)) {
+			apple_nvme_dev_remove_admin(dev);
+			dev->ctrl.admin_q = NULL;
+			return -ENODEV;
+		}
+	} else
+		blk_mq_unquiesce_queue(dev->ctrl.admin_q);
+
+	return 0;
+}
+
+static int apple_nvme_configure_admin_queue(struct apple_nvme_dev *dev)
+{
+	int result;
+	u32 aqa;
+
+	result = nvme_disable_ctrl(&dev->ctrl);
+	if (result < 0)
+		return result;
+
+	result = apple_nvme_alloc_queue(dev, true);
+	if (result)
+		return result;
+
+	dev->ctrl.numa_node = dev_to_node(dev->dev);
+
+	aqa = dev->adminq->q_depth - 1;
+	aqa |= aqa << 16;
+
+	writel(aqa, dev->nvme_mmio + NVME_REG_AQA);
+	lo_hi_writeq(dev->adminq->sq_dma_addr, dev->nvme_mmio + NVME_REG_ASQ);
+	lo_hi_writeq(dev->adminq->cq_dma_addr, dev->nvme_mmio + NVME_REG_ACQ);
+
+	result = nvme_enable_ctrl(&dev->ctrl);
+	if (result)
+		return result;
+
+	apple_nvme_init_queue(dev->adminq);
+
+	dev->adminq_online = true;
+	set_bit(NVMEQ_ENABLED, &dev->adminq->flags);
+	return result;
+}
+
+static int apple_nvme_setup_io_queues_trylock(struct apple_nvme_dev *dev)
+{
+	/*
+	 * Give up if the lock is being held by nvme_dev_disable.
+	 */
+	if (!mutex_trylock(&dev->shutdown_lock))
+		return -ENODEV;
+
+	/*
+	 * Controller is in wrong state, fail early.
+	 */
+	if (dev->ctrl.state != NVME_CTRL_CONNECTING) {
+		mutex_unlock(&dev->shutdown_lock);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int apple_nvme_create_io_queue(struct apple_nvme_dev *dev)
+{
+	int ret = 0;
+
+	if (apple_nvme_alloc_queue(dev, false))
+		return -ENOMEM;
+
+	clear_bit(NVMEQ_DELETE_ERROR, &dev->ioq->flags);
+
+	ret = apple_adapter_alloc_cq(dev, dev->ioq);
+	if (ret)
+		return ret;
+
+	ret = apple_adapter_alloc_sq(dev, dev->ioq);
+	if (ret)
+		goto release_cq;
+
+	ret = apple_nvme_setup_io_queues_trylock(dev);
+	if (ret)
+		goto release_sq;
+	apple_nvme_init_queue(dev->ioq);
+
+	dev->ioq_online = true;
+	set_bit(NVMEQ_ENABLED, &dev->ioq->flags);
+	mutex_unlock(&dev->shutdown_lock);
+	return 0;
+
+release_sq:
+	apple_adapter_delete_sq(dev);
+release_cq:
+	apple_adapter_delete_cq(dev);
+	return ret;
+}
+
+static void apple_nvme_disable_io_queues(struct apple_nvme_dev *dev)
+{
+	if (__apple_nvme_disable_io_queues(dev, nvme_admin_delete_sq))
+		__apple_nvme_disable_io_queues(dev, nvme_admin_delete_cq);
+}
+
+static int apple_nvme_setup_io_queues(struct apple_nvme_dev *dev)
+{
+	unsigned int nr_io_queues = 1;
+	int result;
+
+	result = nvme_set_queue_count(&dev->ctrl, &nr_io_queues);
+	if (result < 0)
+		return result;
+
+	if (nr_io_queues == 0)
+		return 0;
+
+	result = apple_nvme_create_io_queue(dev);
+	if (result || !dev->ioq_online)
+		return result;
+
+	return 0;
+}
+
+static void apple_nvme_del_queue_end(struct request *req, blk_status_t error)
+{
+	struct apple_nvme_queue *nvmeq = req->end_io_data;
+
+	blk_mq_free_request(req);
+	complete(&nvmeq->delete_done);
+}
+
+static void apple_nvme_del_cq_end(struct request *req, blk_status_t error)
+{
+	struct apple_nvme_queue *nvmeq = req->end_io_data;
+
+	if (error)
+		set_bit(NVMEQ_DELETE_ERROR, &nvmeq->flags);
+
+	apple_nvme_del_queue_end(req, error);
+}
+
+static int apple_nvme_delete_queue(struct apple_nvme_queue *nvmeq, u8 opcode)
+{
+	struct request_queue *q = nvmeq->dev->ctrl.admin_q;
+	struct request *req;
+	struct nvme_command cmd = { };
+
+	cmd.delete_queue.opcode = opcode;
+	 /* we only have a single IO queue */
+	cmd.delete_queue.qid = cpu_to_le16(1);
+
+	req = nvme_alloc_request(q, &cmd, BLK_MQ_REQ_NOWAIT);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	req->end_io_data = nvmeq;
+
+	init_completion(&nvmeq->delete_done);
+	blk_execute_rq_nowait(NULL, req, false,
+			opcode == nvme_admin_delete_cq ?
+				apple_nvme_del_cq_end : apple_nvme_del_queue_end);
+	return 0;
+}
+
+static bool __apple_nvme_disable_io_queues(struct apple_nvme_dev *dev, u8 opcode)
+{
+	unsigned long timeout = NVME_ADMIN_TIMEOUT;
+
+	if (!dev->ioq_online)
+		return true;
+
+	if (apple_nvme_delete_queue(dev->ioq, opcode))
+		return false;
+
+	timeout =
+		wait_for_completion_io_timeout(&dev->ioq->delete_done, timeout);
+	if (timeout == 0)
+		return false;
+	return true;
+}
+
+static void apple_nvme_dev_add(struct apple_nvme_dev *dev)
+{
+	int ret;
+
+	if (!dev->ctrl.tagset) {
+		dev->tagset.ops = &apple_nvme_mq_ops;
+		dev->tagset.nr_hw_queues = 1;
+		dev->tagset.nr_maps = 2; /* admin + io */
+		dev->tagset.timeout = NVME_IO_TIMEOUT;
+		dev->tagset.numa_node = dev->ctrl.numa_node;
+		dev->tagset.queue_depth = APPLE_ANS2_QUEUE_DEPTH - 1;
+		dev->tagset.cmd_size = sizeof(struct apple_nvme_iod);
+		dev->tagset.flags = BLK_MQ_F_SHOULD_MERGE;
+		dev->tagset.driver_data = dev;
+
+		/*
+		 * This Apple controller requires tags to be unique
+		 * across admin and IO queue, so reserve the first 32
+		 * tags of the IO queue.
+		 */
+		dev->tagset.reserved_tags = NVME_AQ_DEPTH;
+
+		ret = blk_mq_alloc_tag_set(&dev->tagset);
+		if (ret) {
+			dev_warn(dev->ctrl.device,
+				"IO queues tagset allocation failed %d\n", ret);
+			return;
+		}
+		dev->ctrl.tagset = &dev->tagset;
+	} else {
+		WARN_ON(!dev->adminq_online);
+		WARN_ON(!dev->ioq_online);
+
+		blk_mq_update_nr_hw_queues(&dev->tagset, 1);
+
+		/* Free previously allocated IO queue that is no longer usable */
+		apple_nvme_free_queue(dev->ioq);
+		dev->ctrl.queue_count--;
+	}
+}
+
+static int apple_nvme_enable(struct apple_nvme_dev *dev)
+{
+	if (readl(dev->nvme_mmio + NVME_REG_CSTS) == -1)
+		return -ENODEV;
+
+	dev->ctrl.cap = lo_hi_readq(dev->nvme_mmio + NVME_REG_CAP);
+
+	dev->ctrl.sqsize = APPLE_ANS2_QUEUE_DEPTH - 1; /* 0's based queue depth */
+	dev->db_stride = 1 << NVME_CAP_STRIDE(dev->ctrl.cap);
+	dev->dbs = dev->nvme_mmio + 4096;
+
+	return 0;
+}
+
+static void apple_nvme_dev_disable(struct apple_nvme_dev *dev, bool shutdown)
+{
+	bool dead = true, freeze = false;
+	u32 csts;
+
+	mutex_lock(&dev->shutdown_lock);
+	csts = readl(dev->nvme_mmio + NVME_REG_CSTS);
+
+	if (dev->ctrl.state == NVME_CTRL_LIVE ||
+	    dev->ctrl.state == NVME_CTRL_RESETTING) {
+		freeze = true;
+		nvme_start_freeze(&dev->ctrl);
+	}
+	dead = !!((csts & NVME_CSTS_CFS) || !(csts & NVME_CSTS_RDY));
+
+	/*
+	 * Give the controller a chance to complete all entered requests if
+	 * doing a safe shutdown.
+	 */
+	if (!dead && shutdown && freeze)
+		nvme_wait_freeze_timeout(&dev->ctrl, NVME_IO_TIMEOUT);
+
+	nvme_stop_queues(&dev->ctrl);
+
+	if (!dead && dev->ctrl.queue_count > 0) {
+		apple_nvme_disable_io_queues(dev);
+		apple_nvme_disable_admin_queue(dev, shutdown);
+	}
+	if (dev->ioq_online)
+		apple_nvme_suspend_queue(dev->ioq);
+	apple_nvme_suspend_queue(dev->adminq);
+	if (dev->ctrl.queue_count > 1)
+		nvme_process_cq(dev->ioq);
+
+	blk_mq_tagset_busy_iter(&dev->tagset, nvme_cancel_request, &dev->ctrl);
+	blk_mq_tagset_busy_iter(&dev->admin_tagset, nvme_cancel_request, &dev->ctrl);
+	blk_mq_tagset_wait_completed_request(&dev->tagset);
+	blk_mq_tagset_wait_completed_request(&dev->admin_tagset);
+
+	/*
+	 * The driver will not be starting up queues again if shutting down so
+	 * must flush all entered requests to their failed completion to avoid
+	 * deadlocking blk-mq hot-cpu notifier.
+	 */
+	if (shutdown) {
+		nvme_start_queues(&dev->ctrl);
+		if (dev->ctrl.admin_q && !blk_queue_dying(dev->ctrl.admin_q))
+			blk_mq_unquiesce_queue(dev->ctrl.admin_q);
+	}
+	mutex_unlock(&dev->shutdown_lock);
+}
+
+static int apple_nvme_disable_prepare_reset(struct apple_nvme_dev *dev, bool shutdown)
+{
+	if (!nvme_wait_reset(&dev->ctrl))
+		return -EBUSY;
+	apple_nvme_dev_disable(dev, shutdown);
+	return 0;
+}
+
+static int apple_nvme_setup_prp_pools(struct apple_nvme_dev *dev)
+{
+	dev->prp_page_pool = dma_pool_create("prp list page", dev->dev,
+						NVME_CTRL_PAGE_SIZE,
+						NVME_CTRL_PAGE_SIZE, 0);
+	if (!dev->prp_page_pool)
+		return -ENOMEM;
+
+	/* Optimisation for I/Os between 4k and 128k */
+	dev->prp_small_pool = dma_pool_create("prp list 256", dev->dev,
+						256, 256, 0);
+	if (!dev->prp_small_pool) {
+		dma_pool_destroy(dev->prp_page_pool);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void apple_nvme_release_prp_pools(struct apple_nvme_dev *dev)
+{
+	dma_pool_destroy(dev->prp_page_pool);
+	dma_pool_destroy(dev->prp_small_pool);
+}
+
+static void apple_nvme_free_tagset(struct apple_nvme_dev *dev)
+{
+	if (dev->tagset.tags)
+		blk_mq_free_tag_set(&dev->tagset);
+	dev->ctrl.tagset = NULL;
+}
+
+static void apple_nvme_free_ctrl(struct nvme_ctrl *ctrl)
+{
+	struct apple_nvme_dev *dev = to_apple_nvme_dev(ctrl);
+
+	apple_nvme_free_tagset(dev);
+	if (dev->ctrl.admin_q)
+		blk_put_queue(dev->ctrl.admin_q);
+	mempool_destroy(dev->iod_mempool);
+	put_device(dev->dev);
+	kfree(dev->adminq);
+	kfree(dev->ioq);
+	kfree(dev);
+}
+
+static void apple_nvme_remove_dead_ctrl(struct apple_nvme_dev *dev)
+{
+	/*
+	 * Set state to deleting now to avoid blocking nvme_wait_reset(), which
+	 * may be holding this pci_dev's device lock.
+	 */
+	nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_DELETING);
+	nvme_get_ctrl(&dev->ctrl);
+	apple_nvme_dev_disable(dev, false);
+	nvme_kill_queues(&dev->ctrl);
+	if (!queue_work(nvme_wq, &dev->remove_work))
+		nvme_put_ctrl(&dev->ctrl);
+}
+
+static void apple_nvme_reset_work(struct work_struct *work)
+{
+	struct apple_nvme_dev *dev =
+		container_of(work, struct apple_nvme_dev, ctrl.reset_work);
+	int result;
+
+	if (WARN_ON(dev->ctrl.state != NVME_CTRL_RESETTING)) {
+		result = -ENODEV;
+		goto out;
+	}
+
+	/*
+	 * If we're called to reset a live controller first shut it down before
+	 * moving on.
+	 */
+	if (dev->ctrl.ctrl_config & NVME_CC_ENABLE)
+		apple_nvme_dev_disable(dev, false);
+	nvme_sync_queues(&dev->ctrl);
+
+	mutex_lock(&dev->shutdown_lock);
+
+	result = apple_nvme_enable(dev);
+	if (result)
+		goto out_unlock;
+
+	result = apple_nvme_configure_admin_queue(dev);
+	if (result)
+		goto out_unlock;
+
+	result = apple_nvme_alloc_admin_tags(dev);
+	if (result)
+		goto out_unlock;
+
+	/*
+	 * Limit the max command size to prevent iod->sg allocations going
+	 * over a single page.
+	 */
+	dev->ctrl.max_hw_sectors = min_t(u32,
+		NVME_MAX_KB_SZ << 1, dma_max_mapping_size(dev->dev) >> 9);
+	dev->ctrl.max_segments = NVME_MAX_SEGS;
+
+	/*
+	 * Don't limit the IOMMU merged segment size.
+	 */
+	dma_set_max_seg_size(dev->dev, 0xffffffff);
+	dma_set_min_align_mask(dev->dev, NVME_CTRL_PAGE_SIZE - 1);
+
+	mutex_unlock(&dev->shutdown_lock);
+
+	/*
+	 * Introduce CONNECTING state from nvme-fc/rdma transports to mark the
+	 * initializing procedure here.
+	 */
+	if (!nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_CONNECTING)) {
+		dev_warn(dev->ctrl.device,
+			"failed to mark controller CONNECTING\n");
+		result = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * We do not support an SGL for metadata (yet), so we are limited to a
+	 * single integrity segment for the separate metadata pointer.
+	 */
+	dev->ctrl.max_integrity_segments = 1;
+
+	result = nvme_init_ctrl_finish(&dev->ctrl);
+	if (result)
+		goto out;
+
+	result = apple_nvme_setup_io_queues(dev);
+	if (result)
+		goto out;
+
+	/*
+	 * Keep the controller around but remove all namespaces if we don't have
+	 * any working I/O queue.
+	 */
+	if (!dev->ioq_online) {
+		dev_warn(dev->ctrl.device, "IO queues not created\n");
+		nvme_kill_queues(&dev->ctrl);
+		nvme_remove_namespaces(&dev->ctrl);
+		apple_nvme_free_tagset(dev);
+	} else {
+		nvme_start_queues(&dev->ctrl);
+		nvme_wait_freeze(&dev->ctrl);
+		apple_nvme_dev_add(dev);
+		nvme_unfreeze(&dev->ctrl);
+	}
+
+	/*
+	 * If only admin queue live, keep it to do further investigation or
+	 * recovery.
+	 */
+	if (!nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_LIVE)) {
+		dev_warn(dev->ctrl.device,
+			"failed to mark controller live state\n");
+		result = -ENODEV;
+		goto out;
+	}
+
+	nvme_start_ctrl(&dev->ctrl);
+	return;
+
+ out_unlock:
+	mutex_unlock(&dev->shutdown_lock);
+ out:
+	if (result)
+		dev_warn(dev->ctrl.device,
+			 "Removing after probe failure status: %d\n", result);
+	apple_nvme_remove_dead_ctrl(dev);
+}
+
+static void apple_nvme_remove_dead_ctrl_work(struct work_struct *work)
+{
+	struct apple_nvme_dev *dev = container_of(work, struct apple_nvme_dev, remove_work);
+
+	if (dev_get_drvdata(dev->dev))
+		device_release_driver(dev->dev);
+	nvme_put_ctrl(&dev->ctrl);
+}
+
+static int apple_nvme_reg_read32(struct nvme_ctrl *ctrl, u32 off, u32 *val)
+{
+	*val = readl(to_apple_nvme_dev(ctrl)->nvme_mmio + off);
+	return 0;
+}
+
+static int apple_nvme_reg_write32(struct nvme_ctrl *ctrl, u32 off, u32 val)
+{
+	writel(val, to_apple_nvme_dev(ctrl)->nvme_mmio + off);
+	return 0;
+}
+
+static int apple_nvme_reg_read64(struct nvme_ctrl *ctrl, u32 off, u64 *val)
+{
+	*val = lo_hi_readq(to_apple_nvme_dev(ctrl)->nvme_mmio + off);
+	return 0;
+}
+
+static int apple_nvme_get_address(struct nvme_ctrl *ctrl, char *buf, int size)
+{
+	struct device *dev = to_apple_nvme_dev(ctrl)->dev;
+
+	return snprintf(buf, size, "%s\n", dev_name(dev));
+}
+
+static struct apple_nvme_dev *apple_nvme_dev_alloc(struct device *parent)
+{
+	struct apple_nvme_dev *dev;
+	size_t alloc_size;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->dev = get_device(parent);
+        dev->adminq = kzalloc(sizeof(*dev->adminq), GFP_KERNEL);
+        if (!dev->adminq)
+                goto free_dev;
+
+	dev->ioq = kzalloc(sizeof(*dev->ioq), GFP_KERNEL);
+        if (!dev->ioq)
+                goto free_adminq;
+
+	dev->adminq->is_adminq = true;
+	dev->ioq->is_adminq = false;
+
+	INIT_WORK(&dev->ctrl.reset_work, apple_nvme_reset_work);
+	INIT_WORK(&dev->remove_work, apple_nvme_remove_dead_ctrl_work);
+	mutex_init(&dev->shutdown_lock);
+
+	if (apple_nvme_setup_prp_pools(dev))
+		goto free_ioq;
+
+	/*
+	 * Double check that our mempool alloc size will cover the biggest
+	 * command we support.
+	 */
+	alloc_size = apple_nvme_iod_alloc_size();
+	WARN_ON_ONCE(alloc_size > PAGE_SIZE);
+
+	dev->iod_mempool = mempool_create(1, mempool_kmalloc,
+						mempool_kfree,
+						(void *) alloc_size);
+	if (!dev->iod_mempool)
+		goto free_pools;
+
+	return dev;
+
+free_pools:
+	apple_nvme_release_prp_pools(dev);
+free_ioq:
+	kfree(dev->ioq);
+free_adminq:
+        kfree(dev->adminq);
+free_dev:
+	kfree(dev);
+	return NULL;
+}
+
+static void apple_nvme_dev_free(struct apple_nvme_dev *dev)
+{
+	mempool_destroy(dev->iod_mempool);
+	apple_nvme_release_prp_pools(dev);
+	put_device(dev->dev);
+	kfree(dev->adminq);
+	kfree(dev->ioq);
+	kfree(dev);
+}
+
+/*
+ * The driver's remove may be called on a device in a partially initialized
+ * state. This function must not have any dependencies on the device state in
+ * order to proceed.
+ */
+static int apple_nvme_remove(struct platform_device *pdev)
+{
+	struct apple_nvme_dev *dev = platform_get_drvdata(pdev);
+
+	nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_DELETING);
+	platform_set_drvdata(pdev, NULL);
+	flush_work(&dev->ctrl.reset_work);
+	nvme_stop_ctrl(&dev->ctrl);
+	nvme_remove_namespaces(&dev->ctrl);
+	apple_nvme_dev_disable(dev, true);
+	apple_nvme_dev_remove_admin(dev);
+	if (dev->ctrl.queue_count > 1)
+		apple_nvme_free_queue(dev->ioq);
+	if (dev->ctrl.queue_count > 0)
+		apple_nvme_free_queue(dev->adminq);
+        dev->ctrl.queue_count = 0;
+	apple_nvme_release_prp_pools(dev);
+	nvme_uninit_ctrl(&dev->ctrl);
+
+	return 0;
+}
+
+static const struct nvme_ctrl_ops nvme_ctrl_ops = {
+	.name			= "platform",
+	.module			= THIS_MODULE,
+	.flags			= NVME_F_METADATA_SUPPORTED,
+	.reg_read32		= apple_nvme_reg_read32,
+	.reg_write32		= apple_nvme_reg_write32,
+	.reg_read64		= apple_nvme_reg_read64,
+	.free_ctrl		= apple_nvme_free_ctrl,
+	.submit_async_event	= apple_nvme_submit_async_event,
+	.get_address		= apple_nvme_get_address,
+};
+
+static void apple_nvme_async_probe(void *data, async_cookie_t cookie)
+{
+	struct apple_nvme_dev *dev = data;
+
+	flush_work(&dev->ctrl.reset_work);
+	flush_work(&dev->ctrl.scan_work);
+	nvme_put_ctrl(&dev->ctrl);
+}
+
+static void apple_nvme_rx_callback(void *cookie, u8 endpoint, u64 message)
+{
+        struct apple_nvme_dev *dev = cookie;
+	dev_warn(dev->dev, "Unexpected message from ANS2: %016llx\n", (u64)message);
+}
+
+static void *apple_nvme_sart_alloc(void *cookie, size_t size, dma_addr_t *dma_handle,
+			    gfp_t flag)
+{
+	struct apple_nvme_dev *dev = cookie;
+	void *cpu_addr = dma_alloc_coherent(dev->dev, size, dma_handle, flag);
+
+	apple_sart_add_allowed_region(dev->sart, *dma_handle, size);
+
+	return cpu_addr;
+}
+
+static struct apple_rtkit_ops sart_rtkit_ops =
+{
+	.flags = APPLE_RTKIT_SHMEM_OWNER_LINUX,
+	.shmem_alloc = apple_nvme_sart_alloc,
+	.recv_message = apple_nvme_rx_callback,
+};
+
+static int apple_nvme_probe(struct platform_device *pdev)
+{
+	int result, ret;
+	struct apple_nvme_dev *dev;
+	struct resource *res;
+	u32 ans2_boot_status;
+
+	dev = apple_nvme_dev_alloc(&pdev->dev);
+	if (!dev)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, dev);
+	dev->nvme_mmio = devm_platform_ioremap_resource(pdev, 0);
+	result = PTR_ERR_OR_ZERO(dev->nvme_mmio);
+	if (result)
+		goto out;
+
+	if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {
+		result = ENXIO;
+		goto out_unmap;
+	}
+
+	dev->dbs = dev->nvme_mmio + NVME_REG_DBS;
+	dev->adminq->ans2_q_db = dev->nvme_mmio + APPLE_ANS2_LINEAR_ASQ_DB;
+	dev->adminq->nvmmu_base = dev->nvme_mmio + APPLE_NVMMU_BASE_ASQ;
+	dev->ioq->ans2_q_db = dev->nvme_mmio + APPLE_ANS2_LINEAR_IOSQ_DB;
+	dev->ioq->nvmmu_base = dev->nvme_mmio + APPLE_NVMMU_BASE_IOSQ;
+
+	dev->platform_irq = platform_get_irq(pdev, 0);
+	if (dev->platform_irq < 0) {
+		result = dev->platform_irq;
+		goto out_unmap;
+	}
+
+	result = devm_request_irq(dev->dev, dev->platform_irq, apple_nvme_irq,
+				  0, "nvme", dev);
+	if (result)
+		goto out_unmap;
+
+	dev->sart = apple_sart_get(&pdev->dev);
+	if (IS_ERR(dev->sart)) {
+		result = PTR_ERR(dev->sart);
+		goto out_unmap;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "coproc");
+	if (!res) {
+		result = -EINVAL;
+		goto out_unmap;
+	}
+
+	dev->rtk = apple_rtkit_init(dev->dev, dev, res, NULL, 0,
+				    &sart_rtkit_ops);
+	if (!dev->rtk) {
+		result = PTR_ERR(dev->rtk);
+		goto out_unmap;
+	}
+
+	ret = apple_rtkit_boot_wait(dev->rtk, APPLE_ANS_BOOT_TIMEOUT);
+	if (ret) {
+		dev_err(dev->dev, "RTKit did not boot");
+		goto out_unmap;
+	}
+
+	result = readl_poll_timeout(
+		dev->nvme_mmio + APPLE_ANS2_BOOT_STATUS, ans2_boot_status,
+		ans2_boot_status == APPLE_ANS2_BOOT_STATUS_OK, 100, 10000000);
+	if (result) {
+		dev_err(dev->dev, "ANS did not boot");
+		goto out_unmap;
+	}
+
+	writel(APPLE_ANS2_MAX_PEND_CMDS | (APPLE_ANS2_MAX_PEND_CMDS << 16),
+	       dev->nvme_mmio + APPLE_ANS2_MAX_PEND_CMDS_CTRL);
+	writel(APPLE_ANS2_LINEAR_SQ_EN, dev->nvme_mmio + APPLE_ANS2_LINEAR_SQ_CTRL);
+	writel(readl(dev->nvme_mmio + APPLE_ANS2_UNKNOWN_CTRL) &
+		       ~APPLE_ANS2_PRP_NULL_CHECK,
+	       dev->nvme_mmio + APPLE_ANS2_UNKNOWN_CTRL);
+	writel(APPLE_NVMMU_NUM_TCBS - 1, dev->nvme_mmio + APPLE_NVMMU_NUM);
+
+	result = nvme_init_ctrl(&dev->ctrl, &pdev->dev, &nvme_ctrl_ops,
+				NVME_QUIRK_NO_SCAN_NS_LIST | NVME_QUIRK_SKIP_CID_GEN);
+	if (result)
+		goto out_unmap;
+
+	nvme_reset_ctrl(&dev->ctrl);
+	async_schedule(apple_nvme_async_probe, dev);
+
+	return 0;
+
+out_unmap:
+	devm_iounmap(&pdev->dev, dev->nvme_mmio);
+out:
+	apple_nvme_dev_free(dev);
+	return result;
+}
+
+static void apple_nvme_shutdown(struct platform_device *pdev)
+{
+	struct apple_nvme_dev *dev = platform_get_drvdata(pdev);
+
+	apple_nvme_disable_prepare_reset(dev, true);
+}
+
+static const struct of_device_id nvme_of_device_ids[] = {
+	{ .compatible = "apple,t8103-ans-nvme", },
+	{},
+};
+
+static struct platform_driver nvme_driver = {
+	.driver = {
+		.name = "apple-ans-nvme",
+		.owner = THIS_MODULE,
+		.of_match_table = nvme_of_device_ids,
+	},
+	.probe = apple_nvme_probe,
+	.remove = apple_nvme_remove,
+	.shutdown = apple_nvme_shutdown,
+};
+
+static int __init apple_nvme_init(void)
+{
+	int ret;
+
+	BUILD_BUG_ON(sizeof(struct nvme_create_cq) != 64);
+	BUILD_BUG_ON(sizeof(struct nvme_create_sq) != 64);
+	BUILD_BUG_ON(sizeof(struct nvme_delete_queue) != 64);
+	BUILD_BUG_ON(sizeof(struct apple_nvmmu_tcb) != 128);
+	BUILD_BUG_ON(BLK_MQ_MAX_DEPTH < APPLE_ANS2_QUEUE_DEPTH);
+
+	ret = platform_driver_register(&nvme_driver);
+
+	return ret;
+}
+
+static void __exit apple_nvme_exit(void)
+{
+	platform_driver_unregister(&nvme_driver);
+	flush_workqueue(nvme_wq);
+}
+
+MODULE_AUTHOR("Sven Peter <sven@svenpeter.dev>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+module_init(apple_nvme_init);
+module_exit(apple_nvme_exit);
-- 
2.34.0


From 0cd2d33333aa2cf82d8094b0bff49961e36ee574 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 20:45:14 +0900
Subject: [PATCH 22/83] arm64: dts: apple: Add ANS2 nodes to t6001.dtsi

This adds support for the NVMe controller.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index 2dc9e39c00d0..68e8f91ea8e7 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -464,5 +464,33 @@ dwc3_3: usb@1302280000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
+
+		ans2_mbox: mbox@38f408000 {
+			compatible = "apple,t8103-asc-mailbox";
+			reg = <0x3 0x8f408000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1069 IRQ_TYPE_LEVEL_HIGH>,
+				<AIC_IRQ 0 1070 IRQ_TYPE_LEVEL_HIGH>,
+				<AIC_IRQ 0 1071 IRQ_TYPE_LEVEL_HIGH>,
+				<AIC_IRQ 0 1072 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "send-empty", "send-not-empty",
+				"recv-empty", "recv-not-empty";
+			#mbox-cells = <0>;
+		};
+
+		sart: sart@393c50000 {
+			compatible = "apple,t6000-sart";
+			reg = <0x3 0x93c50000 0x0 0x10000>;
+		};
+
+		ans2: nvme@393cc0000 {
+			compatible = "apple,t8103-ans-nvme";
+			reg = <0x3 0x93cc0000 0x0 0x40000>, <0x3 0x8f400000 0x0 0x4000>;
+			reg-names = "nvme", "coproc";
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1613 IRQ_TYPE_LEVEL_HIGH>;
+			mboxes = <&ans2_mbox>;
+			apple,sart = <&sart>;
+		};
 	};
 };
-- 
2.34.0


From 0f820f92dcce47a63b692bce0cc94aad4bb32a41 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 20:46:15 +0900
Subject: [PATCH 23/83] soc: apple: sart: Add SARTv3 support

As found on t600x SoCs.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/soc/apple/apple-sart.c | 128 ++++++++++++++++++++++++---------
 1 file changed, 93 insertions(+), 35 deletions(-)

diff --git a/drivers/soc/apple/apple-sart.c b/drivers/soc/apple/apple-sart.c
index d28ef1e9d4f4..267b1eaa95b4 100644
--- a/drivers/soc/apple/apple-sart.c
+++ b/drivers/soc/apple/apple-sart.c
@@ -21,6 +21,9 @@
 #include <linux/platform_device.h>
 #include <linux/types.h>
 
+#define APPLE_SART_MAX_ENTRIES 16
+
+/* SARTv2 registers */
 #define APPLE_SART_CONFIG(idx) (0x00 + 4 * (idx))
 #define APPLE_SART_CONFIG_FLAGS GENMASK(31, 24)
 #define APPLE_SART_CONFIG_SIZE GENMASK(23, 0)
@@ -31,7 +34,21 @@
 #define APPLE_SART_PADDR(idx) (0x40 + 4 * (idx))
 #define APPLE_SART_PADDR_SHIFT 12
 
-#define APPLE_SART_MAX_ENTRIES 16
+/* SARTv3 registers */
+#define APPLE_SART3_CONFIG(idx) (0x00 + 4 * (idx))
+
+#define APPLE_SART3_PADDR(idx) (0x40 + 4 * (idx))
+#define APPLE_SART3_PADDR_SHIFT 12
+
+#define APPLE_SART3_SIZE(idx) (0x80 + 4 * (idx))
+#define APPLE_SART3_SIZE_SHIFT 12
+
+struct apple_sart_ops {
+	void (*get_entry)(struct apple_sart *sart, int index, u8 *flags, phys_addr_t *paddr,
+			  size_t *size);
+	void (*set_entry)(struct apple_sart *sart, int index, u8 flags, phys_addr_t paddr,
+			  size_t size);
+};
 
 /*
  * Private structure attached to the SART device struct as drvdata.
@@ -51,10 +68,59 @@ struct apple_sart {
 	struct clk_bulk_data *clks;
 	int num_clks;
 
+	const struct apple_sart_ops *ops;
+
 	unsigned long protected_entries;
 	unsigned long used_entries;
 };
 
+static void sart2_get_entry(struct apple_sart *sart, int index, u8 *flags, phys_addr_t *paddr,
+			    size_t *size)
+{
+	u32 cfg = readl_relaxed(sart->regs + APPLE_SART_CONFIG(index));
+	*flags = FIELD_GET(APPLE_SART_CONFIG_FLAGS, cfg);
+	*size = FIELD_GET(APPLE_SART_CONFIG_SIZE, cfg) << APPLE_SART_CONFIG_SIZE_SHIFT;
+	*paddr = readl_relaxed(sart->regs + APPLE_SART_PADDR(index)) << APPLE_SART_PADDR_SHIFT;
+}
+
+static void sart2_set_entry(struct apple_sart *sart, int index, u8 flags, phys_addr_t paddr,
+			    size_t size)
+{
+	u32 cfg = FIELD_PREP(APPLE_SART_CONFIG_FLAGS, flags);
+	cfg |= FIELD_PREP(APPLE_SART_CONFIG_SIZE, size >> APPLE_SART_CONFIG_SIZE_SHIFT);
+
+	writel_relaxed(paddr >>= APPLE_SART_PADDR_SHIFT, sart->regs + APPLE_SART_PADDR(index));
+	writel_relaxed(cfg, sart->regs + APPLE_SART_CONFIG(index));
+}
+
+static struct apple_sart_ops sart_ops_v2 = {
+	.get_entry = sart2_get_entry,
+	.set_entry = sart2_set_entry,
+};
+
+static void sart3_get_entry(struct apple_sart *sart, int index, u8 *flags, phys_addr_t *paddr,
+			    size_t *size)
+{
+	*flags = readl_relaxed(sart->regs + APPLE_SART3_CONFIG(index));
+	*size = (size_t)readl_relaxed(sart->regs + APPLE_SART3_SIZE(index))
+			<< APPLE_SART3_SIZE_SHIFT;
+	*paddr = (phys_addr_t)readl_relaxed(sart->regs + APPLE_SART_PADDR(index))
+			<< APPLE_SART_PADDR_SHIFT;
+}
+
+static void sart3_set_entry(struct apple_sart *sart, int index, u8 flags, phys_addr_t paddr,
+			    size_t size)
+{
+	writel_relaxed(paddr >>= APPLE_SART_PADDR_SHIFT, sart->regs + APPLE_SART_PADDR(index));
+	writel_relaxed(size >>= APPLE_SART3_SIZE_SHIFT, sart->regs + APPLE_SART3_SIZE(index));
+	writel_relaxed(flags, sart->regs + APPLE_SART3_CONFIG(index));
+}
+
+static struct apple_sart_ops sart_ops_v3 = {
+	.get_entry = sart3_get_entry,
+	.set_entry = sart3_set_entry,
+};
+
 static int apple_sart_probe(struct platform_device *pdev)
 {
 	int i, ret;
@@ -67,6 +133,7 @@ static int apple_sart_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, sart);
 
 	sart->dev = dev;
+	sart->ops = of_device_get_match_data(dev);
 
 	sart->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(sart->regs))
@@ -82,13 +149,11 @@ static int apple_sart_probe(struct platform_device *pdev)
 		return ret;
 
 	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
-		u32 cfg = readl_relaxed(sart->regs + APPLE_SART_CONFIG(i));
-		u8 flags = FIELD_GET(APPLE_SART_CONFIG_FLAGS, cfg);
-		size_t size = FIELD_GET(APPLE_SART_CONFIG_SIZE, cfg)
-			      << APPLE_SART_CONFIG_SIZE_SHIFT;
-		phys_addr_t paddr =
-			readl_relaxed(sart->regs + APPLE_SART_PADDR(i));
-		paddr <<= APPLE_SART_PADDR_SHIFT;
+		u8 flags;
+		size_t size;
+		phys_addr_t paddr;
+
+		sart->ops->get_entry(sart, i, &flags, &paddr, &size);
 
 		if (!flags)
 			continue;
@@ -152,26 +217,16 @@ int apple_sart_add_allowed_region(struct apple_sart *sart, phys_addr_t paddr,
 		"will add [paddr: 0x%llx, size: 0x%zx] to allowed regions\n",
 		paddr, size);
 
-	size >>= APPLE_SART_CONFIG_SIZE_SHIFT;
-	paddr >>= APPLE_SART_PADDR_SHIFT;
-
 	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
-		u32 config;
-
 		if (test_bit(i, &sart->protected_entries))
 			continue;
 		if (test_and_set_bit(i, &sart->used_entries))
 			continue;
 
-		config = FIELD_PREP(APPLE_SART_CONFIG_FLAGS,
-				    APPLE_SART_CONFIG_FLAGS_ALLOW);
-		config |= FIELD_PREP(APPLE_SART_CONFIG_SIZE, size);
-
-		writel_relaxed(paddr, sart->regs + APPLE_SART_PADDR(i));
-		writel_relaxed(config, sart->regs + APPLE_SART_CONFIG(i));
+		sart->ops->set_entry(sart, i, APPLE_SART_CONFIG_FLAGS_ALLOW, paddr, size);
 
-		dev_dbg(sart->dev, "wrote [0x%llx, 0x%x] to %02d\n", paddr,
-			config, i);
+		dev_dbg(sart->dev, "wrote [0x%llx, 0x%lx] to %02d\n", paddr,
+			size, i);
 		return 0;
 	}
 
@@ -211,21 +266,17 @@ int apple_sart_remove_allowed_region(struct apple_sart *sart, phys_addr_t paddr,
 	paddr >>= APPLE_SART_PADDR_SHIFT;
 
 	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
-		u32 config;
+		u8 eflags;
+		size_t esize;
+		phys_addr_t epaddr;
 
-		if (test_bit(i, &sart->protected_entries))
-			continue;
-		if (!test_bit(i, &sart->used_entries))
+		sart->ops->get_entry(sart, i, &eflags, &epaddr, &esize);
+		
+		if (epaddr != paddr || esize != size)
 			continue;
 
-		config = readl_relaxed(sart->regs + APPLE_SART_PADDR(i));
-		if (FIELD_GET(APPLE_SART_CONFIG_SIZE, config) != size)
-			continue;
-		if (readl_relaxed(sart->regs + APPLE_SART_PADDR(i)) != paddr)
-			continue;
+		sart->ops->set_entry(sart, i, 0, 0, 0);
 
-		writel_relaxed(0, sart->regs + APPLE_SART_CONFIG(i));
-		writel_relaxed(0, sart->regs + APPLE_SART_PADDR(i));
 		clear_bit(i, &sart->used_entries);
 		dev_dbg(sart->dev, "cleared entry %02d\n", i);
 		return 0;
@@ -246,13 +297,20 @@ static void apple_sart_shutdown(struct platform_device *pdev)
 	for (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {
 		if (test_bit(i, &sart->protected_entries))
 			continue;
-		writel_relaxed(0, sart->regs + APPLE_SART_CONFIG(i));
-		writel_relaxed(0, sart->regs + APPLE_SART_PADDR(i));
+
+		sart->ops->set_entry(sart, i, 0, 0, 0);
 	}
 }
 
 static const struct of_device_id apple_sart_of_match[] = {
-	{ .compatible = "apple,t8103-sart", },
+	{
+		.compatible = "apple,t6000-sart",
+		.data = &sart_ops_v3,
+	},
+	{
+		.compatible = "apple,t8103-sart",
+		.data = &sart_ops_v2,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, apple_sart_of_match);
-- 
2.34.0


From 2553b9d0950f834cb47acc1459ad1f1f49edf963 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 23:34:48 +0900
Subject: [PATCH 24/83] drm/format-helper: Add
 drm_fb_xrgb8888_to_xrgb2101010_dstclip()

Add XRGB8888 emulation support for devices that can only do XRGB2101010.

This is chiefly useful for simpledrm on Apple devices where the
bootloader-provided framebuffer is 10-bit.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/gpu/drm/drm_format_helper.c | 64 +++++++++++++++++++++++++++++
 include/drm/drm_format_helper.h     |  4 ++
 2 files changed, 68 insertions(+)

diff --git a/drivers/gpu/drm/drm_format_helper.c b/drivers/gpu/drm/drm_format_helper.c
index 69fde60e36b3..d1f6868f3aa1 100644
--- a/drivers/gpu/drm/drm_format_helper.c
+++ b/drivers/gpu/drm/drm_format_helper.c
@@ -378,6 +378,60 @@ void drm_fb_xrgb8888_to_rgb888_dstclip(void __iomem *dst, unsigned int dst_pitch
 }
 EXPORT_SYMBOL(drm_fb_xrgb8888_to_rgb888_dstclip);
 
+static void drm_fb_xrgb8888_to_xrgb2101010_line(u32 *dbuf, u32 *sbuf,
+						unsigned int pixels)
+{
+	unsigned int x;
+
+	for (x = 0; x < pixels; x++) {
+		*dbuf++ = ((sbuf[x] & 0x000000FF) << 2) |
+			  ((sbuf[x] & 0x0000FF00) << 4) |
+			  ((sbuf[x] & 0x00FF0000) << 6);
+	}
+}
+
+/**
+ * drm_fb_xrgb8888_to_xrgb2101010_dstclip - Convert XRGB8888 to XRGB2101010 clip
+ * buffer
+ * @dst: XRGB2101010 destination buffer (iomem)
+ * @dst_pitch: destination buffer pitch
+ * @vaddr: XRGB8888 source buffer
+ * @fb: DRM framebuffer
+ * @clip: Clip rectangle area to copy
+ *
+ * Drivers can use this function for XRGB2101010 devices that don't natively
+ * support XRGB8888.
+ *
+ * This function applies clipping on dst, i.e. the destination is a
+ * full (iomem) framebuffer but only the clip rect content is copied over.
+ */
+void drm_fb_xrgb8888_to_xrgb2101010_dstclip(void __iomem *dst,
+					    unsigned int dst_pitch, void *vaddr,
+					    struct drm_framebuffer *fb,
+					    struct drm_rect *clip)
+{
+	size_t linepixels = clip->x2 - clip->x1;
+	size_t dst_len = linepixels * 4;
+	unsigned y, lines = clip->y2 - clip->y1;
+	void *dbuf;
+
+	dbuf = kmalloc(dst_len, GFP_KERNEL);
+	if (!dbuf)
+		return;
+
+	vaddr += clip_offset(clip, fb->pitches[0], sizeof(u32));
+	dst += clip_offset(clip, dst_pitch, sizeof(u16));
+	for (y = 0; y < lines; y++) {
+		drm_fb_xrgb8888_to_xrgb2101010_line(dbuf, vaddr, linepixels);
+		memcpy_toio(dst, dbuf, dst_len);
+		vaddr += fb->pitches[0];
+		dst += dst_len;
+	}
+
+	kfree(dbuf);
+}
+EXPORT_SYMBOL(drm_fb_xrgb8888_to_rgb888_dstclip);
+
 /**
  * drm_fb_xrgb8888_to_gray8 - Convert XRGB8888 to grayscale
  * @dst: 8-bit grayscale destination buffer
@@ -464,6 +518,10 @@ int drm_fb_blit_rect_dstclip(void __iomem *dst, unsigned int dst_pitch,
 		fb_format = DRM_FORMAT_XRGB8888;
 	if (dst_format == DRM_FORMAT_ARGB8888)
 		dst_format = DRM_FORMAT_XRGB8888;
+	if (fb_format == DRM_FORMAT_ARGB2101010)
+		fb_format = DRM_FORMAT_XRGB2101010;
+	if (dst_format == DRM_FORMAT_ARGB2101010)
+		dst_format = DRM_FORMAT_XRGB2101010;
 
 	if (dst_format == fb_format) {
 		drm_fb_memcpy_dstclip(dst, dst_pitch, vmap, fb, clip);
@@ -482,6 +540,12 @@ int drm_fb_blit_rect_dstclip(void __iomem *dst, unsigned int dst_pitch,
 							  vmap, fb, clip);
 			return 0;
 		}
+	} else if (dst_format == DRM_FORMAT_XRGB2101010) {
+		if (fb_format == DRM_FORMAT_XRGB8888) {
+			drm_fb_xrgb8888_to_xrgb2101010_dstclip(dst, dst_pitch,
+							       vmap, fb, clip);
+			return 0;
+		}
 	}
 
 	return -EINVAL;
diff --git a/include/drm/drm_format_helper.h b/include/drm/drm_format_helper.h
index e86925cf07b9..a0faa710878b 100644
--- a/include/drm/drm_format_helper.h
+++ b/include/drm/drm_format_helper.h
@@ -29,6 +29,10 @@ void drm_fb_xrgb8888_to_rgb888(void *dst, void *src, struct drm_framebuffer *fb,
 void drm_fb_xrgb8888_to_rgb888_dstclip(void __iomem *dst, unsigned int dst_pitch,
 				       void *vaddr, struct drm_framebuffer *fb,
 				       struct drm_rect *clip);
+void drm_fb_xrgb8888_to_xrgb2101010_dstclip(void __iomem *dst,
+					    unsigned int dst_pitch, void *vaddr,
+					    struct drm_framebuffer *fb,
+					    struct drm_rect *clip);
 void drm_fb_xrgb8888_to_gray8(u8 *dst, void *vaddr, struct drm_framebuffer *fb,
 			      struct drm_rect *clip);
 
-- 
2.34.0


From e0566ef9a2d0ce2df250bf5899fa941d90e76a5a Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 23:36:00 +0900
Subject: [PATCH 25/83] drm/simpledrm: Bind to OF framebuffers in /chosen

This matches the simplefb behavior; these nodes are not matched by the
standard OF machinery.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/gpu/drm/tiny/simpledrm.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/drivers/gpu/drm/tiny/simpledrm.c b/drivers/gpu/drm/tiny/simpledrm.c
index 481b48bde047..0d10ea59bc04 100644
--- a/drivers/gpu/drm/tiny/simpledrm.c
+++ b/drivers/gpu/drm/tiny/simpledrm.c
@@ -2,6 +2,7 @@
 
 #include <linux/clk.h>
 #include <linux/of_clk.h>
+#include <linux/of_platform.h>
 #include <linux/platform_data/simplefb.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
@@ -897,5 +898,21 @@ static struct platform_driver simpledrm_platform_driver = {
 
 module_platform_driver(simpledrm_platform_driver);
 
+static int __init simplefb_init(void)
+{
+	struct device_node *np;
+
+	if (IS_ENABLED(CONFIG_OF_ADDRESS) && of_chosen) {
+		for_each_child_of_node(of_chosen, np) {
+			if (of_device_is_compatible(np, "simple-framebuffer"))
+				of_platform_device_create(np, NULL, NULL);
+		}
+	}
+
+	return 0;
+}
+
+fs_initcall(simplefb_init);
+
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL v2");
-- 
2.34.0


From 96ec4ec0add5caada6de5a74adee95928eb62016 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 10 Nov 2021 23:36:42 +0900
Subject: [PATCH 26/83] drm/simpledrm: Add XRGB2101010 format

This is the format used by the bootloader framebuffer on Apple ARM64
platforms.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/gpu/drm/drm_format_helper.c | 6 +++---
 drivers/gpu/drm/tiny/simpledrm.c    | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/drm_format_helper.c b/drivers/gpu/drm/drm_format_helper.c
index d1f6868f3aa1..e676921422b8 100644
--- a/drivers/gpu/drm/drm_format_helper.c
+++ b/drivers/gpu/drm/drm_format_helper.c
@@ -420,17 +420,17 @@ void drm_fb_xrgb8888_to_xrgb2101010_dstclip(void __iomem *dst,
 		return;
 
 	vaddr += clip_offset(clip, fb->pitches[0], sizeof(u32));
-	dst += clip_offset(clip, dst_pitch, sizeof(u16));
+	dst += clip_offset(clip, dst_pitch, sizeof(u32));
 	for (y = 0; y < lines; y++) {
 		drm_fb_xrgb8888_to_xrgb2101010_line(dbuf, vaddr, linepixels);
 		memcpy_toio(dst, dbuf, dst_len);
 		vaddr += fb->pitches[0];
-		dst += dst_len;
+		dst += dst_pitch;
 	}
 
 	kfree(dbuf);
 }
-EXPORT_SYMBOL(drm_fb_xrgb8888_to_rgb888_dstclip);
+EXPORT_SYMBOL(drm_fb_xrgb8888_to_xrgb2101010_dstclip);
 
 /**
  * drm_fb_xrgb8888_to_gray8 - Convert XRGB8888 to grayscale
diff --git a/drivers/gpu/drm/tiny/simpledrm.c b/drivers/gpu/drm/tiny/simpledrm.c
index 0d10ea59bc04..01433cc7a588 100644
--- a/drivers/gpu/drm/tiny/simpledrm.c
+++ b/drivers/gpu/drm/tiny/simpledrm.c
@@ -571,7 +571,7 @@ static const uint32_t simpledrm_default_formats[] = {
 	//DRM_FORMAT_XRGB1555,
 	//DRM_FORMAT_ARGB1555,
 	DRM_FORMAT_RGB888,
-	//DRM_FORMAT_XRGB2101010,
+	DRM_FORMAT_XRGB2101010,
 	//DRM_FORMAT_ARGB2101010,
 };
 
-- 
2.34.0


From e7aee255b6a3a19ed6cbfc4f1e53bd33ff1feab0 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Thu, 11 Nov 2021 01:00:01 +0900
Subject: [PATCH 27/83] drm/format-helper: Fix dst computation in
 drm_fb_xrgb8888_to_rgb888_dstclip()

The dst pointer was being advanced by the clip width, not the full line
stride, resulting in corruption. The clip offset was also calculated
incorrectly.

Cc: stable@vger.kernel.org
Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/gpu/drm/drm_format_helper.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/drm_format_helper.c b/drivers/gpu/drm/drm_format_helper.c
index e676921422b8..12bc6b45e95b 100644
--- a/drivers/gpu/drm/drm_format_helper.c
+++ b/drivers/gpu/drm/drm_format_helper.c
@@ -366,12 +366,12 @@ void drm_fb_xrgb8888_to_rgb888_dstclip(void __iomem *dst, unsigned int dst_pitch
 		return;
 
 	vaddr += clip_offset(clip, fb->pitches[0], sizeof(u32));
-	dst += clip_offset(clip, dst_pitch, sizeof(u16));
+	dst += clip_offset(clip, dst_pitch, 3);
 	for (y = 0; y < lines; y++) {
 		drm_fb_xrgb8888_to_rgb888_line(dbuf, vaddr, linepixels);
 		memcpy_toio(dst, dbuf, dst_len);
 		vaddr += fb->pitches[0];
-		dst += dst_len;
+		dst += dst_pitch;
 	}
 
 	kfree(dbuf);
-- 
2.34.0


From 7cf636797072f20a95f608ba6796c86fd645f82a Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 24 Nov 2021 16:34:16 +0900
Subject: [PATCH 28/83] dt-bindings: power: Add apple,pmgr-pwrstate binding

This syscon child node represents a single SoC device controlled by the
PMGR block. This layout allows us to declare all device power state
controls (power/clock gating and reset) in the device tree, including
dependencies, instead of hardcoding it into the driver. The register
layout is uniform.

Each pmgr-pwrstate node provides genpd and reset features, to be
consumed by downstream device nodes.

Future SoCs are expected to use backwards compatible registers, and the
"apple,pmgr-pwrstate" represents any such interfaces (possibly with
additional features gated by the more specific compatible), allowing
them to be bound without driver updates. If a backwards incompatible
change is introduced in future SoCs, it will require a new compatible,
such as "apple,pmgr-pwrstate-v2".

Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Reviewed-by: Rob Herring <robh@kernel.org>
Signed-off-by: Hector Martin <marcan@marcan.st>
---
 .../bindings/power/apple,pmgr-pwrstate.yaml   | 71 +++++++++++++++++++
 1 file changed, 71 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/power/apple,pmgr-pwrstate.yaml

diff --git a/Documentation/devicetree/bindings/power/apple,pmgr-pwrstate.yaml b/Documentation/devicetree/bindings/power/apple,pmgr-pwrstate.yaml
new file mode 100644
index 000000000000..5056d08b8261
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/apple,pmgr-pwrstate.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/power/apple,pmgr-pwrstate.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Apple SoC PMGR Power States
+
+maintainers:
+  - Hector Martin <marcan@marcan.st>
+
+allOf:
+  - $ref: "power-domain.yaml#"
+
+description: |
+  Apple SoCs include PMGR blocks responsible for power management,
+  which can control various clocks, resets, power states, and
+  performance features. This binding describes the device power
+  state registers, which control power states and resets.
+
+  Each instance of a power controller within the PMGR syscon node
+  represents a generic power domain provider, as documented in
+  Documentation/devicetree/bindings/power/power-domain.yaml.
+  The provider controls a single SoC block. The power hierarchy is
+  represented via power-domains relationships between these nodes.
+
+  See Documentation/devicetree/bindings/arm/apple/apple,pmgr.yaml
+  for the top-level PMGR node documentation.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - apple,t8103-pmgr-pwrstate
+          - apple,t6000-pmgr-pwrstate
+      - const: apple,pmgr-pwrstate
+
+  reg:
+    maxItems: 1
+
+  "#power-domain-cells":
+    const: 0
+
+  "#reset-cells":
+    const: 0
+
+  power-domains:
+    description:
+      Reference to parent power domains. A domain may have multiple parents,
+      and all will be powered up when it is powered.
+    minItems: 1
+    maxItems: 8 # Arbitrary, should be enough
+
+  label:
+    description:
+      Specifies the name of the SoC domain being controlled. This is used to
+      name the power/reset domains.
+
+  apple,always-on:
+    description:
+      Forces this power domain to always be powered up.
+    type: boolean
+
+required:
+  - compatible
+  - reg
+  - "#power-domain-cells"
+  - "#reset-cells"
+  - label
+
+additionalProperties: false
-- 
2.34.0


From 79e0796d2423b9653e9cd44e6db5dd2fb711ffac Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Tue, 5 Oct 2021 22:53:35 +0900
Subject: [PATCH 29/83] dt-bindings: arm: apple: Add apple,pmgr binding

The PMGR block in Apple Silicon SoCs is responsible for SoC power
management. There are two PMGRs in T8103, with different register
layouts but compatible registers. In order to support this as well
as future SoC generations with backwards-compatible registers, we
declare these blocks as syscons and bind to individual registers
in child nodes. Each register controls one SoC device.

The respective apple compatibles are defined in case device-specific
quirks are necessary in the future, but currently these nodes are
expected to be bound by the generic syscon driver.

Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Signed-off-by: Hector Martin <marcan@marcan.st>
---
 .../bindings/arm/apple/apple,pmgr.yaml        | 134 ++++++++++++++++++
 1 file changed, 134 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/arm/apple/apple,pmgr.yaml

diff --git a/Documentation/devicetree/bindings/arm/apple/apple,pmgr.yaml b/Documentation/devicetree/bindings/arm/apple/apple,pmgr.yaml
new file mode 100644
index 000000000000..b6b5d3a912b3
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/apple/apple,pmgr.yaml
@@ -0,0 +1,134 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/arm/apple/apple,pmgr.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Apple SoC Power Manager (PMGR)
+
+maintainers:
+  - Hector Martin <marcan@marcan.st>
+
+description: |
+  Apple SoCs include PMGR blocks responsible for power management,
+  which can control various clocks, resets, power states, and
+  performance features. This node represents the PMGR as a syscon,
+  with sub-nodes representing individual features.
+
+properties:
+  $nodename:
+    pattern: "^power-management@[0-9a-f]+$"
+
+  compatible:
+    items:
+      - enum:
+          - apple,t8103-pmgr
+          - apple,t6000-pmgr
+      - const: apple,pmgr
+      - const: syscon
+      - const: simple-mfd
+
+  reg:
+    maxItems: 1
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 1
+
+patternProperties:
+  "power-controller@[0-9a-f]+$":
+    description:
+      The individual power management domains within this controller
+    type: object
+    $ref: /power/apple,pmgr-pwrstate.yaml#
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+    soc {
+        #address-cells = <2>;
+        #size-cells = <2>;
+
+        power-management@23b700000 {
+            compatible = "apple,t8103-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+            #address-cells = <1>;
+            #size-cells = <1>;
+            reg = <0x2 0x3b700000 0x0 0x14000>;
+
+            ps_sio: power-controller@1c0 {
+                compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+                reg = <0x1c0 8>;
+                #power-domain-cells = <0>;
+                #reset-cells = <0>;
+                label = "sio";
+                apple,always-on;
+            };
+
+            ps_uart_p: power-controller@220 {
+                compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+                reg = <0x220 8>;
+                #power-domain-cells = <0>;
+                #reset-cells = <0>;
+                label = "uart_p";
+                power-domains = <&ps_sio>;
+            };
+
+            ps_uart0: power-controller@270 {
+                compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+                reg = <0x270 8>;
+                #power-domain-cells = <0>;
+                #reset-cells = <0>;
+                label = "uart0";
+                power-domains = <&ps_uart_p>;
+            };
+        };
+
+        power-management@23d280000 {
+            compatible = "apple,t8103-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+            #address-cells = <1>;
+            #size-cells = <1>;
+            reg = <0x2 0x3d280000 0x0 0xc000>;
+
+            ps_aop_filter: power-controller@4000 {
+                compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+                reg = <0x4000 8>;
+                #power-domain-cells = <0>;
+                #reset-cells = <0>;
+                label = "aop_filter";
+            };
+
+            ps_aop_base: power-controller@4010 {
+                compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+                reg = <0x4010 8>;
+                #power-domain-cells = <0>;
+                #reset-cells = <0>;
+                label = "aop_base";
+                power-domains = <&ps_aop_filter>;
+            };
+
+            ps_aop_shim: power-controller@4038 {
+                compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+                reg = <0x4038 8>;
+                #power-domain-cells = <0>;
+                #reset-cells = <0>;
+                label = "aop_shim";
+                power-domains = <&ps_aop_base>;
+            };
+
+            ps_aop_uart0: power-controller@4048 {
+                compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+                reg = <0x4048 8>;
+                #power-domain-cells = <0>;
+                #reset-cells = <0>;
+                label = "aop_uart0";
+                power-domains = <&ps_aop_shim>;
+            };
+        };
+    };
-- 
2.34.0


From 2c2183725ef3f156215633d8b116d025e38ea7c4 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Tue, 5 Oct 2021 23:18:12 +0900
Subject: [PATCH 30/83] soc: apple: Add driver for Apple PMGR power state
 controls

Implements genpd and reset providers for downstream devices. Each
instance of the driver binds to a single register and represents a
single SoC power domain.

The driver does not currently implement all features (auto-pm,
clockgate-only state), but we declare the respective registers for
documentation purposes. These features will be added as they become
useful for downstream devices.

This also creates the apple/soc tree and Kconfig submenu.

Acked-by: Linus Walleij <linus.walleij@linaro.org>
Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/soc/apple/Kconfig               |  12 +
 drivers/soc/apple/Makefile              |   1 +
 drivers/soc/apple/apple-pmgr-pwrstate.c | 317 ++++++++++++++++++++++++
 3 files changed, 330 insertions(+)
 create mode 100644 drivers/soc/apple/apple-pmgr-pwrstate.c

diff --git a/drivers/soc/apple/Kconfig b/drivers/soc/apple/Kconfig
index 89bec8919eca..57d2c6e52d10 100644
--- a/drivers/soc/apple/Kconfig
+++ b/drivers/soc/apple/Kconfig
@@ -24,5 +24,17 @@ config APPLE_SART
 
 	  Say 'y' here if you have an Apple SoC.
 
+config APPLE_PMGR_PWRSTATE
+	tristate "Apple SoC PMGR power state control"
+	select REGMAP
+	select MFD_SYSCON
+	select PM_GENERIC_DOMAINS
+	select RESET_CONTROLLER
+	default ARCH_APPLE
+	help
+	  The PMGR block in Apple SoCs provides high-level power state
+	  controls for SoC devices. This driver manages them through the
+	  generic power domain framework, and also provides reset support.
+
 endmenu
 endif
diff --git a/drivers/soc/apple/Makefile b/drivers/soc/apple/Makefile
index 68d562898f32..2255670dee32 100644
--- a/drivers/soc/apple/Makefile
+++ b/drivers/soc/apple/Makefile
@@ -2,3 +2,4 @@
 
 obj-$(CONFIG_APPLE_RTKIT) += apple-rtkit.o
 obj-$(CONFIG_APPLE_SART) += apple-sart.o
+obj-$(CONFIG_APPLE_PMGR_PWRSTATE) += apple-pmgr-pwrstate.o
diff --git a/drivers/soc/apple/apple-pmgr-pwrstate.c b/drivers/soc/apple/apple-pmgr-pwrstate.c
new file mode 100644
index 000000000000..507500494b98
--- /dev/null
+++ b/drivers/soc/apple/apple-pmgr-pwrstate.c
@@ -0,0 +1,317 @@
+// SPDX-License-Identifier: GPL-2.0-only OR MIT
+/*
+ * Apple SoC PMGR device power state driver
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+#include <linux/bitops.h>
+#include <linux/bitfield.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/reset-controller.h>
+#include <linux/module.h>
+
+#define APPLE_PMGR_RESET        BIT(31)
+#define APPLE_PMGR_AUTO_ENABLE  BIT(28)
+#define APPLE_PMGR_PS_AUTO      GENMASK(27, 24)
+#define APPLE_PMGR_PARENT_OFF   BIT(11)
+#define APPLE_PMGR_DEV_DISABLE  BIT(10)
+#define APPLE_PMGR_WAS_CLKGATED BIT(9)
+#define APPLE_PMGR_WAS_PWRGATED BIT(8)
+#define APPLE_PMGR_PS_ACTUAL    GENMASK(7, 4)
+#define APPLE_PMGR_PS_TARGET    GENMASK(3, 0)
+
+#define APPLE_PMGR_FLAGS        (APPLE_PMGR_WAS_CLKGATED | APPLE_PMGR_WAS_PWRGATED)
+
+#define APPLE_PMGR_PS_ACTIVE    0xf
+#define APPLE_PMGR_PS_CLKGATE   0x4
+#define APPLE_PMGR_PS_PWRGATE   0x0
+
+#define APPLE_PMGR_PS_SET_TIMEOUT 100
+#define APPLE_PMGR_RESET_TIME 1
+
+struct apple_pmgr_ps {
+	struct device *dev;
+	struct generic_pm_domain genpd;
+	struct reset_controller_dev rcdev;
+	struct regmap *regmap;
+	u32 offset;
+};
+
+#define genpd_to_apple_pmgr_ps(_genpd) container_of(_genpd, struct apple_pmgr_ps, genpd)
+#define rcdev_to_apple_pmgr_ps(_rcdev) container_of(_rcdev, struct apple_pmgr_ps, rcdev)
+
+static int apple_pmgr_ps_set(struct generic_pm_domain *genpd, u32 pstate, bool auto_enable)
+{
+	int ret;
+	struct apple_pmgr_ps *ps = genpd_to_apple_pmgr_ps(genpd);
+	u32 reg;
+
+	ret = regmap_read(ps->regmap, ps->offset, &reg);
+	if (ret < 0)
+		return ret;
+
+	/* Resets are synchronous, and only work if the device is powered and clocked. */
+	if (reg & APPLE_PMGR_RESET && pstate != APPLE_PMGR_PS_ACTIVE)
+		dev_err(ps->dev, "PS %s: powering off with RESET active\n",
+			genpd->name);
+
+	reg &= ~(APPLE_PMGR_AUTO_ENABLE | APPLE_PMGR_FLAGS | APPLE_PMGR_PS_TARGET);
+	reg |= FIELD_PREP(APPLE_PMGR_PS_TARGET, pstate);
+
+	dev_dbg(ps->dev, "PS %s: pwrstate = 0x%x: 0x%x\n", genpd->name, pstate, reg);
+
+	regmap_write(ps->regmap, ps->offset, reg);
+
+	ret = regmap_read_poll_timeout_atomic(
+		ps->regmap, ps->offset, reg,
+		(FIELD_GET(APPLE_PMGR_PS_ACTUAL, reg) == pstate), 1,
+		APPLE_PMGR_PS_SET_TIMEOUT);
+	if (ret < 0)
+		dev_err(ps->dev, "PS %s: Failed to reach power state 0x%x (now: 0x%x)\n",
+			genpd->name, pstate, reg);
+
+	if (auto_enable) {
+		/* Not all devices implement this; this is a no-op where not implemented. */
+		reg &= APPLE_PMGR_FLAGS;
+		reg |= APPLE_PMGR_AUTO_ENABLE;
+		regmap_write(ps->regmap, ps->offset, reg);
+	}
+
+	return ret;
+}
+
+static bool apple_pmgr_ps_is_active(struct apple_pmgr_ps *ps)
+{
+	u32 reg = 0;
+
+	regmap_read(ps->regmap, ps->offset, &reg);
+	/*
+	 * We consider domains as active if they are actually on, or if they have auto-PM
+	 * enabled and the intended target is on.
+	 */
+	return (FIELD_GET(APPLE_PMGR_PS_ACTUAL, reg) == APPLE_PMGR_PS_ACTIVE ||
+		(FIELD_GET(APPLE_PMGR_PS_TARGET, reg) == APPLE_PMGR_PS_ACTIVE &&
+		 reg & APPLE_PMGR_AUTO_ENABLE));
+}
+
+static int apple_pmgr_ps_power_on(struct generic_pm_domain *genpd)
+{
+	return apple_pmgr_ps_set(genpd, APPLE_PMGR_PS_ACTIVE, true);
+}
+
+static int apple_pmgr_ps_power_off(struct generic_pm_domain *genpd)
+{
+	return apple_pmgr_ps_set(genpd, APPLE_PMGR_PS_PWRGATE, false);
+}
+
+static int apple_pmgr_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct apple_pmgr_ps *ps = rcdev_to_apple_pmgr_ps(rcdev);
+
+	mutex_lock(&ps->genpd.mlock);
+
+	if (ps->genpd.status == GENPD_STATE_OFF)
+		dev_err(ps->dev, "PS 0x%x: asserting RESET while powered down\n", ps->offset);
+
+	dev_dbg(ps->dev, "PS 0x%x: assert reset\n", ps->offset);
+	/* Quiesce device before asserting reset */
+	regmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_DEV_DISABLE,
+			   APPLE_PMGR_DEV_DISABLE);
+	regmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_RESET,
+			   APPLE_PMGR_RESET);
+
+	mutex_unlock(&ps->genpd.mlock);
+
+	return 0;
+}
+
+static int apple_pmgr_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct apple_pmgr_ps *ps = rcdev_to_apple_pmgr_ps(rcdev);
+
+	mutex_lock(&ps->genpd.mlock);
+
+	dev_dbg(ps->dev, "PS 0x%x: deassert reset\n", ps->offset);
+	regmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_RESET, 0);
+	regmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_DEV_DISABLE, 0);
+
+	if (ps->genpd.status == GENPD_STATE_OFF)
+		dev_err(ps->dev, "PS 0x%x: RESET was deasserted while powered down\n", ps->offset);
+
+	mutex_unlock(&ps->genpd.mlock);
+
+	return 0;
+}
+
+static int apple_pmgr_reset_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	int ret;
+
+	ret = apple_pmgr_reset_assert(rcdev, id);
+	if (ret)
+		return ret;
+
+	usleep_range(APPLE_PMGR_RESET_TIME, 2 * APPLE_PMGR_RESET_TIME);
+
+	return apple_pmgr_reset_deassert(rcdev, id);
+}
+
+static int apple_pmgr_reset_status(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct apple_pmgr_ps *ps = rcdev_to_apple_pmgr_ps(rcdev);
+	u32 reg = 0;
+
+	regmap_read(ps->regmap, ps->offset, &reg);
+
+	return !!(reg & APPLE_PMGR_RESET);
+}
+
+const struct reset_control_ops apple_pmgr_reset_ops = {
+	.assert		= apple_pmgr_reset_assert,
+	.deassert	= apple_pmgr_reset_deassert,
+	.reset		= apple_pmgr_reset_reset,
+	.status		= apple_pmgr_reset_status,
+};
+
+static int apple_pmgr_reset_xlate(struct reset_controller_dev *rcdev,
+				  const struct of_phandle_args *reset_spec)
+{
+	return 0;
+}
+
+static int apple_pmgr_ps_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct apple_pmgr_ps *ps;
+	struct regmap *regmap;
+	struct of_phandle_iterator it;
+	int ret;
+	const char *name;
+	bool active;
+
+	regmap = syscon_node_to_regmap(node->parent);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	ps = devm_kzalloc(dev, sizeof(*ps), GFP_KERNEL);
+	if (!ps)
+		return -ENOMEM;
+
+	ps->dev = dev;
+	ps->regmap = regmap;
+
+	ret = of_property_read_string(node, "label", &name);
+	if (ret < 0) {
+		dev_err(dev, "missing label property\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "reg", &ps->offset);
+	if (ret < 0) {
+		dev_err(dev, "missing reg property\n");
+		return ret;
+	}
+
+	ps->genpd.name = name;
+	ps->genpd.power_on = apple_pmgr_ps_power_on;
+	ps->genpd.power_off = apple_pmgr_ps_power_off;
+
+	active = apple_pmgr_ps_is_active(ps);
+	if (of_property_read_bool(node, "apple,always-on")) {
+		ps->genpd.flags |= GENPD_FLAG_ALWAYS_ON;
+		if (!active) {
+			dev_warn(dev, "always-on domain %s is not on at boot\n", name);
+			/* Turn it on so pm_genpd_init does not fail */
+			active = apple_pmgr_ps_power_on(&ps->genpd) == 0;
+		}
+	}
+
+	/* Turn on auto-PM if the domain is already on */
+	if (active)
+		regmap_update_bits(regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_AUTO_ENABLE,
+				   APPLE_PMGR_AUTO_ENABLE);
+
+	ret = pm_genpd_init(&ps->genpd, NULL, !active);
+	if (ret < 0) {
+		dev_err(dev, "pm_genpd_init failed\n");
+		return ret;
+	}
+
+	ret = of_genpd_add_provider_simple(node, &ps->genpd);
+	if (ret < 0) {
+		dev_err(dev, "of_genpd_add_provider_simple failed\n");
+		return ret;
+	}
+
+	of_for_each_phandle(&it, ret, node, "power-domains", "#power-domain-cells", -1) {
+		struct of_phandle_args parent, child;
+
+		parent.np = it.node;
+		parent.args_count = of_phandle_iterator_args(&it, parent.args, MAX_PHANDLE_ARGS);
+		child.np = node;
+		child.args_count = 0;
+		ret = of_genpd_add_subdomain(&parent, &child);
+
+		if (ret == -EPROBE_DEFER) {
+			of_node_put(parent.np);
+			goto err_remove;
+		} else if (ret < 0) {
+			dev_err(dev, "failed to add to parent domain: %d (%s -> %s)\n",
+				ret, it.node->name, node->name);
+			of_node_put(parent.np);
+			goto err_remove;
+		}
+	}
+
+	/*
+	 * Do not participate in regular PM; parent power domains are handled via the
+	 * genpd hierarchy.
+	 */
+	pm_genpd_remove_device(dev);
+
+	ps->rcdev.owner = THIS_MODULE;
+	ps->rcdev.nr_resets = 1;
+	ps->rcdev.ops = &apple_pmgr_reset_ops;
+	ps->rcdev.of_node = dev->of_node;
+	ps->rcdev.of_reset_n_cells = 0;
+	ps->rcdev.of_xlate = apple_pmgr_reset_xlate;
+
+	ret = devm_reset_controller_register(dev, &ps->rcdev);
+	if (ret < 0)
+		goto err_remove;
+
+	return 0;
+err_remove:
+	of_genpd_del_provider(node);
+	pm_genpd_remove(&ps->genpd);
+	return ret;
+}
+
+static const struct of_device_id apple_pmgr_ps_of_match[] = {
+	{ .compatible = "apple,pmgr-pwrstate" },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, apple_pmgr_ps_of_match);
+
+static struct platform_driver apple_pmgr_ps_driver = {
+	.probe = apple_pmgr_ps_probe,
+	.driver = {
+		.name = "apple-pmgr-pwrstate",
+		.of_match_table = apple_pmgr_ps_of_match,
+	},
+};
+
+MODULE_AUTHOR("Hector Martin <marcan@marcan.st>");
+MODULE_DESCRIPTION("PMGR power state driver for Apple SoCs");
+MODULE_LICENSE("GPL v2");
+
+module_platform_driver(apple_pmgr_ps_driver);
-- 
2.34.0


From bafd29dc3e3e053ae6ae19a47c85d1041fa84e35 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Tue, 5 Oct 2021 23:24:21 +0900
Subject: [PATCH 31/83] arm64: dts: apple: t8103: Rename clk24 to clkref

We now know that this frequency comes from the external reference
oscillator and is used for various SoC blocks, and isn't just a random
24MHz clock, so let's call it something more appropriate.

Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Signed-off-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/t8103.dtsi | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index ea1b90fbf31a..029ea9ac7712 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -96,11 +96,11 @@ timer {
 			     <AIC_FIQ AIC_TMR_HV_VIRT IRQ_TYPE_LEVEL_HIGH>;
 	};
 
-	clk24: clock-24m {
+	clkref: clock-ref {
 		compatible = "fixed-clock";
 		#clock-cells = <0>;
 		clock-frequency = <24000000>;
-		clock-output-names = "clk24";
+		clock-output-names = "clkref";
 	};
 
 	soc {
@@ -121,7 +121,7 @@ serial0: serial@235200000 {
 			 * TODO: figure out the clocking properly, there may
 			 * be a third selectable clock.
 			 */
-			clocks = <&clk24>, <&clk24>;
+			clocks = <&clkref>, <&clkref>;
 			clock-names = "uart", "clk_uart_baud0";
 			status = "disabled";
 		};
-- 
2.34.0


From 625dbc5087fe80d0703ab83a7f8632f052632065 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Tue, 5 Oct 2021 23:59:30 +0900
Subject: [PATCH 32/83] arm64: dts: apple: t8103: Add PMGR nodes

This adds the two PMGR nodes and all known power state subnodes. Since
there are a large number of them, let's put them in a separate file to
include.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/t8103-pmgr.dtsi | 1136 +++++++++++++++++++++
 arch/arm64/boot/dts/apple/t8103.dtsi      |   27 +
 2 files changed, 1163 insertions(+)
 create mode 100644 arch/arm64/boot/dts/apple/t8103-pmgr.dtsi

diff --git a/arch/arm64/boot/dts/apple/t8103-pmgr.dtsi b/arch/arm64/boot/dts/apple/t8103-pmgr.dtsi
new file mode 100644
index 000000000000..1310be74df1d
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t8103-pmgr.dtsi
@@ -0,0 +1,1136 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * PMGR Power domains for the Apple T8103 "M1" SoC
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+
+&pmgr {
+	ps_sbr: power-controller@100 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x100 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sbr";
+		apple,always-on; /* Core device */
+	};
+
+	ps_aic: power-controller@108 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x108 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "aic";
+		apple,always-on; /* Core device */
+	};
+
+	ps_dwi: power-controller@110 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x110 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dwi";
+		apple,always-on; /* Core device */
+	};
+
+	ps_soc_spmi0: power-controller@118 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x118 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "soc_spmi0";
+	};
+
+	ps_soc_spmi1: power-controller@120 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x120 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "soc_spmi1";
+	};
+
+	ps_soc_spmi2: power-controller@128 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x128 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "soc_spmi2";
+	};
+
+	ps_gpio: power-controller@130 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x130 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "gpio";
+	};
+
+	ps_pms_busif: power-controller@138 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x138 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_busif";
+		apple,always-on; /* Core device */
+	};
+
+	ps_pms: power-controller@140 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x140 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms";
+		apple,always-on; /* Core device */
+	};
+
+	ps_pms_fpwm0: power-controller@148 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x148 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_fpwm0";
+		power-domains = <&ps_pms>;
+	};
+
+	ps_pms_fpwm1: power-controller@150 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x150 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_fpwm1";
+		power-domains = <&ps_pms>;
+	};
+
+	ps_pms_fpwm2: power-controller@158 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x158 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_fpwm2";
+		power-domains = <&ps_pms>;
+	};
+
+	ps_pms_fpwm3: power-controller@160 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x160 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_fpwm3";
+		power-domains = <&ps_pms>;
+	};
+
+	ps_pms_fpwm4: power-controller@168 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x168 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_fpwm4";
+		power-domains = <&ps_pms>;
+	};
+
+	ps_soc_dpe: power-controller@170 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x170 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "soc_dpe";
+		apple,always-on; /* Core device */
+	};
+
+	ps_pmgr_soc_ocla: power-controller@178 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x178 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pmgr_soc_ocla";
+	};
+
+	ps_ispsens0: power-controller@180 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x180 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens0";
+	};
+
+	ps_ispsens1: power-controller@188 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x188 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens1";
+	};
+
+	ps_ispsens2: power-controller@190 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x190 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens2";
+	};
+
+	ps_ispsens3: power-controller@198 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x198 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens3";
+	};
+
+	ps_pcie_ref: power-controller@1a0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pcie_ref";
+	};
+
+	ps_aft0: power-controller@1a8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "aft0";
+	};
+
+	ps_devc0_ivdmc: power-controller@1b0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "devc0_ivdmc";
+	};
+
+	ps_imx: power-controller@1b8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "imx";
+		apple,always-on; /* Apple fabric, critical block */
+	};
+
+	ps_sio_busif: power-controller@1c0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_busif";
+	};
+
+	ps_sio: power-controller@1c8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio";
+		power-domains = <&ps_sio_busif>;
+	};
+
+	ps_sio_cpu: power-controller@1d0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1d0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_cpu";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_fpwm0: power-controller@1d8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1d8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "fpwm0";
+	};
+
+	ps_fpwm1: power-controller@1e0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1e0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "fpwm1";
+	};
+
+	ps_fpwm2: power-controller@1e8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "fpwm2";
+	};
+
+	ps_i2c0: power-controller@1f0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1f0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c0";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c1: power-controller@1f8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1f8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c1";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c2: power-controller@200 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x200 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c2";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c3: power-controller@208 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x208 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c3";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c4: power-controller@210 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x210 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c4";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_spi_p: power-controller@218 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x218 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi_p";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_uart_p: power-controller@220 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x220 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart_p";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_audio_p: power-controller@228 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x228 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "audio_p";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_sio_adma: power-controller@230 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x230 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_adma";
+		power-domains = <&ps_sio>, <&ps_pms>;
+	};
+
+	ps_aes: power-controller@238 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x238 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "aes";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_spi0: power-controller@240 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x240 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi0";
+		power-domains = <&ps_sio>, <&ps_spi_p>;
+	};
+
+	ps_spi1: power-controller@248 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x248 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi1";
+		power-domains = <&ps_sio>, <&ps_spi_p>;
+	};
+
+	ps_spi2: power-controller@250 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x250 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi2";
+		power-domains = <&ps_sio>, <&ps_spi_p>;
+	};
+
+	ps_spi3: power-controller@258 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x258 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi3";
+		power-domains = <&ps_sio>, <&ps_spi_p>;
+	};
+
+	ps_uart_n: power-controller@268 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x268 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart_n";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart0: power-controller@270 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x270 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart0";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart1: power-controller@278 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x278 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart1";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart2: power-controller@280 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x280 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart2";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart3: power-controller@288 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x288 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart3";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart4: power-controller@290 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x290 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart4";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart5: power-controller@298 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x298 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart5";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart6: power-controller@2a0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart6";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart7: power-controller@2a8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart7";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart8: power-controller@2b0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart8";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_mca0: power-controller@2b8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca0";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca1: power-controller@2c0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca1";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca2: power-controller@2c8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca2";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca3: power-controller@2d0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2d0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca3";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca4: power-controller@2d8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2d8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca4";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca5: power-controller@2e0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2e0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca5";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_dpa0: power-controller@2e8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dpa0";
+		power-domains = <&ps_audio_p>;
+	};
+
+	ps_dpa1: power-controller@2f0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2f0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dpa1";
+		power-domains = <&ps_audio_p>;
+	};
+
+	ps_mcc: power-controller@2f8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2f8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mcc";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_spi4: power-controller@260 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x260 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi4";
+		power-domains = <&ps_sio>, <&ps_spi_p>;
+	};
+
+	ps_dcs0: power-controller@300 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x300 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs0";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_dcs1: power-controller@310 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x310 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs1";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_dcs2: power-controller@308 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x308 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs2";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_dcs3: power-controller@318 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x318 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs3";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_smx: power-controller@340 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x340 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "smx";
+		apple,always-on; /* Apple fabric, critical block */
+	};
+
+	ps_apcie: power-controller@348 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x348 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie";
+		power-domains = <&ps_imx>, <&ps_pcie_ref>;
+	};
+
+	ps_rmx: power-controller@350 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x350 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "rmx";
+		/* Apple Fabric, display/image stuff: this can power down */
+	};
+
+	ps_mmx: power-controller@358 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x358 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mmx";
+		/* Apple Fabric, media stuff: this can power down */
+	};
+
+	ps_disp0_fe: power-controller@360 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x360 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "disp0_fe";
+		power-domains = <&ps_rmx>;
+		apple,always-on; /* TODO: figure out if we can enable PM here */
+	};
+
+	ps_dispext_fe: power-controller@368 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x368 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext_fe";
+		power-domains = <&ps_rmx>;
+	};
+
+	ps_dispext_cpu0: power-controller@378 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x378 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext_cpu0";
+		power-domains = <&ps_dispext_fe>;
+	};
+
+	ps_jpg: power-controller@3c0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "jpg";
+		power-domains = <&ps_mmx>;
+	};
+
+	ps_msr: power-controller@3c8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msr";
+		power-domains = <&ps_mmx>;
+	};
+
+	ps_msr_ase_core: power-controller@3d0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3d0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msr_ase_core";
+	};
+
+	ps_pmp: power-controller@3d8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3d8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pmp";
+	};
+
+	ps_pms_sram: power-controller@3e0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3e0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_sram";
+	};
+
+	ps_apcie_gp: power-controller@3e8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie_gp";
+		power-domains = <&ps_apcie>;
+	};
+
+	ps_ans2: power-controller@3f0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3f0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ans2";
+		/*
+		 * The ADT makes ps_apcie_st depend on ps_ans2 instead, but this
+		 * doesn't make much sense since ANS2 uses APCIE_ST.
+		 */
+		power-domains = <&ps_apcie_st>;
+	};
+
+	ps_gfx: power-controller@3f8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3f8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "gfx";
+	};
+
+	ps_dcs4: power-controller@320 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x320 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs4";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_dcs5: power-controller@330 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x330 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs5";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_dcs6: power-controller@328 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x328 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs6";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_dcs7: power-controller@338 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x338 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs7";
+		apple,always-on; /* LPDDR4 interface */
+	};
+
+	ps_dispdfr_fe: power-controller@3a8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispdfr_fe";
+		power-domains = <&ps_rmx>;
+	};
+
+	ps_dispdfr_be: power-controller@3b0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispdfr_be";
+		power-domains = <&ps_dispdfr_fe>;
+	};
+
+	ps_mipi_dsi: power-controller@3b8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mipi_dsi";
+		power-domains = <&ps_dispdfr_be>;
+	};
+
+	ps_isp_sys: power-controller@400 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x400 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "isp_sys";
+		power-domains = <&ps_rmx>;
+	};
+
+	ps_venc_sys: power-controller@408 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x408 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_sys";
+		power-domains = <&ps_mmx>;
+	};
+
+	ps_avd_sys: power-controller@410 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x410 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "avd_sys";
+		power-domains = <&ps_mmx>;
+	};
+
+	ps_apcie_st: power-controller@418 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x418 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie_st";
+		power-domains = <&ps_apcie>;
+	};
+
+	ps_ane_sys: power-controller@470 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x470 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ane_sys";
+	};
+
+	ps_atc0_common: power-controller@420 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x420 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_common";
+	};
+
+	ps_atc0_pcie: power-controller@428 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x428 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_pcie";
+		power-domains = <&ps_atc0_common>;
+	};
+
+	ps_atc0_cio: power-controller@430 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x430 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_cio";
+		power-domains = <&ps_atc0_common>;
+	};
+
+	ps_atc0_cio_pcie: power-controller@438 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x438 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_cio_pcie";
+		power-domains = <&ps_atc0_cio>;
+	};
+
+	ps_atc0_cio_usb: power-controller@440 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x440 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_cio_usb";
+		power-domains = <&ps_atc0_cio>;
+	};
+
+	ps_atc1_common: power-controller@448 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x448 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_common";
+	};
+
+	ps_atc1_pcie: power-controller@450 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x450 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_pcie";
+		power-domains = <&ps_atc1_common>;
+	};
+
+	ps_atc1_cio: power-controller@458 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x458 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_cio";
+		power-domains = <&ps_atc1_common>;
+	};
+
+	ps_atc1_cio_pcie: power-controller@460 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x460 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_cio_pcie";
+		power-domains = <&ps_atc1_cio>;
+	};
+
+	ps_atc1_cio_usb: power-controller@468 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x468 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_cio_usb";
+		power-domains = <&ps_atc1_cio>;
+	};
+
+	ps_sep: power-controller@c00 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xc00 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sep";
+		apple,always-on; /* Locked on */
+	};
+
+	ps_venc_dma: power-controller@8000 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8000 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_dma";
+		power-domains = <&ps_venc_sys>;
+	};
+
+	ps_venc_pipe4: power-controller@8008 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8008 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_pipe4";
+		power-domains = <&ps_venc_dma>;
+	};
+
+	ps_venc_pipe5: power-controller@8010 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8010 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_pipe5";
+		power-domains = <&ps_venc_dma>;
+	};
+
+	ps_venc_me0: power-controller@8018 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8018 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_me0";
+		power-domains = <&ps_venc_pipe4>, <&ps_venc_pipe5>;
+	};
+
+	ps_venc_me1: power-controller@8020 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8020 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_me1";
+		power-domains = <&ps_venc_pipe4>, <&ps_venc_pipe5>;
+	};
+
+	ps_ane_sys_cpu: power-controller@c000 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xc000 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ane_sys_cpu";
+		power-domains = <&ps_ane_sys>;
+	};
+
+	ps_disp0_cpu0: power-controller@10018 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x10018 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "disp0_cpu0";
+		power-domains = <&ps_disp0_fe>;
+		apple,always-on; /* TODO: figure out if we can enable PM here */
+	};
+};
+
+&pmgr_mini {
+	ps_debug: power-controller@58 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x58 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "debug";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_spmi0: power-controller@60 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x60 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_spmi0";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_aon: power-controller@70 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x70 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_aon";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_gpio: power-controller@80 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x80 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_gpio";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_fabric: power-controller@a8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xa8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_fabric";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_sram: power-controller@b0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xb0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_sram";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_debug_usb: power-controller@b8 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xb8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "debug_usb";
+		apple,always-on; /* Core AON device */
+		power-domains = <&ps_debug>;
+	};
+
+	ps_debug_auth: power-controller@c0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xc0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "debug_auth";
+		apple,always-on; /* Core AON device */
+		power-domains = <&ps_debug>;
+	};
+
+	ps_nub_spmi1: power-controller@68 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x68 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_spmi1";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_msg: power-controller@78 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x78 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msg";
+	};
+
+	ps_atc0_usb_aon: power-controller@88 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x88 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_usb_aon";
+	};
+
+	ps_atc1_usb_aon: power-controller@90 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x90 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_usb_aon";
+	};
+
+	ps_atc0_usb: power-controller@98 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x98 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_usb";
+		power-domains = <&ps_atc0_usb_aon>, <&ps_atc0_common>;
+	};
+
+	ps_atc1_usb: power-controller@a0 {
+		compatible = "apple,t8103-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xa0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_usb";
+		power-domains = <&ps_atc1_usb_aon>, <&ps_atc1_common>;
+	};
+};
diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index 029ea9ac7712..58d42b340a05 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -123,6 +123,7 @@ serial0: serial@235200000 {
 			 */
 			clocks = <&clkref>, <&clkref>;
 			clock-names = "uart", "clk_uart_baud0";
+			power-domains = <&ps_uart0>;
 			status = "disabled";
 		};
 
@@ -131,11 +132,20 @@ aic: interrupt-controller@23b100000 {
 			#interrupt-cells = <3>;
 			interrupt-controller;
 			reg = <0x2 0x3b100000 0x0 0x8000>;
+			power-domains = <&ps_aic>;
+		};
+
+		pmgr: power-management@23b700000 {
+			compatible = "apple,t8103-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2 0x3b700000 0 0x14000>;
 		};
 
 		pinctrl_ap: pinctrl@23c100000 {
 			compatible = "apple,t8103-pinctrl", "apple,pinctrl";
 			reg = <0x2 0x3c100000 0x0 0x100000>;
+			power-domains = <&ps_gpio>;
 
 			gpio-controller;
 			#gpio-cells = <2>;
@@ -159,6 +169,13 @@ pcie_pins: pcie-pins {
 			};
 		};
 
+		pmgr_mini: power-management@23d280000 {
+			compatible = "apple,t8103-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2 0x3d280000 0 0x4000>;
+		};
+
 		pinctrl_aop: pinctrl@24a820000 {
 			compatible = "apple,t8103-pinctrl", "apple,pinctrl";
 			reg = <0x2 0x4a820000 0x0 0x4000>;
@@ -182,6 +199,7 @@ pinctrl_aop: pinctrl@24a820000 {
 		pinctrl_nub: pinctrl@23d1f0000 {
 			compatible = "apple,t8103-pinctrl", "apple,pinctrl";
 			reg = <0x2 0x3d1f0000 0x0 0x4000>;
+			power-domains = <&ps_nub_gpio>;
 
 			gpio-controller;
 			#gpio-cells = <2>;
@@ -225,6 +243,7 @@ pcie0_dart_0: dart@681008000 {
 			#iommu-cells = <1>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 696 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_apcie_gp>;
 		};
 
 		pcie0_dart_1: dart@682008000 {
@@ -233,6 +252,7 @@ pcie0_dart_1: dart@682008000 {
 			#iommu-cells = <1>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 699 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_apcie_gp>;
 		};
 
 		pcie0_dart_2: dart@683008000 {
@@ -241,6 +261,7 @@ pcie0_dart_2: dart@683008000 {
 			#iommu-cells = <1>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 702 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_apcie_gp>;
 		};
 
 		pcie0: pcie@690000000 {
@@ -275,6 +296,7 @@ pcie0: pcie@690000000 {
 			ranges = <0x43000000 0x6 0xa0000000 0x6 0xa0000000 0x0 0x20000000>,
 				 <0x02000000 0x0 0xc0000000 0x6 0xc0000000 0x0 0x40000000>;
 
+			power-domains = <&ps_apcie_gp>;
 			pinctrl-0 = <&pcie_pins>;
 			pinctrl-names = "default";
 
@@ -348,12 +370,14 @@ ans: mbox@277408000 {
 				<AIC_IRQ 586 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "send-empty", "send-not-empty",
 				"recv-empty", "recv-not-empty";
+			power-domains = <&ps_ans2>;
 			#mbox-cells = <0>;
 		};
 
 		sart: sart@27bc50000 {
 			compatible = "apple,t8103-sart";
 			reg = <0x2 0x7bc50000 0x0 0x10000>;
+			power-domains = <&ps_ans2>;
 		};
 
 		ans2: nvme@27bcc0000 {
@@ -364,6 +388,9 @@ ans2: nvme@27bcc0000 {
 			interrupts = <AIC_IRQ 590 IRQ_TYPE_LEVEL_HIGH>;
 			mboxes = <&ans>;
 			apple,sart = <&sart>;
+			power-domains = <&ps_ans2>;
 		 };
 	};
 };
+
+#include "t8103-pmgr.dtsi"
-- 
2.34.0


From 3b85c132d3e70332c21c7d55afd2d9dd01c824dc Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Mon, 20 Sep 2021 02:23:11 +0900
Subject: [PATCH 33/83] tty: serial: samsung_tty: Support runtime PM

This allows idle UART devices to be suspended using the standard
runtime-PM framework. The logic is modeled after stm32-usart.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/tty/serial/samsung_tty.c | 93 ++++++++++++++++++++------------
 1 file changed, 59 insertions(+), 34 deletions(-)

diff --git a/drivers/tty/serial/samsung_tty.c b/drivers/tty/serial/samsung_tty.c
index ca084c10d0bb..75c87d7240d9 100644
--- a/drivers/tty/serial/samsung_tty.c
+++ b/drivers/tty/serial/samsung_tty.c
@@ -40,6 +40,7 @@
 #include <linux/clk.h>
 #include <linux/cpufreq.h>
 #include <linux/of.h>
+#include <linux/pm_runtime.h>
 #include <asm/irq.h>
 
 /* UART name and device definitions */
@@ -1381,31 +1382,49 @@ static void exynos_usi_init(struct uart_port *port)
 
 /* power power management control */
 
-static void s3c24xx_serial_pm(struct uart_port *port, unsigned int level,
-			      unsigned int old)
+static int __maybe_unused s3c24xx_serial_runtime_suspend(struct device *dev)
 {
+	struct uart_port *port = dev_get_drvdata(dev);
 	struct s3c24xx_uart_port *ourport = to_ourport(port);
 	int timeout = 10000;
 
-	ourport->pm_level = level;
+	while (--timeout && !s3c24xx_serial_txempty_nofifo(port))
+		udelay(100);
 
-	switch (level) {
-	case 3:
-		while (--timeout && !s3c24xx_serial_txempty_nofifo(port))
-			udelay(100);
+	if (!IS_ERR(ourport->baudclk))
+		clk_disable_unprepare(ourport->baudclk);
 
-		if (!IS_ERR(ourport->baudclk))
-			clk_disable_unprepare(ourport->baudclk);
+	clk_disable_unprepare(ourport->clk);
+	return 0;
+};
 
-		clk_disable_unprepare(ourport->clk);
-		break;
+static int __maybe_unused s3c24xx_serial_runtime_resume(struct device *dev)
+{
+	struct uart_port *port = dev_get_drvdata(dev);
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
 
-	case 0:
-		clk_prepare_enable(ourport->clk);
+	clk_prepare_enable(ourport->clk);
 
-		if (!IS_ERR(ourport->baudclk))
-			clk_prepare_enable(ourport->baudclk);
+	if (!IS_ERR(ourport->baudclk))
+		clk_prepare_enable(ourport->baudclk);
+	return 0;
+};
 
+static void s3c24xx_serial_pm(struct uart_port *port, unsigned int level,
+			      unsigned int old)
+{
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
+
+	ourport->pm_level = level;
+
+	switch (level) {
+	case UART_PM_STATE_OFF:
+		pm_runtime_mark_last_busy(port->dev);
+		pm_runtime_put_sync(port->dev);
+		break;
+
+	case UART_PM_STATE_ON:
+		pm_runtime_get_sync(port->dev);
 		exynos_usi_init(port);
 		break;
 	default:
@@ -2282,18 +2301,15 @@ static int s3c24xx_serial_probe(struct platform_device *pdev)
 		}
 	}
 
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
 	dev_dbg(&pdev->dev, "%s: adding port\n", __func__);
 	uart_add_one_port(&s3c24xx_uart_drv, &ourport->port);
 	platform_set_drvdata(pdev, &ourport->port);
 
-	/*
-	 * Deactivate the clock enabled in s3c24xx_serial_init_port here,
-	 * so that a potential re-enablement through the pm-callback overlaps
-	 * and keeps the clock enabled in this case.
-	 */
-	clk_disable_unprepare(ourport->clk);
-	if (!IS_ERR(ourport->baudclk))
-		clk_disable_unprepare(ourport->baudclk);
+	pm_runtime_put_sync(&pdev->dev);
 
 	ret = s3c24xx_serial_cpufreq_register(ourport);
 	if (ret < 0)
@@ -2307,10 +2323,21 @@ static int s3c24xx_serial_probe(struct platform_device *pdev)
 static int s3c24xx_serial_remove(struct platform_device *dev)
 {
 	struct uart_port *port = s3c24xx_dev_to_port(&dev->dev);
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
 
 	if (port) {
+		pm_runtime_get_sync(&dev->dev);
+
 		s3c24xx_serial_cpufreq_deregister(to_ourport(port));
 		uart_remove_one_port(&s3c24xx_uart_drv, port);
+
+		clk_disable_unprepare(ourport->clk);
+		if (!IS_ERR(ourport->baudclk))
+			clk_disable_unprepare(ourport->baudclk);
+
+		pm_runtime_disable(&dev->dev);
+		pm_runtime_set_suspended(&dev->dev);
+		pm_runtime_put_noidle(&dev->dev);
 	}
 
 	uart_unregister_driver(&s3c24xx_uart_drv);
@@ -2319,8 +2346,8 @@ static int s3c24xx_serial_remove(struct platform_device *dev)
 }
 
 /* UART power management code */
-#ifdef CONFIG_PM_SLEEP
-static int s3c24xx_serial_suspend(struct device *dev)
+
+static int __maybe_unused s3c24xx_serial_suspend(struct device *dev)
 {
 	struct uart_port *port = s3c24xx_dev_to_port(dev);
 
@@ -2330,7 +2357,7 @@ static int s3c24xx_serial_suspend(struct device *dev)
 	return 0;
 }
 
-static int s3c24xx_serial_resume(struct device *dev)
+static int __maybe_unused s3c24xx_serial_resume(struct device *dev)
 {
 	struct uart_port *port = s3c24xx_dev_to_port(dev);
 	struct s3c24xx_uart_port *ourport = to_ourport(port);
@@ -2350,7 +2377,7 @@ static int s3c24xx_serial_resume(struct device *dev)
 	return 0;
 }
 
-static int s3c24xx_serial_resume_noirq(struct device *dev)
+static int __maybe_unused s3c24xx_serial_resume_noirq(struct device *dev)
 {
 	struct uart_port *port = s3c24xx_dev_to_port(dev);
 	struct s3c24xx_uart_port *ourport = to_ourport(port);
@@ -2420,16 +2447,14 @@ static int s3c24xx_serial_resume_noirq(struct device *dev)
 }
 
 static const struct dev_pm_ops s3c24xx_serial_pm_ops = {
+#ifdef CONFIG_PM_SLEEP
 	.suspend = s3c24xx_serial_suspend,
 	.resume = s3c24xx_serial_resume,
 	.resume_noirq = s3c24xx_serial_resume_noirq,
+#endif
+	SET_RUNTIME_PM_OPS(s3c24xx_serial_runtime_suspend,
+			   s3c24xx_serial_runtime_resume, NULL)
 };
-#define SERIAL_SAMSUNG_PM_OPS	(&s3c24xx_serial_pm_ops)
-
-#else /* !CONFIG_PM_SLEEP */
-
-#define SERIAL_SAMSUNG_PM_OPS	NULL
-#endif /* CONFIG_PM_SLEEP */
 
 /* Console code */
 
@@ -2921,7 +2946,7 @@ static struct platform_driver samsung_serial_driver = {
 	.id_table	= s3c24xx_serial_driver_ids,
 	.driver		= {
 		.name	= "samsung-uart",
-		.pm	= SERIAL_SAMSUNG_PM_OPS,
+		.pm	= &s3c24xx_serial_pm_ops,
 		.of_match_table	= of_match_ptr(s3c24xx_uart_dt_match),
 	},
 };
-- 
2.34.0


From 2cb1164b88da6c11ee3b19e25fbc2d22b3f5592e Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Mon, 20 Sep 2021 02:28:20 +0900
Subject: [PATCH 34/83] arm64: dts: apple: t8103: Add UART2

This UART is connected to the debug port of the WLAN module. It is
mostly useless, but makes for a good test case for runtime-pm without
having to unbind the console from the main system UART.

Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Signed-off-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/t8103-j274.dts |  5 +++++
 arch/arm64/boot/dts/apple/t8103.dtsi     | 12 ++++++++++++
 2 files changed, 17 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t8103-j274.dts b/arch/arm64/boot/dts/apple/t8103-j274.dts
index 33a80f9501dc..86ea1b0a6cc8 100644
--- a/arch/arm64/boot/dts/apple/t8103-j274.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j274.dts
@@ -17,6 +17,7 @@ / {
 
 	aliases {
 		serial0 = &serial0;
+		serial2 = &serial2;
 		ethernet0 = &ethernet0;
 	};
 
@@ -45,6 +46,10 @@ &serial0 {
 	status = "okay";
 };
 
+&serial2 {
+	status = "okay";
+};
+
 /*
  * Force the bus number assignments so that we can declare some of the
  * on-board devices and properties that are populated by the bootloader
diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index 58d42b340a05..a07c7d4d3e5d 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -127,6 +127,18 @@ serial0: serial@235200000 {
 			status = "disabled";
 		};
 
+		serial2: serial@235208000 {
+			compatible = "apple,s5l-uart";
+			reg = <0x2 0x35208000 0x0 0x1000>;
+			reg-io-width = <4>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 607 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkref>, <&clkref>;
+			clock-names = "uart", "clk_uart_baud0";
+			power-domains = <&ps_uart2>;
+			status = "disabled";
+		};
+
 		aic: interrupt-controller@23b100000 {
 			compatible = "apple,t8103-aic", "apple,aic";
 			#interrupt-cells = <3>;
-- 
2.34.0


From 51a24d58e2db1c8e11c112a0f94a407befd88de1 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Sun, 21 Nov 2021 21:04:00 +0900
Subject: [PATCH 35/83] arm64: dts: apple: t600x: Add PMGR nodes

t6000 is like t6001, but lacks one entire PMGR node and all of its
domains.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/t6000.dtsi      |    2 +
 arch/arm64/boot/dts/apple/t6001-pmgr.dtsi | 2004 +++++++++++++++++++++
 arch/arm64/boot/dts/apple/t6001.dtsi      |   54 +
 3 files changed, 2060 insertions(+)
 create mode 100644 arch/arm64/boot/dts/apple/t6001-pmgr.dtsi

diff --git a/arch/arm64/boot/dts/apple/t6000.dtsi b/arch/arm64/boot/dts/apple/t6000.dtsi
index e7ca4e88c060..89c3b211b116 100644
--- a/arch/arm64/boot/dts/apple/t6000.dtsi
+++ b/arch/arm64/boot/dts/apple/t6000.dtsi
@@ -14,3 +14,5 @@
 / {
 	compatible = "apple,t6000", "apple,arm-platform";
 };
+
+/delete-node/ &pmgr_south;
diff --git a/arch/arm64/boot/dts/apple/t6001-pmgr.dtsi b/arch/arm64/boot/dts/apple/t6001-pmgr.dtsi
new file mode 100644
index 000000000000..a332f43fef88
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t6001-pmgr.dtsi
@@ -0,0 +1,2004 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * PMGR Power domains for the Apple T6001 "M1 Max" SoC
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+&pmgr {
+	ps_pms_bridge: power-controller@100 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x100 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_bridge";
+		apple,always-on; /* Core device */
+	};
+
+	ps_aic: power-controller@108 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x108 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "aic";
+		apple,always-on; /* Core device */
+	};
+
+	ps_dwi: power-controller@110 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x110 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dwi";
+		apple,always-on; /* Core device */
+	};
+
+	ps_pms: power-controller@118 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x118 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms";
+		apple,always-on; /* Core device */
+	};
+
+	ps_gpio: power-controller@120 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x120 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "gpio";
+		power-domains = <&ps_pms>, <&ps_sio>;
+	};
+
+	ps_soc_dpe: power-controller@128 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x128 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "soc_dpe";
+		apple,always-on; /* Core device */
+	};
+
+	ps_pmgr_soc_ocla: power-controller@130 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x130 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pmgr_soc_ocla";
+		power-domains = <&ps_pms>;
+	};
+
+	ps_pcie0_ref: power-controller@138 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x138 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pcie0_ref";
+	};
+
+	ps_pcie1_ref: power-controller@140 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x140 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pcie1_ref";
+	};
+
+	ps_apcie_st: power-controller@148 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x148 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie_st";
+		power-domains = <&ps_pcie1_ref>;
+	};
+
+	ps_apcie_gp: power-controller@150 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x150 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie_gp";
+		power-domains = <&ps_pcie0_ref>;
+	};
+
+	ps_devc0_ivdmc: power-controller@180 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x180 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "devc0_ivdmc";
+	};
+
+	ps_amcc0: power-controller@188 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x188 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc0";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_amcc2: power-controller@190 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x190 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc2";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_dcs_00: power-controller@198 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x198 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_00";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_01: power-controller@1a0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_01";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_02: power-controller@1a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_02";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_03: power-controller@1b0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_03";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_08: power-controller@1b8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_08";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_09: power-controller@1c0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_09";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_10: power-controller@1c8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_10";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_11: power-controller@1d0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1d0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_11";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_afi: power-controller@1d8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1d8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afi";
+		apple,always-on; /* Apple Fabric, CPU inteface is here */
+	};
+
+	ps_afc: power-controller@1e0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1e0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afc";
+		apple,always-on; /* Apple Fabric, CPU inteface is here */
+	};
+
+	ps_afr: power-controller@1e8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afr";
+		/* Apple Fabric, media stuff: this can power down */
+	};
+
+	ps_afnc1_ioa: power-controller@1f0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1f0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc1_ioa";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afi>;
+	};
+
+	ps_afnc0_ioa: power-controller@1f8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1f8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc0_ioa";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afi>;
+	};
+
+	ps_afnc1_ls: power-controller@200 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x200 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc1_ls";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc1_ioa>;
+	};
+
+	ps_afnc0_ls: power-controller@208 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x208 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc0_ls";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc0_ioa>;
+	};
+
+	ps_afnc1_lw0: power-controller@210 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x210 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc1_lw0";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc1_ls>;
+	};
+
+	ps_afnc1_lw1: power-controller@218 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x218 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc1_lw1";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc1_ls>;
+	};
+
+	ps_afnc1_lw2: power-controller@220 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x220 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc1_lw2";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc1_ls>;
+	};
+
+	ps_afnc0_lw0: power-controller@228 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x228 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc0_lw0";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc0_ls>;
+	};
+
+	ps_scodec: power-controller@230 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x230 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "scodec";
+		power-domains = <&ps_afnc1_lw0>;
+	};
+
+	ps_atc0_common: power-controller@238 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x238 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_common";
+		power-domains = <&ps_afnc1_lw1>;
+	};
+
+	ps_atc1_common: power-controller@240 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x240 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_common";
+		power-domains = <&ps_afnc1_lw1>;
+	};
+
+	ps_c0_usb31drd: power-controller@248 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x248 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "c0_usb31drd";
+		power-domains = <&ps_usb>;
+	};
+
+	ps_c1_usb31drd: power-controller@250 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x250 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "c1_usb31drd";
+		power-domains = <&ps_usb>;
+	};
+
+	ps_dispext0_fe: power-controller@258 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x258 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext0_fe";
+		power-domains = <&ps_afi>;
+	};
+
+	ps_dispext1_fe: power-controller@260 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x260 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext1_fe";
+		power-domains = <&ps_afi>;
+	};
+
+	ps_ane_sys: power-controller@268 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x268 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ane_sys";
+		power-domains = <&ps_afr>;
+	};
+
+	ps_avd_sys: power-controller@270 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x270 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "avd_sys";
+		power-domains = <&ps_afr>;
+	};
+
+	ps_dispext0_cpu0: power-controller@280 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x280 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext0_cpu0";
+		power-domains = <&ps_dispext0_fe>;
+	};
+
+	ps_dispext1_cpu0: power-controller@2a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext1_cpu0";
+		power-domains = <&ps_dispext1_fe>;
+	};
+
+	ps_ane_sys_cpu: power-controller@2c8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ane_sys_cpu";
+		power-domains = <&ps_ane_sys>;
+	};
+
+	ps_pmp: power-controller@2d8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2d8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pmp";
+	};
+
+	ps_pms_sram: power-controller@2e0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2e0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "pms_sram";
+	};
+
+	ps_apcie_st_sys: power-controller@2e8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie_st_sys";
+		power-domains = <&ps_apcie_st>;
+	};
+
+	ps_apcie_st1_sys: power-controller@2f0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2f0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie_st1_sys";
+		power-domains = <&ps_apcie_st>;
+	};
+
+	ps_atc2_common: power-controller@2f8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2f8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc2_common";
+		power-domains = <&ps_afnc1_lw1>;
+	};
+
+	ps_atc3_common: power-controller@300 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x300 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc3_common";
+		power-domains = <&ps_afnc1_lw1>;
+	};
+
+	ps_usb: power-controller@318 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x318 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "usb";
+		power-domains = <&ps_afnc1_lw2>;
+	};
+
+	ps_apcie_gp_sys: power-controller@320 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x320 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "apcie_gp_sys";
+		power-domains = <&ps_afnc1_lw2>, <&ps_apcie_gp>;
+	};
+
+	ps_atc0_cio: power-controller@328 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x328 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_cio";
+		power-domains = <&ps_atc0_common>;
+	};
+
+	ps_atc0_pcie: power-controller@330 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x330 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_pcie";
+		power-domains = <&ps_atc0_common>;
+	};
+
+	ps_atc1_cio: power-controller@338 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x338 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_cio";
+		power-domains = <&ps_atc1_common>;
+	};
+
+	ps_atc1_pcie: power-controller@340 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x340 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_pcie";
+		power-domains = <&ps_atc1_common>;
+	};
+
+	ps_atc2_cio: power-controller@348 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x348 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc2_cio";
+		power-domains = <&ps_atc2_common>;
+	};
+
+	ps_atc2_pcie: power-controller@350 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x350 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc2_pcie";
+		power-domains = <&ps_atc2_common>;
+	};
+
+	ps_atc3_cio: power-controller@358 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x358 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc3_cio";
+		power-domains = <&ps_atc3_common>;
+	};
+
+	ps_atc3_pcie: power-controller@360 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x360 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc3_pcie";
+		power-domains = <&ps_atc3_common>;
+	};
+
+	ps_c0_usbctl: power-controller@368 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x368 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "c0_usbctl";
+		power-domains = <&ps_usb>;
+	};
+
+	ps_c1_usbctl: power-controller@370 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x370 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "c1_usbctl";
+		power-domains = <&ps_usb>;
+	};
+
+	ps_atc0_cio_pcie: power-controller@378 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x378 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_cio_pcie";
+		power-domains = <&ps_atc0_cio>;
+	};
+
+	ps_atc0_cio_usb: power-controller@380 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x380 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_cio_usb";
+		power-domains = <&ps_atc0_cio>;
+	};
+
+	ps_atc1_cio_pcie: power-controller@388 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x388 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_cio_pcie";
+		power-domains = <&ps_atc1_cio>;
+	};
+
+	ps_atc1_cio_usb: power-controller@390 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x390 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_cio_usb";
+		power-domains = <&ps_atc1_cio>;
+	};
+
+	ps_atc2_cio_pcie: power-controller@398 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x398 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc2_cio_pcie";
+		power-domains = <&ps_atc2_cio>;
+	};
+
+	ps_atc2_cio_usb: power-controller@3a0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc2_cio_usb";
+		power-domains = <&ps_atc2_cio>;
+	};
+
+	ps_atc3_cio_pcie: power-controller@3a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc3_cio_pcie";
+		power-domains = <&ps_atc3_cio>;
+	};
+
+	ps_atc3_cio_usb: power-controller@3b0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc3_cio_usb";
+		power-domains = <&ps_atc3_cio>;
+	};
+
+	ps_trace_fab: power-controller@3b8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "trace_fab";
+	};
+};
+
+&pmgr_east {
+	ps_clvr_spmi0: power-controller@100 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x100 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "clvr_spmi0";
+		apple,always-on; /* PCPU voltage regulator interface (used by SMC) */
+	};
+
+	ps_clvr_spmi1: power-controller@108 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x108 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "clvr_spmi1";
+		apple,always-on; /* GPU voltage regulator interface (used by SMC) */
+	};
+
+	ps_clvr_spmi2: power-controller@110 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x110 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "clvr_spmi2";
+		apple,always-on; /* ANE, fabric, AFR voltage regulator interface (used by SMC) */
+	};
+
+	ps_clvr_spmi3: power-controller@118 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x118 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "clvr_spmi3";
+		apple,always-on; /* Additional voltage regulator, probably used on T6001 (SMC) */
+	};
+
+	ps_clvr_spmi4: power-controller@120 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x120 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "clvr_spmi4";
+		apple,always-on; /* Additional voltage regulator, probably used on T6001 (SMC) */
+	};
+
+	ps_ispsens0: power-controller@128 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x128 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens0";
+	};
+
+	ps_ispsens1: power-controller@130 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x130 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens1";
+	};
+
+	ps_ispsens2: power-controller@138 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x138 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens2";
+	};
+
+	ps_ispsens3: power-controller@140 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x140 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ispsens3";
+	};
+
+	ps_afnc2_ioa: power-controller@148 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x148 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc2_ioa";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afi>;
+	};
+
+	ps_afnc2_ls: power-controller@150 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x150 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc2_ls";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc2_ioa>;
+	};
+
+	ps_afnc2_lw0: power-controller@158 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x158 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc2_lw0";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc2_ls>;
+	};
+
+	ps_afnc2_lw1: power-controller@160 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x160 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc2_lw1";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc2_ls>;
+	};
+
+	ps_afnc3_ioa: power-controller@168 {
+		compatible = "apple,t6001-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x168 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc3_ioa";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afi>;
+	};
+
+	ps_afnc3_ls: power-controller@170 {
+		compatible = "apple,t6001-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x170 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc3_ls";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc3_ioa>;
+	};
+
+	ps_afnc3_lw0: power-controller@178 {
+		compatible = "apple,t6001-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x178 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc3_lw0";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc3_ls>;
+	};
+
+	ps_sio: power-controller@180 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x180 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio";
+		power-domains = <&ps_afnc2_lw1>;
+	};
+
+	ps_sio_cpu: power-controller@188 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x188 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_cpu";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_fpwm0: power-controller@190 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x190 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "fpwm0";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_fpwm1: power-controller@198 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x198 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "fpwm1";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_fpwm2: power-controller@1a0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "fpwm2";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c0: power-controller@1a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c0";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c1: power-controller@1b0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c1";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c2: power-controller@1b8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c2";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c3: power-controller@1c0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c3";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c4: power-controller@1c8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c4";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c5: power-controller@1d0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1d0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c5";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c6: power-controller@1d8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1d8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c6";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_i2c7: power-controller@1e0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1e0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "i2c7";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_spi_p: power-controller@1e8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi_p";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_spi0: power-controller@1f0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1f0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi0";
+		power-domains = <&ps_spi_p>;
+	};
+
+	ps_spi1: power-controller@1f8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1f8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi1";
+		power-domains = <&ps_spi_p>;
+	};
+
+	ps_spi2: power-controller@200 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x200 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi2";
+		power-domains = <&ps_spi_p>;
+	};
+
+	ps_spi3: power-controller@208 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x208 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi3";
+		power-domains = <&ps_spi_p>;
+	};
+
+	ps_spi4: power-controller@210 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x210 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "spi4";
+		power-domains = <&ps_spi_p>;
+	};
+
+	ps_sio_spmi0: power-controller@218 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x218 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_spmi0";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_sio_spmi1: power-controller@220 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x220 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_spmi1";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_sio_spmi2: power-controller@228 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x228 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_spmi2";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_uart_p: power-controller@230 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x230 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart_p";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_uart_n: power-controller@238 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x238 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart_n";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart0: power-controller@240 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x240 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart0";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart1: power-controller@248 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x248 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart1";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart2: power-controller@250 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x250 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart2";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart3: power-controller@258 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x258 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart3";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart4: power-controller@260 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x260 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart4";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart6: power-controller@268 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x268 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart6";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_uart7: power-controller@270 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x270 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "uart7";
+		power-domains = <&ps_uart_p>;
+	};
+
+	ps_audio_p: power-controller@278 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x278 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "audio_p";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_sio_adma: power-controller@280 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x280 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sio_adma";
+		power-domains = <&ps_audio_p>, <&ps_sio>;
+	};
+
+	ps_mca0: power-controller@288 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x288 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca0";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca1: power-controller@290 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x290 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca1";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca2: power-controller@298 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x298 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca2";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_mca3: power-controller@2a0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mca3";
+		power-domains = <&ps_audio_p>, <&ps_sio_adma>;
+	};
+
+	ps_dpa0: power-controller@2a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dpa0";
+		power-domains = <&ps_audio_p>;
+	};
+
+	ps_dpa1: power-controller@2b0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dpa1";
+		power-domains = <&ps_audio_p>;
+	};
+
+	ps_dpa2: power-controller@2b8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dpa2";
+		power-domains = <&ps_audio_p>;
+	};
+
+	ps_dpa3: power-controller@2c0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dpa3";
+		power-domains = <&ps_audio_p>;
+	};
+
+	ps_dpa4: power-controller@2c8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dpa4";
+		power-domains = <&ps_audio_p>;
+	};
+
+	ps_aes: power-controller@2d0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2d0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "aes";
+		power-domains = <&ps_sio>;
+	};
+
+	ps_amcc1: power-controller@2d8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2d8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc1";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_amcc3: power-controller@2e0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2e0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc3";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_dcs_04: power-controller@2e8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_04";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_05: power-controller@2f0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2f0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_05";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_06: power-controller@2f8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x2f8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_06";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_07: power-controller@300 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x300 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_07";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_12: power-controller@308 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x308 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_12";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_13: power-controller@310 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x310 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_13";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_14: power-controller@318 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x318 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_14";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_15: power-controller@320 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x320 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_15";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_disp0_fe: power-controller@328 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x328 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "disp0_fe";
+		power-domains = <&ps_afnc2_lw0>;
+		apple,always-on; /* TODO: figure out if we can enable PM here */
+	};
+
+	ps_disp0_cpu0: power-controller@350 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x350 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "disp0_cpu0";
+		power-domains = <&ps_disp0_fe>;
+		apple,always-on; /* TODO: figure out if we can enable PM here */
+	};
+
+	ps_dispdfr_fe: power-controller@378 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x378 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispdfr_fe";
+		power-domains = <&ps_afnc2_lw1>;
+	};
+
+	ps_dispdfr_be: power-controller@380 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x380 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispdfr_be";
+		power-domains = <&ps_dispdfr_fe>;
+	};
+
+	ps_mipi_dsi: power-controller@388 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x388 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "mipi_dsi";
+		power-domains = <&ps_dispdfr_be>;
+	};
+
+	ps_jpg: power-controller@390 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x390 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "jpg";
+		power-domains = <&ps_afr>;
+	};
+
+	ps_msr0: power-controller@398 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x398 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msr0";
+		power-domains = <&ps_afr>;
+	};
+
+	ps_msr0_ase_core: power-controller@3a0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msr0_ase_core";
+		power-domains = <&ps_msr0>;
+	};
+
+	ps_isp_sys: power-controller@3a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "isp_sys";
+		power-domains = <&ps_afnc2_lw1>;
+	};
+
+	ps_venc_sys: power-controller@3b0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_sys";
+		power-domains = <&ps_afr>;
+	};
+
+	ps_ans2: power-controller@3b8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ans2";
+		/*
+		 * The ADT makes ps_apcie_st[1]_sys depend on ps_ans2 instead,
+		 * but we'd rather have a single power domain for the downstream
+		 * device to depend on, so use this node as the child.
+		 * This makes more sense anyway (since ANS2 uses APCIE_ST).
+		 */
+		power-domains = <&ps_afnc2_lw0>, <&ps_apcie_st_sys>, <&ps_apcie_st1_sys>;
+	};
+
+	ps_gfx: power-controller@3c0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x3c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "gfx";
+		power-domains = <&ps_afr>;
+	};
+
+	ps_sep: power-controller@c00 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xc00 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "sep";
+		apple,always-on; /* Locked on */
+	};
+
+	ps_venc_dma: power-controller@8000 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8000 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_dma";
+		power-domains = <&ps_venc_sys>;
+	};
+
+	ps_venc_pipe4: power-controller@8008 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8008 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_pipe4";
+		power-domains = <&ps_venc_dma>;
+	};
+
+	ps_venc_pipe5: power-controller@8010 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8010 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_pipe5";
+		power-domains = <&ps_venc_dma>;
+	};
+
+	ps_venc_me0: power-controller@8018 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8018 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_me0";
+		power-domains = <&ps_venc_pipe5>, <&ps_venc_pipe4>;
+	};
+
+	ps_venc_me1: power-controller@8020 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8020 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc_me1";
+		power-domains = <&ps_venc_me0>;
+	};
+};
+
+&pmgr_south {
+	ps_amcc4: power-controller@100 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x100 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc4";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_amcc5: power-controller@108 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x108 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc5";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_amcc6: power-controller@110 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x110 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc6";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_amcc7: power-controller@118 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x118 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "amcc7";
+		apple,always-on; /* Memory controller */
+	};
+
+	ps_dcs_16: power-controller@120 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x120 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_16";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_17: power-controller@128 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x128 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_17";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_18: power-controller@130 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x130 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_18";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_19: power-controller@138 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x138 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_19";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_20: power-controller@140 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x140 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_20";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_21: power-controller@148 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x148 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_21";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_22: power-controller@150 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x150 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_22";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_23: power-controller@158 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x158 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_23";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_24: power-controller@160 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x160 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_24";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_25: power-controller@168 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x168 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_25";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_26: power-controller@170 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x170 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_26";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_27: power-controller@178 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x178 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_27";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_28: power-controller@180 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x180 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_28";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_29: power-controller@188 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x188 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_29";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_30: power-controller@190 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x190 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_30";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_dcs_31: power-controller@198 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x198 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dcs_31";
+		apple,always-on; /* LPDDR5 interface */
+	};
+
+	ps_afnc4_ioa: power-controller@1a0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc4_ioa";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afi>;
+	};
+
+	ps_afnc4_ls: power-controller@1a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1a8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc4_ls";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc4_ioa>;
+	};
+
+	ps_afnc4_lw0: power-controller@1b0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc4_lw0";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc4_ls>;
+	};
+
+	ps_afnc5_ioa: power-controller@1b8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1b8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc5_ioa";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afi>;
+	};
+
+	ps_afnc5_ls: power-controller@1c0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc5_ls";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc5_ioa>;
+	};
+
+	ps_afnc5_lw0: power-controller@1c8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1c8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "afnc5_lw0";
+		apple,always-on; /* Apple Fabric */
+		power-domains = <&ps_afnc5_ls>;
+	};
+
+	ps_dispext2_fe: power-controller@1d0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1d0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext2_fe";
+		power-domains = <&ps_afnc4_lw0>;
+	};
+
+	ps_dispext2_cpu0: power-controller@1e8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x1e8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext2_cpu0";
+		power-domains = <&ps_dispext2_fe>;
+	};
+
+	ps_dispext3_fe: power-controller@210 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x210 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext3_fe";
+		power-domains = <&ps_afnc4_lw0>;
+	};
+
+	ps_dispext3_cpu0: power-controller@228 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x228 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "dispext3_cpu0";
+		power-domains = <&ps_dispext3_fe>;
+	};
+
+	ps_msr1: power-controller@250 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x250 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msr1";
+		power-domains = <&ps_afnc5_lw0>, <&ps_afr>;
+	};
+
+	ps_msr1_ase_core: power-controller@258 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x258 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msr1_ase_core";
+		power-domains = <&ps_msr1>;
+	};
+
+	ps_venc1_sys: power-controller@260 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x260 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc1_sys";
+		power-domains = <&ps_afnc5_lw0>, <&ps_afr>;
+	};
+
+	/* Seems to be disabled on shipping hardware */
+#if 0
+	ps_ane1_sys: power-controller@268 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x268 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ane1_sys";
+		power-domains = <&ps_afnc5_lw0>;
+	};
+
+	ps_ane1_sys_cpu: power-controller@270 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x270 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "ane1_sys_cpu";
+		power-domains = <&ps_ane1_sys>;
+	};
+#endif
+
+	ps_venc1_dma: power-controller@8000 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8000 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc1_dma";
+		power-domains = <&ps_venc1_sys>;
+	};
+
+	ps_venc1_pipe4: power-controller@8008 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8008 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc1_pipe4";
+		power-domains = <&ps_venc1_dma>;
+	};
+
+	ps_venc1_pipe5: power-controller@8010 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8010 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc1_pipe5";
+		power-domains = <&ps_venc1_dma>;
+	};
+
+	ps_venc1_me0: power-controller@8018 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8018 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc1_me0";
+		power-domains = <&ps_venc1_pipe4>, <&ps_venc1_pipe5>;
+	};
+
+	ps_venc1_me1: power-controller@8020 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x8020 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "venc1_me1";
+		power-domains = <&ps_venc1_me0>;
+	};
+
+	ps_prores: power-controller@c000 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xc000 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "prores";
+		power-domains = <&ps_afnc4_lw0>;
+	};
+};
+
+&pmgr_mini {
+	ps_debug: power-controller@58 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x58 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "debug";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_spmi0: power-controller@60 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x60 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_spmi0";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_spmi1: power-controller@68 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x68 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_spmi1";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_aon: power-controller@70 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x70 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_aon";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_msg: power-controller@78 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x78 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "msg";
+	};
+
+	ps_nub_gpio: power-controller@80 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x80 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_gpio";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_atc0_usb_aon: power-controller@88 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x88 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_usb_aon";
+	};
+
+	ps_atc1_usb_aon: power-controller@90 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x90 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_usb_aon";
+	};
+
+	ps_atc2_usb_aon: power-controller@98 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0x98 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc2_usb_aon";
+	};
+
+	ps_atc3_usb_aon: power-controller@a0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xa0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc3_usb_aon";
+	};
+
+	ps_gp_usb_aon: power-controller@a8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xa8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "gp_usb_aon";
+	};
+
+	ps_nub_fabric: power-controller@b0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xb0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_fabric";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_nub_sram: power-controller@b8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xb8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "nub_sram";
+		apple,always-on; /* Core AON device */
+	};
+
+	ps_debug_usb: power-controller@c0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xc0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "debug_usb";
+		apple,always-on; /* Core AON device */
+		power-domains = <&ps_debug>;
+	};
+
+	ps_debug_auth: power-controller@c8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xc8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "debug_auth";
+		apple,always-on; /* Core AON device */
+		power-domains = <&ps_debug>;
+	};
+
+	ps_atc0_usb: power-controller@d0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xd0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc0_usb";
+		power-domains = <&ps_atc0_usb_aon>, <&ps_atc0_common>;
+	};
+
+	ps_atc1_usb: power-controller@d8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xd8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc1_usb";
+		power-domains = <&ps_atc1_usb_aon>, <&ps_atc1_common>;
+	};
+
+	ps_atc2_usb: power-controller@e0 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xe0 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc2_usb";
+		power-domains = <&ps_atc2_usb_aon>, <&ps_atc2_common>;
+	};
+
+	ps_atc3_usb: power-controller@e8 {
+		compatible = "apple,t6000-pmgr-pwrstate", "apple,pmgr-pwrstate";
+		reg = <0xe8 4>;
+		#power-domain-cells = <0>;
+		#reset-cells = <0>;
+		label = "atc3_usb";
+		power-domains = <&ps_atc3_usb_aon>, <&ps_atc3_common>;
+	};
+};
+
diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index 68e8f91ea8e7..e919f42fdf9a 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -127,11 +127,40 @@ soc {
 		ranges;
 		nonposted-mmio;
 
+		pmgr: power-management@28e080000 {
+			compatible = "apple,t6000-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2 0x8e080000 0 0x4000>;
+		};
+
 		aic: interrupt-controller@28e100000 {
 			compatible = "apple,t6000-aic", "apple,aic2";
 			#interrupt-cells = <4>;
 			interrupt-controller;
 			reg = <0x2 0x8e100000 0x0 0x10000>;
+			power-domains = <&ps_aic>;
+		};
+
+		pmgr_east: power-management@28e580000 {
+			compatible = "apple,t6000-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2 0x8e580000 0 0xc000>;
+		};
+
+		pmgr_south: power-management@28e680000 {
+			compatible = "apple,t6000-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2 0x8e680000 0 0xc000>;
+		};
+
+		pmgr_mini: power-management@292280000 {
+			compatible = "apple,t6000-pmgr", "apple,pmgr", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2 0x92280000 0 0x4000>;
 		};
 
 		serial0: serial@39b200000 {
@@ -146,6 +175,7 @@ serial0: serial@39b200000 {
 			 */
 			clocks = <&clkref>, <&clkref>;
 			clock-names = "uart", "clk_uart_baud0";
+			power-domains = <&ps_uart0>;
 			status = "disabled";
 		};
 
@@ -163,6 +193,7 @@ pinctrl_ap: pinctrl@39b028000 {
 			             <AIC_IRQ 0 433 IRQ_TYPE_LEVEL_HIGH>;
 
 			clocks = <&clkref>;
+			power-domains = <&ps_gpio>;
 
 			gpio-controller;
 			#gpio-cells = <2>;
@@ -194,6 +225,7 @@ i2c0: i2c@39b040000 {
 			interrupts = <AIC_IRQ 0 1119 4>;
 			pinctrl-0 = <&i2c0_pins>;
 			pinctrl-names = "default";
+			power-domains = <&ps_i2c0>;
 			#address-cells = <0x1>;
 			#size-cells = <0x0>;
 		};
@@ -204,6 +236,7 @@ pcie0_dart_0: dart@581008000 {
 			#iommu-cells = <1>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1271 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_apcie_gp_sys>;
 		};
 
 		pcie0_dart_1: dart@582008000 {
@@ -212,6 +245,7 @@ pcie0_dart_1: dart@582008000 {
 			#iommu-cells = <1>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1274 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_apcie_gp_sys>;
 		};
 
 		pcie0_dart_2: dart@583008000 {
@@ -220,6 +254,7 @@ pcie0_dart_2: dart@583008000 {
 			#iommu-cells = <1>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1277 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_apcie_gp_sys>;
 		};
 
 		pcie0_dart_3: dart@584008000 {
@@ -228,6 +263,7 @@ pcie0_dart_3: dart@584008000 {
 			#iommu-cells = <1>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1280 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_apcie_gp_sys>;
 		};
 
 		pcie0: pcie@590000000 {
@@ -265,6 +301,7 @@ pcie0: pcie@590000000 {
 			ranges = <0x43000000 0x5 0xa0000000 0x5 0xa0000000 0x0 0x20000000>,
 				 <0x02000000 0x0 0xc0000000 0x5 0xc0000000 0x0 0x40000000>;
 
+			power-domains = <&ps_apcie_gp_sys>;
 			pinctrl-0 = <&pcie_pins>;
 			pinctrl-names = "default";
 
@@ -354,6 +391,7 @@ dwc3_0_dart_0: iommu@702f00000 {
 			reg = <0x7 0x02f00000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1194 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc0_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -362,6 +400,7 @@ dwc3_0_dart_1: iommu@702f80000 {
 			reg = <0x7 0x02f80000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1194 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc0_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -374,6 +413,7 @@ dwc3_0: usb@702280000 {
 			usb-role-switch;
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_0_dart_0 0>, <&dwc3_0_dart_1 1>;
+			power-domains = <&ps_atc0_usb>;
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
@@ -383,6 +423,7 @@ dwc3_1_dart_0: iommu@b02f00000 {
 			reg = <0xb 0x02f00000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1211 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc1_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -391,6 +432,7 @@ dwc3_1_dart_1: iommu@b02f80000 {
 			reg = <0xb 0x02f80000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1211 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc1_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -403,6 +445,7 @@ dwc3_1: usb@b02280000 {
 			usb-role-switch;
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_1_dart_0 0>, <&dwc3_1_dart_1 1>;
+			power-domains = <&ps_atc1_usb>;
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
@@ -412,6 +455,7 @@ dwc3_2_dart_0: iommu@f02f00000 {
 			reg = <0xf 0x02f00000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1228 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc2_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -420,6 +464,7 @@ dwc3_2_dart_1: iommu@f02f80000 {
 			reg = <0xf 0x02f80000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1228 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc2_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -432,6 +477,7 @@ dwc3_2: usb@f02280000 {
 			usb-role-switch;
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_2_dart_0 0>, <&dwc3_2_dart_1 1>;
+			power-domains = <&ps_atc2_usb>;
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
@@ -441,6 +487,7 @@ dwc3_3_dart_0: iommu@1302f00000 {
 			reg = <0x13 0x02f00000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1245 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc3_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -449,6 +496,7 @@ dwc3_3_dart_1: iommu@1302f80000 {
 			reg = <0x13 0x02f80000 0x0 0x4000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1245 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc3_usb>;
 			#iommu-cells = <1>;
 		};
 
@@ -461,6 +509,7 @@ dwc3_3: usb@1302280000 {
 			usb-role-switch;
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_3_dart_0 0>, <&dwc3_3_dart_1 1>;
+			power-domains = <&ps_atc3_usb>;
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
@@ -475,12 +524,14 @@ ans2_mbox: mbox@38f408000 {
 				<AIC_IRQ 0 1072 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "send-empty", "send-not-empty",
 				"recv-empty", "recv-not-empty";
+			power-domains = <&ps_ans2>;
 			#mbox-cells = <0>;
 		};
 
 		sart: sart@393c50000 {
 			compatible = "apple,t6000-sart";
 			reg = <0x3 0x93c50000 0x0 0x10000>;
+			power-domains = <&ps_ans2>;
 		};
 
 		ans2: nvme@393cc0000 {
@@ -491,6 +542,9 @@ ans2: nvme@393cc0000 {
 			interrupts = <AIC_IRQ 0 1613 IRQ_TYPE_LEVEL_HIGH>;
 			mboxes = <&ans2_mbox>;
 			apple,sart = <&sart>;
+			power-domains = <&ps_ans2>;
 		};
 	};
 };
+
+#include "t6001-pmgr.dtsi"
-- 
2.34.0


From fa3b1e6d6c3f279570d55a45c1e38998457e6c30 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Mon, 22 Nov 2021 00:49:47 +0900
Subject: [PATCH 36/83] PCI: apple: Configure link speeds properly

This sets the maximum link speed from the devicetree, and also requests
a link speed change from the controller. Without the request, the link
always comes up at Gen1 initially, and the core PCIe code complains
about a bandwidth bottleneck.

It turns out ASPM ends up retraining at a higher speed anyway even
without this code, but let's not rely on that.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 drivers/pci/controller/pcie-apple.c | 53 +++++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)

diff --git a/drivers/pci/controller/pcie-apple.c b/drivers/pci/controller/pcie-apple.c
index f98551336b42..d51cec10732e 100644
--- a/drivers/pci/controller/pcie-apple.c
+++ b/drivers/pci/controller/pcie-apple.c
@@ -30,6 +30,10 @@
 #include <linux/of_irq.h>
 #include <linux/pci-ecam.h>
 
+#include "../pci.h"
+/* Apple PCIe is based on DesignWare IP and shares some registers */
+#include "dwc/pcie-designware.h"
+
 #define CORE_RC_PHYIF_CTL		0x00024
 #define   CORE_RC_PHYIF_CTL_RUN		BIT(0)
 #define CORE_RC_PHYIF_STAT		0x00028
@@ -130,9 +134,13 @@
  */
 #define DOORBELL_ADDR		CONFIG_PCIE_APPLE_MSI_DOORBELL_ADDR
 
+/* The offset of the PCIe capabilities structure in bridge config space */
+#define PCIE_CAP_BASE		0x70
+
 struct apple_pcie {
 	struct mutex		lock;
 	struct device		*dev;
+	struct pci_config_window *cfg;
 	void __iomem            *base;
 	struct irq_domain	*domain;
 	unsigned long		*bitmap;
@@ -507,6 +515,48 @@ static u32 apple_pcie_rid2sid_write(struct apple_pcie_port *port,
 	return readl_relaxed(port->base + PORT_RID2SID(idx));
 }
 
+static inline void __iomem *bridge_reg(struct apple_pcie_port *port,
+						  int where)
+{
+	struct pci_config_window *cfg = port->pcie->cfg;
+
+	return cfg->win + PCIE_ECAM_OFFSET(0, PCI_DEVFN(port->idx, 0), where);
+}
+
+static void apple_pcie_unlock_dwc_regs(struct apple_pcie_port *port)
+{
+	rmw_set(PCIE_DBI_RO_WR_EN, bridge_reg(port,PCIE_MISC_CONTROL_1_OFF));
+}
+
+static void apple_pcie_lock_dwc_regs(struct apple_pcie_port *port)
+{
+	rmw_clear(PCIE_DBI_RO_WR_EN, bridge_reg(port, PCIE_MISC_CONTROL_1_OFF));
+}
+
+static int apple_pcie_link_configure_max_speed(struct apple_pcie_port *port)
+{
+	int max_gen;
+	u32 ctrl2;
+
+	max_gen = of_pci_get_max_link_speed(port->np);
+	if (max_gen < 0) {
+		dev_err(port->pcie->dev, "max link speed not specified\n");
+		return max_gen;
+	}
+
+	ctrl2 = readw_relaxed(bridge_reg(port, PCIE_CAP_BASE + PCI_EXP_LNKCTL2));
+	ctrl2 &= ~PCI_EXP_LNKCTL2_TLS;
+	ctrl2 |= FIELD_PREP(PCI_EXP_LNKCTL2_TLS, max_gen);
+	writew_relaxed(ctrl2, bridge_reg(port, PCIE_CAP_BASE + PCI_EXP_LNKCTL2));
+
+	apple_pcie_unlock_dwc_regs(port);
+	rmw_set(PORT_LOGIC_SPEED_CHANGE,
+		bridge_reg(port, PCIE_LINK_WIDTH_SPEED_CONTROL));
+	apple_pcie_lock_dwc_regs(port);
+
+	return 0;
+}
+
 static int apple_pcie_setup_port(struct apple_pcie *pcie,
 				 struct device_node *np)
 {
@@ -578,6 +628,8 @@ static int apple_pcie_setup_port(struct apple_pcie *pcie,
 	ret = apple_pcie_port_register_irqs(port);
 	WARN_ON(ret);
 
+	apple_pcie_link_configure_max_speed(port);
+
 	writel_relaxed(PORT_LTSSMCTL_START, port->base + PORT_LTSSMCTL);
 
 	if (!wait_for_completion_timeout(&pcie->event, HZ / 10))
@@ -763,6 +815,7 @@ static int apple_pcie_init(struct pci_config_window *cfg)
 		return -ENOMEM;
 
 	pcie->dev = dev;
+	pcie->cfg = cfg;
 
 	mutex_init(&pcie->lock);
 
-- 
2.34.0


From 204bdd1c3e65f52c09f75be0e42380a69629d7e7 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 23:11:35 +0100
Subject: [PATCH 37/83] fixup! arm64: dts: apple: Add initial t6000/t6001 DTs

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 18 +++++-------------
 1 file changed, 5 insertions(+), 13 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index e919f42fdf9a..3f5631cc962a 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -217,7 +217,7 @@ pcie_pins: pcie-pins {
 		};
 
 		i2c0: i2c@39b040000 {
-			compatible = "apple,t8103-i2c";
+			compatible = "apple,t8103-i2c", "apple,i2c";
 			reg = <0x3 0x9b040000 0x0 0x4000>;
 			clocks = <&clkref>, <&clkref>;
 			clock-names = "gate", "ref";
@@ -405,7 +405,7 @@ dwc3_0_dart_1: iommu@702f80000 {
 		};
 
 		dwc3_0: usb@702280000 {
-			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			compatible = "apple,t6000-dwc3", "apple,dwc3", "snps,dwc3";
 			reg = <0x7 0x02280000 0x0 0x100000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1190 IRQ_TYPE_LEVEL_HIGH>;
@@ -414,8 +414,6 @@ dwc3_0: usb@702280000 {
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_0_dart_0 0>, <&dwc3_0_dart_1 1>;
 			power-domains = <&ps_atc0_usb>;
-			#address-cells = <1>;
-			#size-cells = <0>;
 		};
 
 		dwc3_1_dart_0: iommu@b02f00000 {
@@ -437,7 +435,7 @@ dwc3_1_dart_1: iommu@b02f80000 {
 		};
 
 		dwc3_1: usb@b02280000 {
-			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			compatible = "apple,t6000-dwc3", "apple,dwc3", "snps,dwc3";
 			reg = <0xb 0x02280000 0x0 0x100000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1207 IRQ_TYPE_LEVEL_HIGH>;
@@ -446,8 +444,6 @@ dwc3_1: usb@b02280000 {
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_1_dart_0 0>, <&dwc3_1_dart_1 1>;
 			power-domains = <&ps_atc1_usb>;
-			#address-cells = <1>;
-			#size-cells = <0>;
 		};
 
 		dwc3_2_dart_0: iommu@f02f00000 {
@@ -469,7 +465,7 @@ dwc3_2_dart_1: iommu@f02f80000 {
 		};
 
 		dwc3_2: usb@f02280000 {
-			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			compatible = "apple,t6000-dwc3", "apple,dwc3", "snps,dwc3";
 			reg = <0xf 0x02280000 0x0 0x100000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1224 IRQ_TYPE_LEVEL_HIGH>;
@@ -478,8 +474,6 @@ dwc3_2: usb@f02280000 {
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_2_dart_0 0>, <&dwc3_2_dart_1 1>;
 			power-domains = <&ps_atc2_usb>;
-			#address-cells = <1>;
-			#size-cells = <0>;
 		};
 
 		dwc3_3_dart_0: iommu@1302f00000 {
@@ -501,7 +495,7 @@ dwc3_3_dart_1: iommu@1302f80000 {
 		};
 
 		dwc3_3: usb@1302280000 {
-			compatible = "apple,t6000,dwc3", "apple,dwc3", "snps,dwc3";
+			compatible = "apple,t6000-dwc3", "apple,dwc3", "snps,dwc3";
 			reg = <0x13 0x02280000 0x0 0x100000>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 0 1241 IRQ_TYPE_LEVEL_HIGH>;
@@ -510,8 +504,6 @@ dwc3_3: usb@1302280000 {
 			role-switch-default-mode = "host";
 			iommus = <&dwc3_3_dart_0 0>, <&dwc3_3_dart_1 1>;
 			power-domains = <&ps_atc3_usb>;
-			#address-cells = <1>;
-			#size-cells = <0>;
 		};
 
 		ans2_mbox: mbox@38f408000 {
-- 
2.34.0


From e3653844a60c0beea8db5b227cecb955d0539d3d Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 19:48:08 +0100
Subject: [PATCH 38/83] fixup! arm64: dts: apple: Add J314 and J316 devicetrees

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
index beacabb1ff07..577101db66b0 100644
--- a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
+++ b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
@@ -134,7 +134,7 @@ hpm5: tps6598x@3a {
 &port00 {
 	/* WLAN */
 	bus-range = <1 1>;
-	wifi0: pci@0,0 {
+	wifi0: ethernet@0,0 {
 		reg = <0x10000 0x0 0x0 0x0 0x0>;
 		/* To be filled by the loader */
 		local-mac-address = [00 10 18 00 00 10];
@@ -145,7 +145,7 @@ &port01 {
 	/* SD card reader */
 	bus-range = <2 2>;
 	max-link-speed = <1>;
-	sdhci0: pci@0,0 {
+	sdhci0: ethernet@0,0 {
 		reg = <0x20000 0x0 0x0 0x0 0x0>;
 		cd-inverted;
 		wp-inverted;
-- 
2.34.0


From 864940f2dd98911f1dcab82f1e7b86f214a4dfe2 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 23:12:08 +0100
Subject: [PATCH 39/83] fixup! arm64: dts: apple: Add J314 and J316 devicetrees

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
index 577101db66b0..10d96dd809d0 100644
--- a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
+++ b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
@@ -165,8 +165,7 @@ &pcie0_dart_3 {
 
 /* USB controllers */
 &dwc3_0 {
-	port@0 {
-		reg = <0>;
+	port {
 		typec0_usb_hs: endpoint {
 			remote-endpoint = <&typec0_con_hs>;
 		};
@@ -174,8 +173,7 @@ typec0_usb_hs: endpoint {
 };
 
 &dwc3_1 {
-	port@0 {
-		reg = <0>;
+	port {
 		typec1_usb_hs: endpoint {
 			remote-endpoint = <&typec1_con_hs>;
 		};
@@ -183,8 +181,7 @@ typec1_usb_hs: endpoint {
 };
 
 &dwc3_2 {
-	port@0 {
-		reg = <0>;
+	port {
 		typec2_usb_hs: endpoint {
 			remote-endpoint = <&typec2_con_hs>;
 		};
-- 
2.34.0


From f780dd9da01f7f6f0ec72617b65c05d8a3364e0d Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 21:32:00 +0100
Subject: [PATCH 40/83] fixup! arm64: dts: apple: Add initial t6000/t6001 DTs

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index 3f5631cc962a..cd83b1ba8543 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -217,12 +217,11 @@ pcie_pins: pcie-pins {
 		};
 
 		i2c0: i2c@39b040000 {
-			compatible = "apple,t8103-i2c", "apple,i2c";
+			compatible = "apple,t6000-i2c", "apple,i2c";
 			reg = <0x3 0x9b040000 0x0 0x4000>;
-			clocks = <&clkref>, <&clkref>;
-			clock-names = "gate", "ref";
+			clocks = <&clkref>;
 			interrupt-parent = <&aic>;
-			interrupts = <AIC_IRQ 0 1119 4>;
+			interrupts = <AIC_IRQ 0 1119 IRQ_TYPE_LEVEL_HIGH>;
 			pinctrl-0 = <&i2c0_pins>;
 			pinctrl-names = "default";
 			power-domains = <&ps_i2c0>;
-- 
2.34.0


From 89681d59051978851d4e4a7e05f84c839c625922 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 21:49:13 +0100
Subject: [PATCH 41/83] fixup! arm64: dts: apple: Add initial t6000/t6001 DTs

same change as:

arm64: dts: apple: t8103: Fix PCIe #PERST polarity

As the name indicates, #PERST is active low. So fix the DT description
to match the HW behaviour.

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index cd83b1ba8543..38a8ae44261b 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -7,6 +7,7 @@
  * Copyright The Asahi Linux Contributors
  */
 
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/interrupt-controller/apple-aic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/pinctrl/apple.h>
@@ -307,7 +308,7 @@ pcie0: pcie@590000000 {
 			port00: pci@0,0 {
 				device_type = "pci";
 				reg = <0x0 0x0 0x0 0x0 0x0>;
-				reset-gpios = <&pinctrl_ap 4 0>;
+				reset-gpios = <&pinctrl_ap 4 GPIO_ACTIVE_LOW>;
 				max-link-speed = <2>;
 
 				#address-cells = <3>;
@@ -327,7 +328,7 @@ port00: pci@0,0 {
 			port01: pci@1,0 {
 				device_type = "pci";
 				reg = <0x800 0x0 0x0 0x0 0x0>;
-				reset-gpios = <&pinctrl_ap 5 0>;
+				reset-gpios = <&pinctrl_ap 5 GPIO_ACTIVE_LOW>;
 				max-link-speed = <2>;
 
 				#address-cells = <3>;
@@ -347,7 +348,7 @@ port01: pci@1,0 {
 			port02: pci@2,0 {
 				device_type = "pci";
 				reg = <0x1000 0x0 0x0 0x0 0x0>;
-				reset-gpios = <&pinctrl_ap 6 0>;
+				reset-gpios = <&pinctrl_ap 6 GPIO_ACTIVE_LOW>;
 				max-link-speed = <1>;
 
 				#address-cells = <3>;
@@ -367,7 +368,7 @@ port02: pci@2,0 {
 			port03: pci@3,0 {
 				device_type = "pci";
 				reg = <0x1800 0x0 0x0 0x0 0x0>;
-				reset-gpios = <&pinctrl_ap 7 0>;
+				reset-gpios = <&pinctrl_ap 7 GPIO_ACTIVE_LOW>;
 				max-link-speed = <1>;
 
 				#address-cells = <3>;
-- 
2.34.0


From 73eb726c1085a680548c58740db810d8c7d48818 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 22:00:35 +0100
Subject: [PATCH 42/83] fixup! arm64: dts: apple: Add initial t6000/t6001 DTs

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index 38a8ae44261b..c29e0bb3e2bc 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -267,7 +267,7 @@ pcie0_dart_3: dart@584008000 {
 		};
 
 		pcie0: pcie@590000000 {
-			compatible = "apple,t8103-pcie", "apple,pcie";
+			compatible = "apple,t6000-pcie", "apple,pcie";
 			device_type = "pci";
 
 			reg = <0x5 0x90000000 0x0 0x1000000>,
-- 
2.34.0


From 28a0bfc2b32c9c688e39645bd5c3b7b40515a76b Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 23:13:56 +0100
Subject: [PATCH 43/83] fixup! arm64: dts: apple: Add J314 and J316 devicetrees

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
index 10d96dd809d0..4a5a55ca8aa3 100644
--- a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
+++ b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
@@ -42,7 +42,7 @@ &serial0 {
 
 /* USB Type C */
 &i2c0 {
-	hpm0: tps6598x@38 {
+	hpm0: usb-pd@38 {
 		compatible = "apple,cd321x";
 		reg = <0x38>;
 		interrupt-parent = <&pinctrl_ap>;
@@ -68,7 +68,7 @@ typec0_con_hs: endpoint {
 		};
 	};
 
-	hpm1: tps6598x@3f {
+	hpm1: usb-pd@3f {
 		compatible = "apple,cd321x";
 		reg = <0x3f>;
 		interrupt-parent = <&pinctrl_ap>;
@@ -94,7 +94,7 @@ typec1_con_hs: endpoint {
 		};
 	};
 
-	hpm2: tps6598x@3b {
+	hpm2: usb-pd@3b {
 		compatible = "apple,cd321x";
 		reg = <0x3b>;
 		interrupt-parent = <&pinctrl_ap>;
@@ -121,7 +121,7 @@ typec2_con_hs: endpoint {
 	};
 
 	/* MagSafe port */
-	hpm5: tps6598x@3a {
+	hpm5: usb-pd@3a {
 		compatible = "apple,cd321x";
 		reg = <0x3a>;
 		interrupt-parent = <&pinctrl_ap>;
-- 
2.34.0


From 5fe5d0fe889a5eb263f48d2d07c32d0f187ab86d Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 23:14:10 +0100
Subject: [PATCH 44/83] fixup! arm64: dts: apple: Add J314 and J316 devicetrees

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
index 4a5a55ca8aa3..219b53badcea 100644
--- a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
+++ b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
@@ -134,7 +134,7 @@ hpm5: usb-pd@3a {
 &port00 {
 	/* WLAN */
 	bus-range = <1 1>;
-	wifi0: ethernet@0,0 {
+	wifi0: wifi@0,0 {
 		reg = <0x10000 0x0 0x0 0x0 0x0>;
 		/* To be filled by the loader */
 		local-mac-address = [00 10 18 00 00 10];
@@ -145,7 +145,7 @@ &port01 {
 	/* SD card reader */
 	bus-range = <2 2>;
 	max-link-speed = <1>;
-	sdhci0: ethernet@0,0 {
+	sdhci0: mmc@0,0 {
 		reg = <0x20000 0x0 0x0 0x0 0x0>;
 		cd-inverted;
 		wp-inverted;
-- 
2.34.0


From 34fd1e3c310f2066eb73c9fd8de13bff192d2d00 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 21:24:02 +0100
Subject: [PATCH 45/83] arm64: dts: apple: t6001: add aop, nub and smc pinctrl
 nodes

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 64 ++++++++++++++++++++++++++++
 1 file changed, 64 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index c29e0bb3e2bc..7baaf31dae75 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -157,6 +157,49 @@ pmgr_south: power-management@28e680000 {
 			reg = <0x2 0x8e680000 0 0xc000>;
 		};
 
+		pinctrl_smc: pinctrl@290820000 {
+			compatible = "apple,t6000-pinctrl", "apple,pinctrl";
+			reg = <0x2 0x90820000 0x0 0x4000>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl_smc 0 0 30>;
+			apple,npins = <30>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 743 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 744 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 745 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 746 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 747 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 748 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 749 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		pinctrl_nub: pinctrl@2921f0000 {
+			compatible = "apple,t6000-pinctrl", "apple,pinctrl";
+			reg = <0x2 0x921f0000 0x0 0x4000>;
+			power-domains = <&ps_nub_gpio>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl_nub 0 0 16>;
+			apple,npins = <16>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 623 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 624 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 625 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 626 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 627 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 628 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 629 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		pmgr_mini: power-management@292280000 {
 			compatible = "apple,t6000-pmgr", "apple,pmgr", "syscon", "simple-mfd";
 			#address-cells = <1>;
@@ -164,6 +207,27 @@ pmgr_mini: power-management@292280000 {
 			reg = <0x2 0x92280000 0 0x4000>;
 		};
 
+		pinctrl_aop: pinctrl@293820000 {
+			compatible = "apple,t6000-pinctrl", "apple,pinctrl";
+			reg = <0x2 0x93820000 0x0 0x4000>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl_aop 0 0 63>;
+			apple,npins = <63>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 567 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 568 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 569 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 570 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 571 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 572 IRQ_TYPE_LEVEL_HIGH>,
+				     <AIC_IRQ 0 573 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		serial0: serial@39b200000 {
 			compatible = "apple,s5l-uart";
 			reg = <0x3 0x9b200000 0x0 0x1000>;
-- 
2.34.0


From 589a7d6ac630605c011074609d52be93de553d96 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 21:42:34 +0100
Subject: [PATCH 46/83] arm64: dts: apple: t6001: Add i2c1 to i2c5 device nodes

Devices are disabled until they gain an target on the i2c bus.

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 95 ++++++++++++++++++++++++++++
 1 file changed, 95 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index 7baaf31dae75..c703e95fabe6 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -273,6 +273,31 @@ i2c0_pins: i2c0-pins {
 					<APPLE_PINMUX(93, 1)>;
 			};
 
+			i2c1_pins: i2c1-pins {
+				pinmux = <APPLE_PINMUX(94, 1)>,
+					<APPLE_PINMUX(95, 1)>;
+			};
+
+			i2c2_pins: i2c2-pins {
+				pinmux = <APPLE_PINMUX(96, 1)>,
+					<APPLE_PINMUX(97, 1)>;
+			};
+
+			i2c3_pins: i2c3-pins {
+				pinmux = <APPLE_PINMUX(98, 1)>,
+					<APPLE_PINMUX(99, 1)>;
+			};
+
+			i2c4_pins: i2c4-pins {
+				pinmux = <APPLE_PINMUX(8, 1)>,
+					<APPLE_PINMUX(9, 1)>;
+			};
+
+			i2c5_pins: i2c5-pins {
+				pinmux = <APPLE_PINMUX(100, 1)>,
+					<APPLE_PINMUX(101, 1)>;
+			};
+
 			pcie_pins: pcie-pins {
 				pinmux = <APPLE_PINMUX(0, 1)>,
 					 <APPLE_PINMUX(1, 1)>,
@@ -294,6 +319,76 @@ i2c0: i2c@39b040000 {
 			#size-cells = <0x0>;
 		};
 
+		i2c1: i2c@39b044000 {
+			compatible = "apple,t6000-i2c", "apple,i2c";
+			reg = <0x3 0x9b044000 0x0 0x4000>;
+			clocks = <&clkref>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1120 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c1_pins>;
+			pinctrl-names = "default";
+			power-domains = <&ps_i2c1>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@39b048000 {
+			compatible = "apple,t6000-i2c", "apple,i2c";
+			reg = <0x3 0x9b048000 0x0 0x4000>;
+			clocks = <&clkref>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1121 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c2_pins>;
+			pinctrl-names = "default";
+			power-domains = <&ps_i2c2>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@39b04c000 {
+			compatible = "apple,t6000-i2c", "apple,i2c";
+			reg = <0x3 0x9b04c000 0x0 0x4000>;
+			clocks = <&clkref>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1122 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c3_pins>;
+			pinctrl-names = "default";
+			power-domains = <&ps_i2c3>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			status = "disabled";
+		};
+
+		i2c4: i2c@39b050000 {
+			compatible = "apple,t6000-i2c", "apple,i2c";
+			reg = <0x3 0x9b050000 0x0 0x4000>;
+			clocks = <&clkref>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1123 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c4_pins>;
+			pinctrl-names = "default";
+			power-domains = <&ps_i2c4>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			status = "disabled";
+		};
+
+		i2c5: i2c@39b054000 {
+			compatible = "apple,t6000-i2c", "apple,i2c";
+			reg = <0x3 0x9b054000 0x0 0x4000>;
+			clocks = <&clkref>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1124 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c5_pins>;
+			pinctrl-names = "default";
+			power-domains = <&ps_i2c5>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			status = "disabled";
+		};
+
 		pcie0_dart_0: dart@581008000 {
 			compatible = "apple,t6000-dart";
 			reg = <0x5 0x81008000 0x0 0x4000>;
-- 
2.34.0


From 6d1cc6193b3840a72afb4f9316e92f90a1392f56 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 24 Nov 2021 16:34:12 +0900
Subject: [PATCH 47/83] dt-bindings: i2c: apple,i2c: Add power-domains property

This will bind to the PMGR pwrstate nodes that control power/clock
gating to SoC blocks. The i2c driver doesn't do runtime-pm yet, so
initially this will just keep the domain on permanently.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 Documentation/devicetree/bindings/i2c/apple,i2c.yaml | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Documentation/devicetree/bindings/i2c/apple,i2c.yaml b/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
index 22fc8483256f..be2bfbddfa36 100644
--- a/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
+++ b/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
@@ -40,6 +40,9 @@ properties:
       used. This frequency is generated by dividing the reference clock.
       Allowed values are between ref_clk/(16*4) and ref_clk/(16*255).
 
+  power-domains:
+    maxItems: 1
+
 required:
   - compatible
   - reg
-- 
2.34.0


From ff14ef0ef753aee19b63fc5ec00425cb7d9e6e76 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 24 Nov 2021 16:34:13 +0900
Subject: [PATCH 48/83] dt-bindings: iommu: apple,dart: Add power-domains
 property

This will bind to the PMGR pwrstate nodes that control power/clock
gating to SoC blocks. The DART driver doesn't do runtime-pm yet, so
initially this will just keep the domain on permanently.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 Documentation/devicetree/bindings/iommu/apple,dart.yaml | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Documentation/devicetree/bindings/iommu/apple,dart.yaml b/Documentation/devicetree/bindings/iommu/apple,dart.yaml
index ca2cbde9f3c9..06af2bacbe97 100644
--- a/Documentation/devicetree/bindings/iommu/apple,dart.yaml
+++ b/Documentation/devicetree/bindings/iommu/apple,dart.yaml
@@ -43,6 +43,9 @@ properties:
       Has to be one. The single cell describes the stream id emitted by
       a master to the IOMMU.
 
+  power-domains:
+    maxItems: 1
+
 required:
   - compatible
   - reg
-- 
2.34.0


From d4a68aeaba3a7510e293f07fd886ee0bb7bd5a07 Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 24 Nov 2021 16:34:14 +0900
Subject: [PATCH 49/83] dt-bindings: pinctrl: apple,pinctrl: Add power-domains
 property

This will bind to the PMGR pwrstate nodes that control power/clock
gating to SoC blocks. The pinctrl driver doesn't do runtime-pm yet, so
initially this will just keep the domain on permanently.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml b/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
index 07b00de79755..200d411621e7 100644
--- a/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
+++ b/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
@@ -50,6 +50,9 @@ properties:
   '#interrupt-cells':
     const: 2
 
+  power-domains:
+    maxItems: 1
+
 patternProperties:
   '-pins$':
     type: object
-- 
2.34.0


From 54da795020184ea7b2a094d2787918fdb10cc90a Mon Sep 17 00:00:00 2001
From: Hector Martin <marcan@marcan.st>
Date: Wed, 24 Nov 2021 16:34:15 +0900
Subject: [PATCH 50/83] dt-bindings: interrupt-controller: apple,aic: Add
 power-domains property

This will bind to the PMGR pwrstate nodes that control power/clock
gating to SoC blocks. The AIC driver doesn't do runtime-pm and likely
never will (since it is system-critical), but it makes sense to describe
the power domain relationship the devicetree properly.

Signed-off-by: Hector Martin <marcan@marcan.st>
---
 .../devicetree/bindings/interrupt-controller/apple,aic.yaml    | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Documentation/devicetree/bindings/interrupt-controller/apple,aic.yaml b/Documentation/devicetree/bindings/interrupt-controller/apple,aic.yaml
index cf6c091a07b1..97359024709a 100644
--- a/Documentation/devicetree/bindings/interrupt-controller/apple,aic.yaml
+++ b/Documentation/devicetree/bindings/interrupt-controller/apple,aic.yaml
@@ -65,6 +65,9 @@ properties:
       Specifies base physical address and size of the AIC registers.
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
 required:
   - compatible
   - '#interrupt-cells'
-- 
2.34.0


From e80850b6cd9161b69a8e868599e67ba253381540 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 22:40:16 +0100
Subject: [PATCH 51/83] dt-bindings: mailbox: apple: Add power-domains property

This will bind to the PMGR pwrstate nodes that control power/clock
gating to SoC blocks. The mailbox driver doesn't do runtime-pm yet, so
initially this will just keep the domain on permanently.
---
 Documentation/devicetree/bindings/mailbox/apple,mailbox.yaml | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Documentation/devicetree/bindings/mailbox/apple,mailbox.yaml b/Documentation/devicetree/bindings/mailbox/apple,mailbox.yaml
index 2c1704b34e7a..c4255f42e801 100644
--- a/Documentation/devicetree/bindings/mailbox/apple,mailbox.yaml
+++ b/Documentation/devicetree/bindings/mailbox/apple,mailbox.yaml
@@ -56,6 +56,9 @@ properties:
   "#mbox-cells":
     const: 0
 
+  power-domains:
+    maxItems: 1
+
 required:
   - compatible
   - reg
-- 
2.34.0


From 6cec5e3f7f198d9da354a186b64032329c535fd8 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 19:41:13 +0100
Subject: [PATCH 52/83] dt-bindings: i2c: apple,i2c: allow multiple compatibles

The intention was to have a SoC-specific and base compatible string
to allow forward compatibility and SoC specific quirks,

Fixes: df7c4a8c1b47 ("dt-bindings: i2c: Add Apple I2C controller bindings")
Signed-off-by: Janne Grunau <j@jannau.net>
Cc: Mark Kettenis <kettenis@openbsd.org>
Reviewed-by: Sven Peter <sven@svenpeter.dev>
---
 Documentation/devicetree/bindings/i2c/apple,i2c.yaml | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/Documentation/devicetree/bindings/i2c/apple,i2c.yaml b/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
index be2bfbddfa36..47dd6c107a6d 100644
--- a/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
+++ b/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
@@ -20,9 +20,9 @@ allOf:
 
 properties:
   compatible:
-    enum:
-      - apple,t8103-i2c
-      - apple,i2c
+    items:
+      - const: apple,t8103-i2c
+      - const: apple,i2c
 
   reg:
     maxItems: 1
@@ -54,7 +54,7 @@ unevaluatedProperties: false
 examples:
   - |
     i2c@35010000 {
-      compatible = "apple,t8103-i2c";
+      compatible = "apple,t8103-i2c", "apple,i2c";
       reg = <0x35010000 0x4000>;
       interrupt-parent = <&aic>;
       interrupts = <0 627 4>;
-- 
2.34.0


From 4c27957101f7e7ecb794d8d1c75498bcb48cfc1a Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Sun, 14 Nov 2021 13:54:50 +0100
Subject: [PATCH 53/83] dt-bindings: arm: apple: Add iMac (24-inch 2021) to
 Apple bindings

This introduces compatible strings for both 2021 Apple iMac M1 devices:

* apple,j456 - iMac (24-inch, 4x USB-C, M1, 2021)
* apple,j457 - iMac (24-inch, 2x USB-C, M1, 2021)

Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Signed-off-by: Janne Grunau <j@jannau.net>
---
 Documentation/devicetree/bindings/arm/apple.yaml | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/Documentation/devicetree/bindings/arm/apple.yaml b/Documentation/devicetree/bindings/arm/apple.yaml
index 1e772c85206c..b23c8dc5a27d 100644
--- a/Documentation/devicetree/bindings/arm/apple.yaml
+++ b/Documentation/devicetree/bindings/arm/apple.yaml
@@ -12,12 +12,12 @@ maintainers:
 description: |
   ARM platforms using SoCs designed by Apple Inc., branded "Apple Silicon".
 
-  This currently includes devices based on the "M1" SoC, starting with the
-  three Mac models released in late 2020:
+  This currently includes devices based on the "M1" SoC:
 
   - Mac mini (M1, 2020)
   - MacBook Pro (13-inch, M1, 2020)
   - MacBook Air (M1, 2020)
+  - iMac (24-inch, M1, 2021)
 
   The compatible property should follow this format:
 
@@ -56,6 +56,8 @@ properties:
               - apple,j274 # Mac mini (M1, 2020)
               - apple,j293 # MacBook Pro (13-inch, M1, 2020)
               - apple,j313 # MacBook Air (M1, 2020)
+              - apple,j456 # iMac (24-inch, 4x USB-C, M1, 2021)
+              - apple,j457 # iMac (24-inch, 2x USB-C, M1, 2021)
           - const: apple,t8103
           - const: apple,arm-platform
 
-- 
2.34.0


From ded1c68fa273269f09a4c320a3b5521cff147d3d Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 19:46:17 +0100
Subject: [PATCH 54/83] dt-bindings: i2c: apple,i2c: add "apple,t6000-i2c"
 compatible

Signed-off-by: Janne Grunau <j@jannau.net>
---
 Documentation/devicetree/bindings/i2c/apple,i2c.yaml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/i2c/apple,i2c.yaml b/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
index 47dd6c107a6d..8000870b7b9f 100644
--- a/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
+++ b/Documentation/devicetree/bindings/i2c/apple,i2c.yaml
@@ -21,7 +21,9 @@ allOf:
 properties:
   compatible:
     items:
-      - const: apple,t8103-i2c
+      - enum:
+          - apple,t6000-i2c
+          - apple,t8103-i2c
       - const: apple,i2c
 
   reg:
-- 
2.34.0


From 27fde6c4b21808f5998c4be5038dd629f2afd27c Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 21:27:33 +0100
Subject: [PATCH 55/83] dt-bindings: pinctrl: apple,pinctrl: Add
 apple,t6000-i2c compatible

Signed-off-by: Janne Grunau <j@jannau.net>
---
 Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml b/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
index 200d411621e7..2be094913be7 100644
--- a/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
+++ b/Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
@@ -17,7 +17,9 @@ description: |
 properties:
   compatible:
     items:
-      - const: apple,t8103-pinctrl
+      - enum:
+          - apple,t6000-pinctrl
+          - apple,t8103-pinctrl
       - const: apple,pinctrl
 
   reg:
-- 
2.34.0


From 8266763703b9ed674be2ebf7756772d22c0fedbb Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 21:56:43 +0100
Subject: [PATCH 56/83] dt-bindings: pci: apple,pcie: Add support for M1
 Pro/Max

Add a new SoC specific compatible string "apple,t6000-pcie" and extends
field for 4 ports instead of 3 ports on the M1.
---
 Documentation/devicetree/bindings/pci/apple,pcie.yaml | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/Documentation/devicetree/bindings/pci/apple,pcie.yaml b/Documentation/devicetree/bindings/pci/apple,pcie.yaml
index ef1d424ec299..f8e52325af84 100644
--- a/Documentation/devicetree/bindings/pci/apple,pcie.yaml
+++ b/Documentation/devicetree/bindings/pci/apple,pcie.yaml
@@ -35,12 +35,14 @@ allOf:
 properties:
   compatible:
     items:
-      - const: apple,t8103-pcie
+      - enum:
+          - apple,t6000-pcie
+          - apple,t8103-pcie
       - const: apple,pcie
 
   reg:
     minItems: 3
-    maxItems: 5
+    maxItems: 6
 
   reg-names:
     minItems: 3
@@ -50,6 +52,7 @@ properties:
       - const: port0
       - const: port1
       - const: port2
+      - const: port3
 
   ranges:
     minItems: 2
@@ -59,7 +62,7 @@ properties:
     description:
       Interrupt specifiers, one for each root port.
     minItems: 1
-    maxItems: 3
+    maxItems: 4
 
   msi-parent: true
 
-- 
2.34.0


From c06bbfc1982c87c424580078cd39371f9fb8b153 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 22:06:26 +0100
Subject: [PATCH 57/83] dt-bindings: arm: apple: Add 2021 MacBook Pro targets

This introduces compatible strings for the 14-inch and 16-inch Apple
Macbook Pro models:

* apple,j314c - MacBook Pro (14-inc, M1 Max, 2021)
* apple,j314s - MacBook Pro (14-inc, M1 Pro, 2021)
* apple,j316c - MacBook Pro (16-inc, M1 Max, 2021)
* apple,j316s - MacBook Pro (16-inc, M1 Pro, 2021)

In addition it add compatible strings for the M1 Pro and M1 Max SoCs:
* apple,t6000 - M1 Pro
* apple,t6001 - M1 Max

Signed-off-by: Janne Grunau <j@jannau.net>
---
 Documentation/devicetree/bindings/arm/apple.yaml | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/Documentation/devicetree/bindings/arm/apple.yaml b/Documentation/devicetree/bindings/arm/apple.yaml
index b23c8dc5a27d..8194c041c988 100644
--- a/Documentation/devicetree/bindings/arm/apple.yaml
+++ b/Documentation/devicetree/bindings/arm/apple.yaml
@@ -12,12 +12,14 @@ maintainers:
 description: |
   ARM platforms using SoCs designed by Apple Inc., branded "Apple Silicon".
 
-  This currently includes devices based on the "M1" SoC:
+  This currently includes devices based on the "M1", "M1 Pro", "M1 Max" SoCs:
 
   - Mac mini (M1, 2020)
   - MacBook Pro (13-inch, M1, 2020)
   - MacBook Air (M1, 2020)
   - iMac (24-inch, M1, 2021)
+  - MacBook Pro (14-inch, M1 Pro/Max, 2021)
+  - MacBook Pro (16-inch, M1 Pro/Max, 2021)
 
   The compatible property should follow this format:
 
@@ -56,9 +58,16 @@ properties:
               - apple,j274 # Mac mini (M1, 2020)
               - apple,j293 # MacBook Pro (13-inch, M1, 2020)
               - apple,j313 # MacBook Air (M1, 2020)
+              - apple,j314c # MacBook Pro (14-inc, M1 Max, 2021)
+              - apple,j314s # MacBook Pro (14-inc, M1 Pro, 2021)
+              - apple,j316c # MacBook Pro (16-inc, M1 Max, 2021)
+              - apple,j316s # MacBook Pro (16-inc, M1 Pro, 2021)
               - apple,j456 # iMac (24-inch, 4x USB-C, M1, 2021)
               - apple,j457 # iMac (24-inch, 2x USB-C, M1, 2021)
-          - const: apple,t8103
+          - enum:
+              - apple,t6000 # M1 Pro
+              - apple,t6001 # M1 Max
+              - apple,t8103 # M1
           - const: apple,arm-platform
 
 additionalProperties: true
-- 
2.34.0


From 7c954721c8ea10b6745171f01c1e58d5437d6ece Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Sun, 14 Nov 2021 14:51:26 +0100
Subject: [PATCH 58/83] arm64: dts: apple: change ethernet0 device type to
 ethernet

Fixes make dtbs_check errors for t8103-j274.dts due to missing pci
properties.

Fixes: e1bebf978151 ("arm64: dts: apple: j274: Expose PCI node for the Ethernet MAC address")
Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t8103-j274.dts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/apple/t8103-j274.dts b/arch/arm64/boot/dts/apple/t8103-j274.dts
index 86ea1b0a6cc8..6ba566caf69f 100644
--- a/arch/arm64/boot/dts/apple/t8103-j274.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j274.dts
@@ -65,7 +65,7 @@ &port01 {
 
 &port02 {
 	bus-range = <3 3>;
-	ethernet0: pci@0,0 {
+	ethernet0: ethernet@0,0 {
 		reg = <0x30000 0x0 0x0 0x0 0x0>;
 		/* To be filled by the loader */
 		local-mac-address = [00 10 18 00 00 00];
-- 
2.34.0


From 9ca46082d0e17ba4d1f58fa0f5676da74660578c Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 21:11:33 +0100
Subject: [PATCH 59/83] arm64: dts: apple: add #interrupt-cells property to
 pinctrl nodes

Required for devices trying to use pinctrl devices as interrupt
controller.

Fixes: 0a8282b83119 ("arm64: apple: Add pinctrl nodes")
Signed-off-by: Janne Grunau <j@jannau.net>
Cc: Mark Kettenis <kettenis@openbsd.org>
Reviewed-by: Sven Peter <sven@svenpeter.dev>
---
 arch/arm64/boot/dts/apple/t8103.dtsi | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index a07c7d4d3e5d..e39b14971e68 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -165,6 +165,7 @@ pinctrl_ap: pinctrl@23c100000 {
 			apple,npins = <212>;
 
 			interrupt-controller;
+			#interrupt-cells = <2>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 190 IRQ_TYPE_LEVEL_HIGH>,
 				     <AIC_IRQ 191 IRQ_TYPE_LEVEL_HIGH>,
@@ -198,6 +199,7 @@ pinctrl_aop: pinctrl@24a820000 {
 			apple,npins = <42>;
 
 			interrupt-controller;
+			#interrupt-cells = <2>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 268 IRQ_TYPE_LEVEL_HIGH>,
 				     <AIC_IRQ 269 IRQ_TYPE_LEVEL_HIGH>,
@@ -219,6 +221,7 @@ pinctrl_nub: pinctrl@23d1f0000 {
 			apple,npins = <23>;
 
 			interrupt-controller;
+			#interrupt-cells = <2>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 330 IRQ_TYPE_LEVEL_HIGH>,
 				     <AIC_IRQ 331 IRQ_TYPE_LEVEL_HIGH>,
@@ -239,6 +242,7 @@ pinctrl_smc: pinctrl@23e820000 {
 			apple,npins = <16>;
 
 			interrupt-controller;
+			#interrupt-cells = <2>;
 			interrupt-parent = <&aic>;
 			interrupts = <AIC_IRQ 391 IRQ_TYPE_LEVEL_HIGH>,
 				     <AIC_IRQ 392 IRQ_TYPE_LEVEL_HIGH>,
-- 
2.34.0


From 4836a5113bbf0b069b8a2e8d8b23684fc0f63246 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Sun, 14 Nov 2021 13:48:20 +0100
Subject: [PATCH 60/83] arm64: dts: apple: Add missing M1 (t8103) devices

This adds support for following Apple M1 devices:
 - MacBook Pro (13-inch, M1, 2020)
 - MacBook Air (M1, 2020)
 - iMac (24-inch 2021)

Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/Makefile        |  4 ++
 arch/arm64/boot/dts/apple/t8103-j274.dts  | 34 +-------------
 arch/arm64/boot/dts/apple/t8103-j293.dts  | 33 ++++++++++++++
 arch/arm64/boot/dts/apple/t8103-j313.dts  | 33 ++++++++++++++
 arch/arm64/boot/dts/apple/t8103-j456.dts  | 41 +++++++++++++++++
 arch/arm64/boot/dts/apple/t8103-j457.dts  | 47 ++++++++++++++++++++
 arch/arm64/boot/dts/apple/t8103-jxxx.dtsi | 54 +++++++++++++++++++++++
 7 files changed, 213 insertions(+), 33 deletions(-)
 create mode 100644 arch/arm64/boot/dts/apple/t8103-j293.dts
 create mode 100644 arch/arm64/boot/dts/apple/t8103-j313.dts
 create mode 100644 arch/arm64/boot/dts/apple/t8103-j456.dts
 create mode 100644 arch/arm64/boot/dts/apple/t8103-j457.dts
 create mode 100644 arch/arm64/boot/dts/apple/t8103-jxxx.dtsi

diff --git a/arch/arm64/boot/dts/apple/Makefile b/arch/arm64/boot/dts/apple/Makefile
index 8a94ff229ff9..b021931b0a17 100644
--- a/arch/arm64/boot/dts/apple/Makefile
+++ b/arch/arm64/boot/dts/apple/Makefile
@@ -1,5 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
 dtb-$(CONFIG_ARCH_APPLE) += t8103-j274.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t8103-j293.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t8103-j313.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t8103-j456.dtb
+dtb-$(CONFIG_ARCH_APPLE) += t8103-j457.dtb
 dtb-$(CONFIG_ARCH_APPLE) += t6000-j314s.dtb
 dtb-$(CONFIG_ARCH_APPLE) += t6001-j314c.dtb
 dtb-$(CONFIG_ARCH_APPLE) += t6000-j316s.dtb
diff --git a/arch/arm64/boot/dts/apple/t8103-j274.dts b/arch/arm64/boot/dts/apple/t8103-j274.dts
index 6ba566caf69f..9e01ef70039d 100644
--- a/arch/arm64/boot/dts/apple/t8103-j274.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j274.dts
@@ -10,44 +10,15 @@
 /dts-v1/;
 
 #include "t8103.dtsi"
+#include "t8103-jxxx.dtsi"
 
 / {
 	compatible = "apple,j274", "apple,t8103", "apple,arm-platform";
 	model = "Apple Mac mini (M1, 2020)";
 
 	aliases {
-		serial0 = &serial0;
-		serial2 = &serial2;
 		ethernet0 = &ethernet0;
 	};
-
-	chosen {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		ranges;
-
-		stdout-path = "serial0";
-
-		framebuffer0: framebuffer@0 {
-			compatible = "apple,simple-framebuffer", "simple-framebuffer";
-			reg = <0 0 0 0>; /* To be filled by loader */
-			/* Format properties will be added by loader */
-			status = "disabled";
-		};
-	};
-
-	memory@800000000 {
-		device_type = "memory";
-		reg = <0x8 0 0x2 0>; /* To be filled by loader */
-	};
-};
-
-&serial0 {
-	status = "okay";
-};
-
-&serial2 {
-	status = "okay";
 };
 
 /*
@@ -55,9 +26,6 @@ &serial2 {
  * on-board devices and properties that are populated by the bootloader
  * (such as MAC addresses).
  */
-&port00 {
-	bus-range = <1 1>;
-};
 
 &port01 {
 	bus-range = <2 2>;
diff --git a/arch/arm64/boot/dts/apple/t8103-j293.dts b/arch/arm64/boot/dts/apple/t8103-j293.dts
new file mode 100644
index 000000000000..466035f00b69
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t8103-j293.dts
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * Apple MacBook Pro (13-inch, M1, 2020)
+ *
+ * target-type: J293
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t8103.dtsi"
+#include "t8103-jxxx.dtsi"
+
+/ {
+	compatible = "apple,j293", "apple,t8103", "apple,arm-platform";
+	model = "Apple MacBook Pro (13-inch, M1, 2020)";
+};
+
+/*
+ * Remove unused PCIe ports and disable the associated DARTs.
+ */
+
+&pcie0_dart_1 {
+	status = "disabled";
+};
+
+&pcie0_dart_2 {
+	status = "disabled";
+};
+
+/delete-node/ &port01;
+/delete-node/ &port02;
diff --git a/arch/arm64/boot/dts/apple/t8103-j313.dts b/arch/arm64/boot/dts/apple/t8103-j313.dts
new file mode 100644
index 000000000000..b0ebb45bdb6f
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t8103-j313.dts
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * Apple MacBook Air (M1, 2020)
+ *
+ * target-type: J313
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t8103.dtsi"
+#include "t8103-jxxx.dtsi"
+
+/ {
+	compatible = "apple,j313", "apple,t8103", "apple,arm-platform";
+	model = "Apple MacBook Air (M1, 2020)";
+};
+
+/*
+ * Remove unused PCIe ports and disable the associated DARTs.
+ */
+
+&pcie0_dart_1 {
+	status = "disabled";
+};
+
+&pcie0_dart_2 {
+	status = "disabled";
+};
+
+/delete-node/ &port01;
+/delete-node/ &port02;
diff --git a/arch/arm64/boot/dts/apple/t8103-j456.dts b/arch/arm64/boot/dts/apple/t8103-j456.dts
new file mode 100644
index 000000000000..7267e069355b
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t8103-j456.dts
@@ -0,0 +1,41 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * Apple iMac (24-inch, 4x USB-C, M1, 2020)
+ *
+ * target-type: J456
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t8103.dtsi"
+#include "t8103-jxxx.dtsi"
+
+/ {
+	compatible = "apple,j456", "apple,t8103", "apple,arm-platform";
+	model = "Apple iMac (24-inch, 4x USB-C, M1, 2020)";
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+};
+
+/*
+ * Force the bus number assignments so that we can declare some of the
+ * on-board devices and properties that are populated by the bootloader
+ * (such as MAC addresses).
+ */
+
+&port01 {
+	bus-range = <2 2>;
+};
+
+&port02 {
+	bus-range = <3 3>;
+	ethernet0: ethernet@0,0 {
+		reg = <0x30000 0x0 0x0 0x0 0x0>;
+		/* To be filled by the loader */
+		local-mac-address = [00 10 18 00 00 00];
+	};
+};
diff --git a/arch/arm64/boot/dts/apple/t8103-j457.dts b/arch/arm64/boot/dts/apple/t8103-j457.dts
new file mode 100644
index 000000000000..d7c622931627
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t8103-j457.dts
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * Apple iMac (24-inch, 2x USB-C, M1, 2020)
+ *
+ * target-type: J457
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/dts-v1/;
+
+#include "t8103.dtsi"
+#include "t8103-jxxx.dtsi"
+
+/ {
+	compatible = "apple,j457", "apple,t8103", "apple,arm-platform";
+	model = "Apple iMac (24-inch, 2x USB-C, M1, 2020)";
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+};
+
+/*
+ * Force the bus number assignments so that we can declare some of the
+ * on-board devices and properties that are populated by the bootloader
+ * (such as MAC addresses).
+ */
+
+&port02 {
+	bus-range = <3 3>;
+	ethernet0: ethernet@0,0 {
+		reg = <0x30000 0x0 0x0 0x0 0x0>;
+		/* To be filled by the loader */
+		local-mac-address = [00 10 18 00 00 00];
+	};
+};
+
+/*
+ * Remove unused PCIe port and disable the associated DART.
+ */
+
+&pcie0_dart_1 {
+	status = "disabled";
+};
+
+/delete-node/ &port01;
diff --git a/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
new file mode 100644
index 000000000000..5b464def327c
--- /dev/null
+++ b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: GPL-2.0+ OR MIT
+/*
+ * Apple M1 Mac mini, MacBook Air/Pro, iMac 24" (M1, 2020/2021)
+ *
+ * This file contains parts common to all Apple M1 devices using the t8103.
+ *
+ * target-type: J274, J293, J313, J456, J457
+ *
+ * Copyright The Asahi Linux Contributors
+ */
+
+/ {
+	aliases {
+		serial0 = &serial0;
+		serial2 = &serial2;
+	};
+
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		stdout-path = "serial0";
+
+		framebuffer0: framebuffer@0 {
+			compatible = "apple,simple-framebuffer", "simple-framebuffer";
+			reg = <0 0 0 0>; /* To be filled by loader */
+			/* Format properties will be added by loader */
+			status = "disabled";
+		};
+	};
+
+	memory@800000000 {
+		device_type = "memory";
+		reg = <0x8 0 0x2 0>; /* To be filled by loader */
+	};
+};
+
+&serial0 {
+	status = "okay";
+};
+
+&serial2 {
+	status = "okay";
+};
+
+/*
+ * Force the bus number assignments so that we can declare some of the
+ * on-board devices and properties that are populated by the bootloader
+ * (such as MAC addresses).
+ */
+&port00 {
+	bus-range = <1 1>;
+};
-- 
2.34.0


From 56d47269012ca4d921efe39674e6c490ab8ae404 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 19:35:57 +0100
Subject: [PATCH 61/83] arm64: dts: apple: t8103: Add i2c nodes

Apple M1 has at least 5 i2c controllers. i2c0, i2c1 and i2c3 are used
on all M1 Mac devices. The 2020 Mac Mini uses i2c2 and the 13-inch
MacBook Pro uses i2c2 and i2c4.

Signed-off-by: Janne Grunau <j@jannau.net>
Reviewed-by: Sven Peter <sven@svenpeter.dev>
Acked-by: Hector Martin <marcan@marcan.st>
---
 arch/arm64/boot/dts/apple/t8103-j274.dts |  4 ++
 arch/arm64/boot/dts/apple/t8103-j293.dts |  8 +++
 arch/arm64/boot/dts/apple/t8103.dtsi     | 92 ++++++++++++++++++++++++
 3 files changed, 104 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t8103-j274.dts b/arch/arm64/boot/dts/apple/t8103-j274.dts
index 9e01ef70039d..2cd429efba5b 100644
--- a/arch/arm64/boot/dts/apple/t8103-j274.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j274.dts
@@ -39,3 +39,7 @@ ethernet0: ethernet@0,0 {
 		local-mac-address = [00 10 18 00 00 00];
 	};
 };
+
+&i2c2 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/apple/t8103-j293.dts b/arch/arm64/boot/dts/apple/t8103-j293.dts
index 466035f00b69..49cdf4b560a3 100644
--- a/arch/arm64/boot/dts/apple/t8103-j293.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j293.dts
@@ -31,3 +31,11 @@ &pcie0_dart_2 {
 
 /delete-node/ &port01;
 /delete-node/ &port02;
+
+&i2c2 {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index e39b14971e68..bee134ae9396 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -111,6 +111,73 @@ soc {
 		ranges;
 		nonposted-mmio;
 
+		i2c0: i2c@235010000 {
+			compatible = "apple,t8103-i2c", "apple,i2c";
+			reg = <0x2 0x35010000 0x0 0x4000>;
+			clocks = <&clkref>;
+			power-domains = <&ps_i2c0>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 627 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c0_pins>;
+			pinctrl-names = "default";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+		};
+
+		i2c1: i2c@235014000 {
+			compatible = "apple,t8103-i2c", "apple,i2c";
+			reg = <0x2 0x35014000 0x0 0x4000>;
+			clocks = <&clkref>;
+			power-domains = <&ps_i2c1>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 628 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c1_pins>;
+			pinctrl-names = "default";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+		};
+
+		i2c2: i2c@235018000 {
+			compatible = "apple,t8103-i2c", "apple,i2c";
+			reg = <0x2 0x35018000 0x0 0x4000>;
+			clocks = <&clkref>;
+			power-domains = <&ps_i2c2>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 629 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c2_pins>;
+			pinctrl-names = "default";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			status = "disabled"; /* not used in all devices */
+		};
+
+		i2c3: i2c@23501c000 {
+			compatible = "apple,t8103-i2c", "apple,i2c";
+			reg = <0x2 0x3501c000 0x0 0x4000>;
+			clocks = <&clkref>;
+			power-domains = <&ps_i2c3>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 630 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c3_pins>;
+			pinctrl-names = "default";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+		};
+
+		i2c4: i2c@235020000 {
+			compatible = "apple,t8103-i2c", "apple,i2c";
+			reg = <0x2 0x35020000 0x0 0x4000>;
+			clocks = <&clkref>;
+			power-domains = <&ps_i2c4>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 631 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-0 = <&i2c4_pins>;
+			pinctrl-names = "default";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			status = "disabled"; /* only used in J293 */
+		};
+
 		serial0: serial@235200000 {
 			compatible = "apple,s5l-uart";
 			reg = <0x2 0x35200000 0x0 0x1000>;
@@ -175,6 +242,31 @@ pinctrl_ap: pinctrl@23c100000 {
 				     <AIC_IRQ 195 IRQ_TYPE_LEVEL_HIGH>,
 				     <AIC_IRQ 196 IRQ_TYPE_LEVEL_HIGH>;
 
+			i2c0_pins: i2c0-pins {
+				pinmux = <APPLE_PINMUX(192, 1)>,
+					 <APPLE_PINMUX(188, 1)>;
+			};
+
+			i2c1_pins: i2c1-pins {
+				pinmux = <APPLE_PINMUX(201, 1)>,
+					 <APPLE_PINMUX(199, 1)>;
+			};
+
+			i2c2_pins: i2c2-pins {
+				pinmux = <APPLE_PINMUX(163, 1)>,
+					 <APPLE_PINMUX(162, 1)>;
+			};
+
+			i2c3_pins: i2c3-pins {
+				pinmux = <APPLE_PINMUX(73, 1)>,
+					 <APPLE_PINMUX(72, 1)>;
+			};
+
+			i2c4_pins: i2c4-pins {
+				pinmux = <APPLE_PINMUX(135, 1)>,
+					 <APPLE_PINMUX(134, 1)>;
+			};
+
 			pcie_pins: pcie-pins {
 				pinmux = <APPLE_PINMUX(150, 1)>,
 					 <APPLE_PINMUX(151, 1)>,
-- 
2.34.0


From f816055f3f89e37070a583b2d64ed995e4c63d90 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 19 Nov 2021 19:35:57 +0100
Subject: [PATCH 62/83] arm64: dts: apple: t8103: Add cd321x nodes

All M1 Mac devices have 2 SoC connected USB-C ports and use cd321x USB
type C port switch and power deliver controllers. I2c bus and addresses
configuration are for all devices equal.
The iMac (24-inch, 2021) has a configuration with 2 additional USB-C
ports (j456) using two addiotional cd321x controllers.

Signed-off-by: Janne Grunau <j@jannau.net>
Reviewed-by: Sven Peter <sven@svenpeter.dev>
---
 arch/arm64/boot/dts/apple/t8103-j456.dts  | 18 ++++++++++++++++++
 arch/arm64/boot/dts/apple/t8103-jxxx.dtsi | 18 ++++++++++++++++++
 2 files changed, 36 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t8103-j456.dts b/arch/arm64/boot/dts/apple/t8103-j456.dts
index 7267e069355b..884fddf7d363 100644
--- a/arch/arm64/boot/dts/apple/t8103-j456.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j456.dts
@@ -21,6 +21,24 @@ aliases {
 	};
 };
 
+&i2c0 {
+	hpm2: usb-pd@3b {
+		compatible = "apple,cd321x";
+		reg = <0x3b>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <106 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+	};
+
+	hpm3: usb-pd@3c {
+		compatible = "apple,cd321x";
+		reg = <0x3c>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <106 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+	};
+};
+
 /*
  * Force the bus number assignments so that we can declare some of the
  * on-board devices and properties that are populated by the bootloader
diff --git a/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
index 5b464def327c..e11d5def94b4 100644
--- a/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
@@ -44,6 +44,24 @@ &serial2 {
 	status = "okay";
 };
 
+&i2c0 {
+	hpm0: usb-pd@38 {
+		compatible = "apple,cd321x";
+		reg = <0x38>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <106 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+	};
+
+	hpm1: usb-pd@3f {
+		compatible = "apple,cd321x";
+		reg = <0x3f>;
+		interrupt-parent = <&pinctrl_ap>;
+		interrupts = <106 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "irq";
+	};
+};
+
 /*
  * Force the bus number assignments so that we can declare some of the
  * on-board devices and properties that are populated by the bootloader
-- 
2.34.0


From ed63e6bbb775a2a869b8aa497eddba7f1d39c88f Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Sat, 20 Nov 2021 05:16:02 +0100
Subject: [PATCH 63/83] arm64: dts: apple: t8103: Add USB-C related nodes

This adds nodes for dwc3, the associtated DARTs and connectors for
the associtated cd321x USB-C PD controllers.

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t8103-j274.dts  | 12 ++++
 arch/arm64/boot/dts/apple/t8103-j293.dts  | 12 ++++
 arch/arm64/boot/dts/apple/t8103-j313.dts  | 12 ++++
 arch/arm64/boot/dts/apple/t8103-j456.dts  | 12 ++++
 arch/arm64/boot/dts/apple/t8103-j457.dts  | 12 ++++
 arch/arm64/boot/dts/apple/t8103-jxxx.dtsi | 34 +++++++++++
 arch/arm64/boot/dts/apple/t8103.dtsi      | 72 +++++++++++++++++++++++
 7 files changed, 166 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t8103-j274.dts b/arch/arm64/boot/dts/apple/t8103-j274.dts
index 2cd429efba5b..214476814797 100644
--- a/arch/arm64/boot/dts/apple/t8103-j274.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j274.dts
@@ -21,6 +21,18 @@ aliases {
 	};
 };
 
+/*
+ * Provide labels for the USB type C ports.
+ */
+
+&typec0 {
+	label = "USB-C Back-left";
+};
+
+&typec1 {
+	label = "USB-C Back-right";
+};
+
 /*
  * Force the bus number assignments so that we can declare some of the
  * on-board devices and properties that are populated by the bootloader
diff --git a/arch/arm64/boot/dts/apple/t8103-j293.dts b/arch/arm64/boot/dts/apple/t8103-j293.dts
index 49cdf4b560a3..6f08fd64f482 100644
--- a/arch/arm64/boot/dts/apple/t8103-j293.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j293.dts
@@ -17,6 +17,18 @@ / {
 	model = "Apple MacBook Pro (13-inch, M1, 2020)";
 };
 
+/*
+ * Provide labels for the USB type C ports.
+ */
+
+&typec0 {
+	label = "USB-C Left-back";
+};
+
+&typec1 {
+	label = "USB-C Left-front";
+};
+
 /*
  * Remove unused PCIe ports and disable the associated DARTs.
  */
diff --git a/arch/arm64/boot/dts/apple/t8103-j313.dts b/arch/arm64/boot/dts/apple/t8103-j313.dts
index b0ebb45bdb6f..114aa87c8cb4 100644
--- a/arch/arm64/boot/dts/apple/t8103-j313.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j313.dts
@@ -17,6 +17,18 @@ / {
 	model = "Apple MacBook Air (M1, 2020)";
 };
 
+/*
+ * Provide labels for the USB type C ports.
+ */
+
+&typec0 {
+	label = "USB-C Left-back";
+};
+
+&typec1 {
+	label = "USB-C Left-front";
+};
+
 /*
  * Remove unused PCIe ports and disable the associated DARTs.
  */
diff --git a/arch/arm64/boot/dts/apple/t8103-j456.dts b/arch/arm64/boot/dts/apple/t8103-j456.dts
index 884fddf7d363..9814c97cd9ba 100644
--- a/arch/arm64/boot/dts/apple/t8103-j456.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j456.dts
@@ -39,6 +39,18 @@ hpm3: usb-pd@3c {
 	};
 };
 
+/*
+ * Provide labels for the USB type C ports.
+ */
+
+&typec0 {
+	label = "USB-C Back-right";
+};
+
+&typec1 {
+	label = "USB-C Back-right-middle";
+};
+
 /*
  * Force the bus number assignments so that we can declare some of the
  * on-board devices and properties that are populated by the bootloader
diff --git a/arch/arm64/boot/dts/apple/t8103-j457.dts b/arch/arm64/boot/dts/apple/t8103-j457.dts
index d7c622931627..0f4cc643741c 100644
--- a/arch/arm64/boot/dts/apple/t8103-j457.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j457.dts
@@ -21,6 +21,18 @@ aliases {
 	};
 };
 
+/*
+ * Provide labels for the USB type C ports.
+ */
+
+&typec0 {
+	label = "USB-C Back-right";
+};
+
+&typec1 {
+	label = "USB-C Back-left";
+};
+
 /*
  * Force the bus number assignments so that we can declare some of the
  * on-board devices and properties that are populated by the bootloader
diff --git a/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
index e11d5def94b4..2f1a41d2ff1b 100644
--- a/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi
@@ -51,6 +51,23 @@ hpm0: usb-pd@38 {
 		interrupt-parent = <&pinctrl_ap>;
 		interrupts = <106 IRQ_TYPE_LEVEL_LOW>;
 		interrupt-names = "irq";
+
+		typec0: connector {
+			compatible = "usb-c-connector";
+			power-role = "dual";
+			data-role = "dual";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					typec0_con_hs: endpoint {
+						remote-endpoint = <&typec0_usb_hs>;
+					};
+				};
+			};
+		};
 	};
 
 	hpm1: usb-pd@3f {
@@ -59,6 +76,23 @@ hpm1: usb-pd@3f {
 		interrupt-parent = <&pinctrl_ap>;
 		interrupts = <106 IRQ_TYPE_LEVEL_LOW>;
 		interrupt-names = "irq";
+
+		typec1: connector {
+			compatible = "usb-c-connector";
+			power-role = "dual";
+			data-role = "dual";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					typec1_con_hs: endpoint {
+						remote-endpoint = <&typec1_usb_hs>;
+					};
+				};
+			};
+		};
 	};
 };
 
diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index bee134ae9396..6746737d5a28 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -345,6 +345,78 @@ pinctrl_smc: pinctrl@23e820000 {
 				     <AIC_IRQ 397 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
+		dwc3_0_dart_0: iommu@382f00000 {
+			compatible = "apple,t8103-dart";
+			reg = <0x3 0x82f00000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 781 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc0_usb>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_0_dart_1: iommu@382f80000 {
+			compatible = "apple,t8103-dart";
+			reg = <0x3 0x82f80000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 781 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc0_usb>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_0: usb@382280000 {
+			compatible = "apple,t8103-dwc3", "apple,dwc3", "snps,dwc3";
+			reg = <0x3 0x82280000 0x0 0x100000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 777 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc0_usb>;
+			dr_mode = "otg";
+			usb-role-switch;
+			role-switch-default-mode = "host";
+			iommus = <&dwc3_0_dart_0 0>, <&dwc3_0_dart_1 1>;
+
+			port {
+				typec0_usb_hs: endpoint {
+					remote-endpoint = <&typec0_con_hs>;
+				};
+			};
+		};
+
+		dwc3_1_dart_0: iommu@502f00000 {
+			compatible = "apple,t8103-dart";
+			reg = <0x5 0x02f00000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 861 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc1_usb>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_1_dart_1: iommu@502f80000 {
+			compatible = "apple,t8103-dart";
+			reg = <0x5 0x02f80000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 861 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc1_usb>;
+			#iommu-cells = <1>;
+		};
+
+		dwc3_1: usb@b02280000 {
+			compatible = "apple,t8103-dwc3", "apple,dwc3", "snps,dwc3";
+			reg = <0x5 0x02280000 0x0 0x100000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 857 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&ps_atc1_usb>;
+			dr_mode = "otg";
+			usb-role-switch;
+			role-switch-default-mode = "host";
+			iommus = <&dwc3_1_dart_0 0>, <&dwc3_1_dart_1 1>;
+
+			port {
+				typec1_usb_hs: endpoint {
+					remote-endpoint = <&typec1_con_hs>;
+				};
+			};
+		};
+
 		pcie0_dart_0: dart@681008000 {
 			compatible = "apple,t8103-dart";
 			reg = <0x6 0x81008000 0x0 0x4000>;
-- 
2.34.0


From aa929448681f6373e53f362ad3af05d94a637eab Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Sat, 20 Nov 2021 15:03:41 +0100
Subject: [PATCH 64/83] arm64: dts: apple: j274: add alias for ethernet PCI
 port

The 10 gigabit ethernet Mac Mini model uses different PCI port
properties. Most noteable it increases the "max-link-speed" from
1 to 4 lanes. With this alias m1n1 will adjust the properties based on
the apple device tree.

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t8103-j274.dts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm64/boot/dts/apple/t8103-j274.dts b/arch/arm64/boot/dts/apple/t8103-j274.dts
index 214476814797..1a5f6903ff7a 100644
--- a/arch/arm64/boot/dts/apple/t8103-j274.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j274.dts
@@ -18,6 +18,7 @@ / {
 
 	aliases {
 		ethernet0 = &ethernet0;
+		port02 = &port02; /* adjust properties for the 10GE model */
 	};
 };
 
-- 
2.34.0


From ab8679937b8751c956af6d1a1e949c877032cbe8 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Mon, 15 Nov 2021 19:23:30 +0100
Subject: [PATCH 65/83] dt-bindings: watchdog: Add Apple Watchdog

Apple SoCs come with a simple embedded watchdog. This watchdog is also
required in order to reset the SoC.

Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 .../bindings/watchdog/apple,wdt.yaml          | 52 +++++++++++++++++++
 MAINTAINERS                                   |  1 +
 2 files changed, 53 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/watchdog/apple,wdt.yaml

diff --git a/Documentation/devicetree/bindings/watchdog/apple,wdt.yaml b/Documentation/devicetree/bindings/watchdog/apple,wdt.yaml
new file mode 100644
index 000000000000..e58c56a6fdf6
--- /dev/null
+++ b/Documentation/devicetree/bindings/watchdog/apple,wdt.yaml
@@ -0,0 +1,52 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/watchdog/apple,wdt.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Apple SoC Watchdog
+
+allOf:
+  - $ref: "watchdog.yaml#"
+
+maintainers:
+  - Sven Peter <sven@svenpeter.dev>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - apple,t8103-wdt
+          - apple,t6000-wdt
+      - const: apple,wdt
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - interrupts
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/apple-aic.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+    wdt: watchdog@50000000 {
+        compatible = "apple,t8103-wdt", "apple,wdt";
+        reg = <0x50000000 0x4000>;
+        clocks = <&clk>;
+        interrupts = <AIC_IRQ 123 IRQ_TYPE_LEVEL_HIGH>;
+    };
+
+...
diff --git a/MAINTAINERS b/MAINTAINERS
index 29314357908c..6dad3a36555c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1751,6 +1751,7 @@ F:	Documentation/devicetree/bindings/mailbox/apple,mailbox.yaml
 F:	Documentation/devicetree/bindings/pci/apple,pcie.yaml
 F:	Documentation/devicetree/bindings/pinctrl/apple,pinctrl.yaml
 F:	Documentation/devicetree/bindings/usb/apple,dwc3.yaml
+F:	Documentation/devicetree/bindings/watchdog/apple,wdt.yaml
 F:	arch/arm64/boot/dts/apple/
 F:	drivers/i2c/busses/i2c-pasemi-core.c
 F:	drivers/i2c/busses/i2c-pasemi-platform.c
-- 
2.34.0


From 59f4f75d35dd54efcb0777863cf066f859517609 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Mon, 15 Nov 2021 19:23:31 +0100
Subject: [PATCH 66/83] watchdog: Add Apple SoC watchdog driver

Add support for the watchdog timer found in Apple SoCs. This driver is
also required to reboot these machines.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 MAINTAINERS                  |   1 +
 drivers/watchdog/Kconfig     |  12 ++
 drivers/watchdog/Makefile    |   1 +
 drivers/watchdog/apple_wdt.c | 227 +++++++++++++++++++++++++++++++++++
 4 files changed, 241 insertions(+)
 create mode 100644 drivers/watchdog/apple_wdt.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 6dad3a36555c..862fe932ef77 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1758,6 +1758,7 @@ F:	drivers/i2c/busses/i2c-pasemi-platform.c
 F:	drivers/irqchip/irq-apple-aic.c
 F:	drivers/mailbox/apple-mailbox.c
 F:	drivers/pinctrl/pinctrl-apple-gpio.c
+F:	drivers/watchdog/apple_wdt.c
 F:	include/dt-bindings/interrupt-controller/apple-aic.h
 F:	include/dt-bindings/pinctrl/apple.h
 F:	include/linux/apple-mailbox.h
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 9d222ba17ec6..170dec880c8f 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -976,6 +976,18 @@ config MSC313E_WATCHDOG
 	  To compile this driver as a module, choose M here: the
 	  module will be called msc313e_wdt.
 
+config APPLE_WATCHDOG
+	tristate "Apple SoC watchdog"
+	depends on ARCH_APPLE || COMPILE_TEST
+	select WATCHDOG_CORE
+	help
+	  Say Y here to include support for the Watchdog found in Apple
+	  SoCs such as the M1. Next to the common watchdog features this
+	  driver is also required in order to reboot these SoCs.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called apple_wdt.
+
 # X86 (i386 + ia64 + x86_64) Architecture
 
 config ACQUIRE_WDT
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 2ee97064145b..270a518bd8f3 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -93,6 +93,7 @@ obj-$(CONFIG_PM8916_WATCHDOG) += pm8916_wdt.o
 obj-$(CONFIG_ARM_SMC_WATCHDOG) += arm_smc_wdt.o
 obj-$(CONFIG_VISCONTI_WATCHDOG) += visconti_wdt.o
 obj-$(CONFIG_MSC313E_WATCHDOG) += msc313e_wdt.o
+obj-$(CONFIG_APPLE_WATCHDOG) += apple_wdt.o
 
 # X86 (i386 + ia64 + x86_64) Architecture
 obj-$(CONFIG_ACQUIRE_WDT) += acquirewdt.o
diff --git a/drivers/watchdog/apple_wdt.c b/drivers/watchdog/apple_wdt.c
new file mode 100644
index 000000000000..cc77336a82b4
--- /dev/null
+++ b/drivers/watchdog/apple_wdt.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0-only OR MIT
+/*
+ * Apple SoC Watchdog driver
+ *
+ * Copyright (C) The Asahi Linux Contributors
+ */
+
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/watchdog.h>
+
+/*
+ * Apple Watchdog MMIO registers
+ *
+ * This HW block has three separate watchdogs. WD0 resets the machine
+ * to recovery mode and is not very useful for us. WD1 and WD2 trigger a normal
+ * machine reset. WD0 additionally supports a configurable interrupt.
+ * This information can be used to implement pretimeout support at a later time.
+ *
+ * APPLE_WDT_WDx_CUR_TIME is a simple counter incremented for each tick of the
+ * reference clock. It can also be overwritten to any value.
+ * Whenever APPLE_WDT_CTRL_RESET_EN is set in APPLE_WDT_WDx_CTRL and
+ * APPLE_WDTx_WD1_CUR_TIME >= APPLE_WDTx_WD1_BITE_TIME the entire machine is
+ * reset.
+ * Whenever APPLE_WDT_CTRL_IRQ_EN is set and APPLE_WDTx_WD1_CUR_TIME >=
+ * APPLE_WDTx_WD1_BARK_TIME an interrupt is triggered and
+ * APPLE_WDT_CTRL_IRQ_STATUS is set. The interrupt can be cleared by writing
+ * 1 to APPLE_WDT_CTRL_IRQ_STATUS.
+ */
+#define APPLE_WDT_WD0_CUR_TIME		0x00
+#define APPLE_WDT_WD0_BITE_TIME		0x04
+#define APPLE_WDT_WD0_BARK_TIME		0x08
+#define APPLE_WDT_WD0_CTRL		0x0c
+
+#define APPLE_WDT_WD1_CUR_TIME		0x10
+#define APPLE_WDT_WD1_BITE_TIME		0x14
+#define APPLE_WDT_WD1_CTRL		0x1c
+
+#define APPLE_WDT_WD2_CUR_TIME		0x20
+#define APPLE_WDT_WD2_BITE_TIME		0x24
+#define APPLE_WDT_WD2_CTRL		0x2c
+
+#define APPLE_WDT_CTRL_IRQ_EN		BIT(0)
+#define APPLE_WDT_CTRL_IRQ_STATUS	BIT(1)
+#define APPLE_WDT_CTRL_RESET_EN		BIT(2)
+
+#define APPLE_WDT_TIMEOUT_DEFAULT	30
+
+struct apple_wdt {
+	struct watchdog_device wdd;
+	void __iomem *regs;
+	unsigned long clk_rate;
+};
+
+static struct apple_wdt *to_apple_wdt(struct watchdog_device *wdd)
+{
+	return container_of(wdd, struct apple_wdt, wdd);
+}
+
+static int apple_wdt_start(struct watchdog_device *wdd)
+{
+	struct apple_wdt *wdt = to_apple_wdt(wdd);
+
+	writel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);
+	writel_relaxed(APPLE_WDT_CTRL_RESET_EN, wdt->regs + APPLE_WDT_WD1_CTRL);
+
+	return 0;
+}
+
+static int apple_wdt_stop(struct watchdog_device *wdd)
+{
+	struct apple_wdt *wdt = to_apple_wdt(wdd);
+
+	writel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CTRL);
+
+	return 0;
+}
+
+static int apple_wdt_ping(struct watchdog_device *wdd)
+{
+	struct apple_wdt *wdt = to_apple_wdt(wdd);
+
+	writel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);
+
+	return 0;
+}
+
+static int apple_wdt_set_timeout(struct watchdog_device *wdd, unsigned int s)
+{
+	struct apple_wdt *wdt = to_apple_wdt(wdd);
+
+	writel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);
+	writel_relaxed(wdt->clk_rate * s, wdt->regs + APPLE_WDT_WD1_BITE_TIME);
+
+	wdd->timeout = s;
+
+	return 0;
+}
+
+static unsigned int apple_wdt_get_timeleft(struct watchdog_device *wdd)
+{
+	struct apple_wdt *wdt = to_apple_wdt(wdd);
+	u32 cur_time, reset_time;
+
+	cur_time = readl_relaxed(wdt->regs + APPLE_WDT_WD1_CUR_TIME);
+	reset_time = readl_relaxed(wdt->regs + APPLE_WDT_WD1_BITE_TIME);
+
+	return (reset_time - cur_time) / wdt->clk_rate;
+}
+
+static int apple_wdt_restart(struct watchdog_device *wdd, unsigned long mode,
+			     void *cmd)
+{
+	struct apple_wdt *wdt = to_apple_wdt(wdd);
+
+	writel_relaxed(APPLE_WDT_CTRL_RESET_EN, wdt->regs + APPLE_WDT_WD1_CTRL);
+	writel_relaxed(0, wdt->regs + APPLE_WDT_WD1_BITE_TIME);
+	writel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);
+
+	/*
+	 * Flush writes and then wait for the SoC to reset. Even though the
+	 * reset is queued almost immediately experiments have shown that it
+	 * can take up to ~20-25ms until the SoC is actually reset. Just wait
+	 * 50ms here to be safe.
+	 */
+	(void)readl_relaxed(wdt->regs + APPLE_WDT_WD1_CUR_TIME);
+	mdelay(50);
+
+	return 0;
+}
+
+static void apple_wdt_clk_disable_unprepare(void *data)
+{
+	clk_disable_unprepare(data);
+}
+
+static struct watchdog_ops apple_wdt_ops = {
+	.owner = THIS_MODULE,
+	.start = apple_wdt_start,
+	.stop = apple_wdt_stop,
+	.ping = apple_wdt_ping,
+	.set_timeout = apple_wdt_set_timeout,
+	.get_timeleft = apple_wdt_get_timeleft,
+	.restart = apple_wdt_restart,
+};
+
+static struct watchdog_info apple_wdt_info = {
+	.identity = "Apple SoC Watchdog",
+	.options = WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT,
+};
+
+static int apple_wdt_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct apple_wdt *wdt;
+	struct clk *clk;
+	u32 wdt_ctrl;
+	int ret;
+
+	wdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);
+	if (!wdt)
+		return -ENOMEM;
+
+	wdt->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(wdt->regs))
+		return PTR_ERR(wdt->regs);
+
+	clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		return ret;
+
+	ret = devm_add_action_or_reset(dev, apple_wdt_clk_disable_unprepare,
+				       clk);
+	if (ret)
+		return ret;
+
+	wdt->clk_rate = clk_get_rate(clk);
+	if (!wdt->clk_rate)
+		return -EINVAL;
+
+	wdt->wdd.ops = &apple_wdt_ops;
+	wdt->wdd.info = &apple_wdt_info;
+	wdt->wdd.max_timeout = U32_MAX / wdt->clk_rate;
+	wdt->wdd.timeout = min((unsigned int)APPLE_WDT_TIMEOUT_DEFAULT,
+			       wdt->wdd.max_timeout);
+
+	wdt_ctrl = readl_relaxed(wdt->regs + APPLE_WDT_WD1_CTRL);
+	if (wdt_ctrl & APPLE_WDT_CTRL_RESET_EN)
+		set_bit(WDOG_HW_RUNNING, &wdt->wdd.status);
+
+	watchdog_init_timeout(&wdt->wdd, 0, dev);
+	apple_wdt_set_timeout(&wdt->wdd, wdt->wdd.timeout);
+	watchdog_stop_on_unregister(&wdt->wdd);
+	watchdog_set_restart_priority(&wdt->wdd, 128);
+
+	return devm_watchdog_register_device(dev, &wdt->wdd);
+}
+
+static const struct of_device_id apple_wdt_of_match[] = {
+	{ .compatible = "apple,wdt" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, apple_wdt_of_match);
+
+static struct platform_driver apple_wdt_driver = {
+	.driver = {
+		.name = "apple-watchdog",
+		.of_match_table = apple_wdt_of_match,
+	},
+	.probe = apple_wdt_probe,
+};
+module_platform_driver(apple_wdt_driver);
+
+MODULE_DESCRIPTION("Apple SoC watchdog driver");
+MODULE_AUTHOR("Sven Peter <sven@svenpeter.dev>");
+MODULE_LICENSE("Dual MIT/GPL");
-- 
2.34.0


From a712390892884d2f0b4252508752cd9bbc89fdd9 Mon Sep 17 00:00:00 2001
From: Sven Peter <sven@svenpeter.dev>
Date: Mon, 15 Nov 2021 19:23:32 +0100
Subject: [PATCH 67/83] arm64: dts: apple: t8103: Add watchdog node

Add the watchdog node which also enables reboot support on the t8103.

Signed-off-by: Sven Peter <sven@svenpeter.dev>
---
 arch/arm64/boot/dts/apple/t8103.dtsi | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index 6746737d5a28..3b2472c0fedf 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -324,6 +324,14 @@ pinctrl_nub: pinctrl@23d1f0000 {
 				     <AIC_IRQ 336 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
+		wdt: watchdog@23d2b0000 {
+			compatible = "apple,t8103-wdt", "apple,wdt";
+			reg = <0x2 0x3d2b0000 0x0 0x4000>;
+			clocks = <&clkref>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 338 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		pinctrl_smc: pinctrl@23e820000 {
 			compatible = "apple,t8103-pinctrl", "apple,pinctrl";
 			reg = <0x2 0x3e820000 0x0 0x4000>;
-- 
2.34.0


From d2544443209068e34f3295d215cbaf78b22cd748 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Sun, 14 Nov 2021 09:56:43 +0100
Subject: [PATCH 68/83] arm64: dts: apple: t6001: add watchdog node

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index c703e95fabe6..0804e9296071 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -207,6 +207,14 @@ pmgr_mini: power-management@292280000 {
 			reg = <0x2 0x92280000 0 0x4000>;
 		};
 
+		wdt: watchdog@2922b0000 {
+			compatible = "apple,t6000-wdt", "apple,wdt";
+			reg = <0x2 0x922b0000 0x0 0x4000>;
+			clocks = <&clkref>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 631 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		pinctrl_aop: pinctrl@293820000 {
 			compatible = "apple,t6000-pinctrl", "apple,pinctrl";
 			reg = <0x2 0x93820000 0x0 0x4000>;
-- 
2.34.0


From f2e61d1022b630397d3ce16fbaa8c8e4f3b18a8e Mon Sep 17 00:00:00 2001
From: Marc Zyngier <maz@kernel.org>
Date: Tue, 23 Nov 2021 18:06:34 +0000
Subject: [PATCH 69/83] PCI: apple: Follow the PCIe specifications when
 resetting the port
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

While the Apple PCIe driver works correctly when directly booted
from the firmware, it fails to initialise when the kernel is booted
from a bootloader using PCIe such as u-boot.

That's beacuse we're missing a proper reset of the port (we only
clear the reset, but never assert it).

The PCIe spec requirements are two-fold:

- #PERST must be asserted before setting up the clocks, and
  stay asserted for at least 100us (Tperst-clk).

- Once #PERST is deasserted, the OS must wait for at least 100ms
  "from the end of a Conventional Reset" before we can start talking
  to the devices

Implementing this results in a booting system.

Fixes: 1e33888fbe44 ("PCI: apple: Add initial hardware bring-up")
Acked-by: Pali Rohár <pali@kernel.org>
Signed-off-by: Marc Zyngier <maz@kernel.org>
Cc: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Cc: Bjorn Helgaas <bhelgaas@google.com>
---
 drivers/pci/controller/pcie-apple.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/drivers/pci/controller/pcie-apple.c b/drivers/pci/controller/pcie-apple.c
index d51cec10732e..f73003329f91 100644
--- a/drivers/pci/controller/pcie-apple.c
+++ b/drivers/pci/controller/pcie-apple.c
@@ -590,13 +590,23 @@ static int apple_pcie_setup_port(struct apple_pcie *pcie,
 
 	rmw_set(PORT_APPCLK_EN, port->base + PORT_APPCLK);
 
+	/* Engage #PERST before setting up the clock */
+	gpiod_set_value(reset, 0);
+
 	ret = apple_pcie_setup_refclk(pcie, port);
 	if (ret < 0)
 		return ret;
 
+	/* The minimal Tperst-clk value is 100us (PCIe CMS r2.0, 2.6.2) */
+	usleep_range(100, 200);
+
+	/* Deassert #PERST */
 	rmw_set(PORT_PERST_OFF, port->base + PORT_PERST);
 	gpiod_set_value(reset, 1);
 
+	/* Wait for 100ms after #PERST deassertion (PCIe r2.0, 6.6.1) */
+	msleep(100);
+
 	ret = readl_relaxed_poll_timeout(port->base + PORT_STATUS, stat,
 					 stat & PORT_STATUS_READY, 100, 250000);
 	if (ret < 0) {
-- 
2.34.0


From c945fc964abe96cb517090d7c2b3bc86bf30c0b3 Mon Sep 17 00:00:00 2001
From: Marc Zyngier <maz@kernel.org>
Date: Tue, 23 Nov 2021 18:06:35 +0000
Subject: [PATCH 70/83] arm64: dts: apple: t8103: Fix PCIe #PERST polarity

As the name indicates, #PERST is active low. So fix the DT description
to match the HW behaviour.

Fixes: ff2a8d91d80c ("arm64: apple: Add PCIe node")
Signed-off-by: Marc Zyngier <maz@kernel.org>
---
 arch/arm64/boot/dts/apple/t8103.dtsi | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index 3b2472c0fedf..0fdd9945041a 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -7,6 +7,7 @@
  * Copyright The Asahi Linux Contributors
  */
 
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/interrupt-controller/apple-aic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/pinctrl/apple.h>
@@ -491,7 +492,7 @@ pcie0: pcie@690000000 {
 			port00: pci@0,0 {
 				device_type = "pci";
 				reg = <0x0 0x0 0x0 0x0 0x0>;
-				reset-gpios = <&pinctrl_ap 152 0>;
+				reset-gpios = <&pinctrl_ap 152 GPIO_ACTIVE_LOW>;
 				max-link-speed = <2>;
 
 				#address-cells = <3>;
@@ -511,7 +512,7 @@ port00: pci@0,0 {
 			port01: pci@1,0 {
 				device_type = "pci";
 				reg = <0x800 0x0 0x0 0x0 0x0>;
-				reset-gpios = <&pinctrl_ap 153 0>;
+				reset-gpios = <&pinctrl_ap 153 GPIO_ACTIVE_LOW>;
 				max-link-speed = <2>;
 
 				#address-cells = <3>;
@@ -531,7 +532,7 @@ port01: pci@1,0 {
 			port02: pci@2,0 {
 				device_type = "pci";
 				reg = <0x1000 0x0 0x0 0x0 0x0>;
-				reset-gpios = <&pinctrl_ap 33 0>;
+				reset-gpios = <&pinctrl_ap 33 GPIO_ACTIVE_LOW>;
 				max-link-speed = <1>;
 
 				#address-cells = <3>;
-- 
2.34.0


From fa57a1eeb1ede8bbe7d9b92f09b232e07985f053 Mon Sep 17 00:00:00 2001
From: Marc Zyngier <maz@kernel.org>
Date: Tue, 23 Nov 2021 18:06:36 +0000
Subject: [PATCH 71/83] PCI: apple: Fix #PERST polarity
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Now that #PERST is properly defined as active-low in the device tree,
fix the driver to correctly drive the line indemendently of the
implied polarity.

Fixes: 1e33888fbe44 ("PCI: apple: Add initial hardware bring-up")
Suggested-by: Pali Rohár <pali@kernel.org>
Signed-off-by: Marc Zyngier <maz@kernel.org>
---
 drivers/pci/controller/pcie-apple.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/controller/pcie-apple.c b/drivers/pci/controller/pcie-apple.c
index f73003329f91..3ab895e5c7dd 100644
--- a/drivers/pci/controller/pcie-apple.c
+++ b/drivers/pci/controller/pcie-apple.c
@@ -591,7 +591,7 @@ static int apple_pcie_setup_port(struct apple_pcie *pcie,
 	rmw_set(PORT_APPCLK_EN, port->base + PORT_APPCLK);
 
 	/* Engage #PERST before setting up the clock */
-	gpiod_set_value(reset, 0);
+	gpiod_set_value(reset, 1);
 
 	ret = apple_pcie_setup_refclk(pcie, port);
 	if (ret < 0)
@@ -602,7 +602,7 @@ static int apple_pcie_setup_port(struct apple_pcie *pcie,
 
 	/* Deassert #PERST */
 	rmw_set(PORT_PERST_OFF, port->base + PORT_PERST);
-	gpiod_set_value(reset, 1);
+	gpiod_set_value(reset, 0);
 
 	/* Wait for 100ms after #PERST deassertion (PCIe r2.0, 6.6.1) */
 	msleep(100);
-- 
2.34.0


From 544bd5e21e2760dc329cba50506507ee9c562f7c Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 22:48:07 +0100
Subject: [PATCH 72/83] WIP: bindings/soc/apple/apple,sart: add t6000

Signed-off-by: Janne Grunau <j@jannau.net>
---
 Documentation/devicetree/bindings/soc/apple/apple,sart.yaml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
index 5114c2bd415f..c95fbec7adb4 100644
--- a/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
+++ b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
@@ -19,7 +19,9 @@ description:
 
 properties:
   compatible:
-    const: apple,t8103-sart
+    enum:
+      - apple,t6000-sart
+      - apple,t8103-sart
 
   reg:
     maxItems: 1
-- 
2.34.0


From 137f82303a40ae845eb793d847da0df21fd94746 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 22:49:12 +0100
Subject: [PATCH 73/83] WIP: bindings/soc/apple/apple,sart: add power-domains
 property

Signed-off-by: Janne Grunau <j@jannau.net>
---
 Documentation/devicetree/bindings/soc/apple/apple,sart.yaml | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
index c95fbec7adb4..b115bef5701c 100644
--- a/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
+++ b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
@@ -31,6 +31,9 @@ properties:
       Reference to the clock gate phandle(s) if required before accessing
       the MMIO region of this SART.
 
+  power-domains:
+    maxItems: 1
+
 required:
   - compatible
   - reg
-- 
2.34.0


From 480af548e3ff3ad43e242c87d18d8ad2dce0cc07 Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 25 Nov 2021 22:49:45 +0100
Subject: [PATCH 74/83] WIP: bindings/soc/apple/apple,sart: fix example

Signed-off-by: Janne Grunau <j@jannau.net>
---
 Documentation/devicetree/bindings/soc/apple/apple,sart.yaml | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
index b115bef5701c..adff7cad5230 100644
--- a/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
+++ b/Documentation/devicetree/bindings/soc/apple/apple,sart.yaml
@@ -42,7 +42,12 @@ additionalProperties: false
 
 examples:
   - |
+      soc {
+        #address-cells = <2>;
+        #size-cells = <2>;
+
         sart@7bc50000 {
                 compatible = "apple,t8103-sart";
                 reg = <0x2 0x7bc50000 0x0 0x10000>;
         };
+      };
-- 
2.34.0


From 62db4044806d9c855b600886840a893f3fdf02c1 Mon Sep 17 00:00:00 2001
From: Stan Skowronek <stan@corellium.com>
Date: Sun, 24 Jan 2021 20:12:05 -0500
Subject: [PATCH 75/83] Add support for SPI controller with its Flash chip.

Signed-off-by: Stan Skowronek <stan@corellium.com>

[joey: removed dts file]
[joey: cherry picked 5c9a88e4c6e96cccb6d0e5fe901bdff67fa11d46 from
corellium/linux-m1]
---
 drivers/spi/Kconfig        |   7 +
 drivers/spi/Makefile       |   1 +
 drivers/spi/spi-apple-mc.c | 397 +++++++++++++++++++++++++++++++++++++
 3 files changed, 405 insertions(+)
 create mode 100644 drivers/spi/spi-apple-mc.c

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 596705d24400..55b3dc8b7eef 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -79,6 +79,13 @@ config SPI_ALTERA_DFL
 	  Altera SPI master controller.  The SPI master is connected
 	  to a SPI slave to Avalon bridge in a Intel MAX BMC.
 
+config SPI_APPLE_MC
+	tristate "Apple ARM SoC SPI-MC controller"
+	depends on GPIOLIB
+	help
+	  This is the driver for SPI controller found in new Apple ARM SoCs,
+	  including the M1.
+
 config SPI_AR934X
 	tristate "Qualcomm Atheros AR934X/QCA95XX SPI controller driver"
 	depends on ATH79 || COMPILE_TEST
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index dd7393a6046f..1acd821e9ba4 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera-platform.o
 obj-$(CONFIG_SPI_ALTERA_CORE)		+= spi-altera-core.o
 obj-$(CONFIG_SPI_ALTERA_DFL)		+= spi-altera-dfl.o
+obj-$(CONFIG_SPI_APPLE_MC)		+= spi-apple-mc.o
 obj-$(CONFIG_SPI_AR934X)		+= spi-ar934x.o
 obj-$(CONFIG_SPI_ARMADA_3700)		+= spi-armada-3700.o
 obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
diff --git a/drivers/spi/spi-apple-mc.c b/drivers/spi/spi-apple-mc.c
new file mode 100644
index 000000000000..af527633113e
--- /dev/null
+++ b/drivers/spi/spi-apple-mc.c
@@ -0,0 +1,397 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * SPIMC controller driver for Apple M1 SoC
+ *
+ * Copyright (C) 2020-21 Corellium LLC
+ *
+ * Based on spi-mt7621.c
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/reset.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio/consumer.h>
+
+#define REG_CLKCFG			0x00
+#define  REG_CLKCFG_ENABLE		0xD
+#define REG_CONFIG			0x04
+#define  REG_CONFIG_AUTOTX		BIT(0)
+#define  REG_CONFIG_PIOEN		BIT(5)
+#define  REG_CONFIG_IE_RXRDY		BIT(7)
+#define  REG_CONFIG_IE_TXEMPTY		BIT(8)
+#define  REG_CONFIG_IE_COMPL		BIT(21)
+#define  REG_CONFIG_SET			0x00040000
+#define REG_STATUS			0x08
+#define  REG_STATUS_RXRDY		BIT(0)
+#define  REG_STATUS_TXEMPTY		BIT(1)
+#define  REG_STATUS_COMPL		BIT(22)
+#define REG_PIN				0x0C
+#define  REG_PIN_CS			BIT(1)
+#define REG_TXDATA			0x10
+#define REG_RXDATA			0x20
+#define REG_CLKDIV			0x30
+#define  REG_CLKDIV_MAX			2047
+#define REG_RXCNT			0x34
+#define REG_CLKIDLE			0x38
+#define REG_TXCNT			0x4C
+#define REG_AVAIL			0x10C
+#define  REG_AVAIL_TXFIFO_MASK		(255 << 8)
+#define   REG_AVAIL_TXFIFO_SHIFT	8
+#define  REG_AVAIL_RXFIFO_MASK		(255 << 24)
+#define   REG_AVAIL_RXFIFO_SHIFT	24
+#define REG_HWDLY_CFG			0x150
+#define  REG_HWDLY_CFG_EN		BIT(24)
+#define REG_SPCON			0x154
+#define  REG_SPCON_MODE			BIT(8)
+#define REG_HWDLY_PRE			0x160
+#define  REG_HWDLY_PRE_EN		BIT(0)
+#define  REG_HWDLY_PRE_MAGIC		0x823
+#define  REG_HWDLY_PRE_SHIFT		16
+#define REG_HWDLY_POST			0x168
+#define  REG_HWDLY_POST_EN		BIT(0)
+#define  REG_HWDLY_POST_MAGIC		0x423
+#define  REG_HWDLY_POST_SHIFT		16
+#define REG_HWDLY_POST_2		0x194
+
+#define TIMEOUT_MS			1000
+
+#define FIFO_SIZE			16
+
+struct apple_spimc {
+	struct spi_controller *master;
+	void __iomem *base;
+	unsigned int clkfreq;
+	unsigned int speed;
+	struct clk *clk;
+	struct gpio_descs *csgpio;
+
+	spinlock_t lock;
+	const unsigned char *tx_buf;
+	unsigned char *rx_buf;
+	unsigned int tx_compl, rx_compl, len;
+	struct completion done;
+};
+
+static inline struct apple_spimc *spidev_to_apple_spimc(struct spi_device *spi)
+{
+	return spi_controller_get_devdata(spi->master);
+}
+
+static void apple_spimc_continue_tx(struct apple_spimc *spi, unsigned avail)
+{
+	unsigned maxtx = (avail & REG_AVAIL_TXFIFO_MASK) >> REG_AVAIL_TXFIFO_SHIFT;
+	unsigned data;
+	unsigned cfg;
+
+	maxtx = FIFO_SIZE - maxtx;
+	while(spi->tx_compl < spi->len && maxtx) {
+		if(spi->tx_buf)
+			data = spi->tx_buf[spi->tx_compl];
+		else
+			data = 0x00;
+		writel(data, spi->base + REG_TXDATA);
+		spi->tx_compl ++;
+		maxtx --;
+	}
+
+	cfg = REG_CONFIG_SET | REG_CONFIG_PIOEN | REG_CONFIG_IE_RXRDY;
+	if(spi->tx_compl < spi->len)
+		cfg |= REG_CONFIG_IE_TXEMPTY;
+	writel(cfg, spi->base + REG_CONFIG);
+}
+
+static int apple_spimc_continue_rx(struct apple_spimc *spi, unsigned avail)
+{
+	unsigned maxrx = (avail & REG_AVAIL_RXFIFO_MASK) >> REG_AVAIL_RXFIFO_SHIFT;
+	unsigned data;
+
+	while(spi->rx_compl < spi->len && maxrx) {
+		data = readl(spi->base + REG_RXDATA);
+		if(spi->rx_buf)
+			spi->rx_buf[spi->rx_compl] = data;
+		spi->rx_compl ++;
+		maxrx --;
+	}
+
+	if(spi->rx_compl >= spi->len) {
+		writel(REG_CONFIG_SET, spi->base + REG_CONFIG);
+		writel(REG_STATUS_COMPL | REG_STATUS_TXEMPTY | REG_STATUS_RXRDY,
+			spi->base + REG_STATUS);
+		return 1;
+	}
+	return 0;
+}
+
+static irqreturn_t apple_spimc_irq(int irq, void *dev_id)
+{
+	struct apple_spimc *spi = dev_id;
+	unsigned long flags;
+	unsigned status, avail;
+
+	spin_lock_irqsave(&spi->lock, flags);
+
+	status = readl(spi->base + REG_STATUS);
+	avail = readl(spi->base + REG_AVAIL);
+	writel(status, spi->base + REG_STATUS);
+
+	apple_spimc_continue_tx(spi, avail);
+
+	if(apple_spimc_continue_rx(spi, avail))
+		complete(&spi->done);
+
+	spin_unlock_irqrestore(&spi->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void apple_spimc_set_cs(struct spi_device *spid, int enable)
+{
+	struct apple_spimc *spi = spidev_to_apple_spimc(spid);
+	int cs = spid->chip_select;
+
+	if(!spi->csgpio || cs >= spi->csgpio->ndescs)
+		return;
+
+	gpiod_direction_output(spi->csgpio->desc[cs], enable);
+}
+
+static int apple_spimc_prepare(struct spi_device *spid, unsigned int speed)
+{
+	struct apple_spimc *spi = spidev_to_apple_spimc(spid);
+	u32 rate, avail;
+
+	rate = DIV_ROUND_UP(spi->clkfreq, speed);
+	if(rate > REG_CLKDIV_MAX + 1)
+		return -EINVAL;
+	if(rate < 2)
+		rate = 2;
+
+	writel(0, spi->base + REG_CLKCFG);
+	writel(0, spi->base + REG_PIN);
+
+	if(readl(spi->base + REG_RXCNT))
+		writel(0, spi->base + REG_RXCNT);
+	avail = readl(spi->base + REG_AVAIL);
+	avail = (avail & REG_AVAIL_RXFIFO_MASK) >> REG_AVAIL_RXFIFO_SHIFT;
+	while(avail --)
+		readl(spi->base + REG_RXDATA);
+
+	writel(REG_STATUS_COMPL | REG_STATUS_TXEMPTY | REG_STATUS_RXRDY, spi->base + REG_STATUS);
+	writel(rate, spi->base + REG_CLKDIV);
+	writel(0, spi->base + REG_CLKIDLE);
+	writel(REG_STATUS_COMPL | REG_STATUS_TXEMPTY | REG_STATUS_RXRDY, spi->base + REG_STATUS);
+	writel(readl(spi->base + REG_SPCON) & ~REG_SPCON_MODE, spi->base + REG_SPCON);
+	writel(REG_CONFIG_SET, spi->base + REG_CONFIG);
+	writel(readl(spi->base + REG_HWDLY_CFG) & ~REG_HWDLY_CFG_EN, spi->base + REG_HWDLY_CFG);
+	writel(readl(spi->base + REG_HWDLY_PRE) & ~REG_HWDLY_PRE_EN, spi->base + REG_HWDLY_PRE);
+	writel(readl(spi->base + REG_HWDLY_POST) & ~REG_HWDLY_POST_EN, spi->base + REG_HWDLY_POST);
+	readl(spi->base + REG_CONFIG);
+
+	spi->speed = speed;
+
+	return 0;
+}
+
+static int apple_spimc_transfer_one_message(struct spi_controller *master, struct spi_message *m)
+{
+	unsigned long timeout = msecs_to_jiffies(TIMEOUT_MS);
+	struct apple_spimc *spi = spi_controller_get_devdata(master);
+	struct spi_device *spid = m->spi;
+	unsigned int speed = spid->max_speed_hz;
+	struct spi_transfer *t = NULL;
+	int status = 0;
+	unsigned long flags;
+
+	list_for_each_entry(t, &m->transfers, transfer_list)
+		if(t->speed_hz < speed)
+			speed = t->speed_hz;
+
+	if(apple_spimc_prepare(spid, speed)) {
+		status = -EIO;
+		goto msg_done;
+	}
+
+	apple_spimc_set_cs(spid, 1);
+
+	m->actual_length = 0;
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		spin_lock_irqsave(&spi->lock, flags);
+
+		reinit_completion(&spi->done);
+
+		spi->len = t->len;
+		spi->tx_compl = spi->rx_compl = 0;
+		spi->tx_buf = t->tx_buf;
+		spi->rx_buf = t->rx_buf;
+
+		writel(t->len, spi->base + REG_RXCNT);
+		writel(t->len, spi->base + REG_TXCNT);
+		writel(REG_CONFIG_SET | REG_CONFIG_PIOEN, spi->base + REG_CONFIG);
+		writel(REG_CLKCFG_ENABLE, spi->base + REG_CLKCFG);
+
+		apple_spimc_continue_tx(spi, readl(spi->base + REG_AVAIL));
+
+		spin_unlock_irqrestore(&spi->lock, flags);
+
+		timeout = wait_for_completion_timeout(&spi->done, timeout);
+
+		spin_lock_irqsave(&spi->lock, flags);
+
+		writel(0, spi->base + REG_CLKCFG);
+		writel(REG_CONFIG_SET, spi->base + REG_CONFIG);
+		writel(REG_STATUS_COMPL | REG_STATUS_TXEMPTY | REG_STATUS_RXRDY,
+			spi->base + REG_STATUS);
+
+		if(timeout == 0) {
+			dev_err(&spid->dev, "transfer timed out with %d/%d remaining.\n",
+				spi->len - spi->tx_compl, spi->len - spi->rx_compl);
+			status = -ETIMEDOUT;
+		}
+
+		m->actual_length += t->len;
+
+		spin_unlock_irqrestore(&spi->lock, flags);
+
+		if(status)
+			break;
+	}
+
+	apple_spimc_set_cs(spid, 0);
+
+msg_done:
+	m->status = status;
+	spi_finalize_current_message(master);
+
+	return 0;
+}
+
+static int apple_spimc_setup(struct spi_device *spid)
+{
+	struct apple_spimc *spi = spidev_to_apple_spimc(spid);
+
+	if(!spid->max_speed_hz || spid->max_speed_hz > (spi->clkfreq / 2))
+		spid->max_speed_hz = spi->clkfreq / 2;
+
+	if(spid->max_speed_hz < spi->clkfreq / (REG_CLKDIV_MAX + 1)) {
+		dev_err(&spid->dev, "setup: requested speed is too low: %d Hz\n",
+			spid->max_speed_hz);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id apple_spimc_match[] = {
+	{ .compatible = "apple,spi-mc-m1" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, apple_spimc_match);
+
+static int apple_spimc_probe(struct platform_device *pdev)
+{
+	struct spi_controller *master;
+	struct apple_spimc *spi;
+	void __iomem *base;
+	struct clk *clk;
+	struct gpio_descs *csgpio = NULL;
+	int ret, ncs, irq;
+
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if(IS_ERR(base))
+		return PTR_ERR(base);
+
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if(IS_ERR(clk)) {
+		dev_err(&pdev->dev, "unable to get clock: %ld.\n", PTR_ERR(clk));
+		return PTR_ERR(clk);
+	}
+
+	ncs = gpiod_count(&pdev->dev, "cs");
+	if(ncs > 0) {
+		csgpio = devm_gpiod_get_array(&pdev->dev, "cs", 0);
+		if(IS_ERR(csgpio)) {
+			if(PTR_ERR(csgpio) != -EPROBE_DEFER)
+				dev_err(&pdev->dev, "failed to get chip select gpios: %ld\n",
+					PTR_ERR(csgpio));
+			return PTR_ERR(csgpio);
+		}
+	} else
+		ncs = 0;
+
+	ret = clk_prepare_enable(clk);
+	if(ret)
+		return ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*spi));
+	if(!master) {
+		dev_info(&pdev->dev, "master allocation failed.\n");
+		return -ENOMEM;
+	}
+
+	master->mode_bits = SPI_LSB_FIRST;
+	master->flags = 0;
+	master->setup = apple_spimc_setup;
+	master->transfer_one_message = apple_spimc_transfer_one_message;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->dev.of_node = pdev->dev.of_node;
+	master->num_chipselect = ncs ? ncs : 1;
+
+	dev_set_drvdata(&pdev->dev, master);
+
+	spi = spi_controller_get_devdata(master);
+	spi->base = base;
+	spi->clk = clk;
+	spi->master = master;
+	spi->clkfreq = clk_get_rate(spi->clk);
+	spi->csgpio = csgpio;
+
+	dev_err(&pdev->dev, "Apple SPI-MC at %d MHz, %d chip select GPIO%s.\n",
+		spi->clkfreq / 1000000, ncs, ncs == 1 ? "" : "s");
+
+	spin_lock_init(&spi->lock);
+	init_completion(&spi->done);
+
+	irq = platform_get_irq(pdev, 0);
+	if(irq < 0)
+		return irq;
+
+	ret = devm_request_irq(&pdev->dev, irq, apple_spimc_irq, 0, dev_name(&pdev->dev), spi);
+	if(ret < 0)
+		return ret;
+
+	return devm_spi_register_controller(&pdev->dev, master);
+}
+
+static int apple_spimc_remove(struct platform_device *pdev)
+{
+	struct spi_controller *master;
+	struct apple_spimc *spi;
+
+	master = dev_get_drvdata(&pdev->dev);
+	spi = spi_controller_get_devdata(master);
+
+	clk_disable_unprepare(spi->clk);
+
+	return 0;
+}
+
+static struct platform_driver apple_spimc_driver = {
+	.driver = {
+		.name = "spi-apple-mc",
+		.of_match_table = apple_spimc_match,
+	},
+	.probe = apple_spimc_probe,
+	.remove = apple_spimc_remove,
+};
+
+module_platform_driver(apple_spimc_driver);
+
+MODULE_DESCRIPTION("Apple SoC SPI-MC driver");
+MODULE_AUTHOR("Corellium LLC");
+MODULE_LICENSE("GPL");
-- 
2.34.0


From 09e2ef5a838a277c2fb7c23517e11c2753e48632 Mon Sep 17 00:00:00 2001
From: Stan Skowronek <stan@corellium.com>
Date: Fri, 29 Jan 2021 18:03:05 -0500
Subject: [PATCH 76/83] Implement delay options in SPI driver.

Signed-off-by: Stan Skowronek <stan@corellium.com>

[joey: cherry picked e688b19f0f58737ccd6f916b5bb56fc675ad9eeb from
corellium/linux-m1]
---
 drivers/spi/spi-apple-mc.c | 120 ++++++++++++++++++++++++-------------
 1 file changed, 79 insertions(+), 41 deletions(-)

diff --git a/drivers/spi/spi-apple-mc.c b/drivers/spi/spi-apple-mc.c
index af527633113e..7429abdeff35 100644
--- a/drivers/spi/spi-apple-mc.c
+++ b/drivers/spi/spi-apple-mc.c
@@ -59,12 +59,15 @@
 #define  REG_HWDLY_POST_SHIFT		16
 #define REG_HWDLY_POST_2		0x194
 
-#define TIMEOUT_MS			1000
+#define TIMEOUT_MS			100
 
 #define FIFO_SIZE			16
 
+#define MAX_SEG_SIZE			16384
+
 struct apple_spimc {
 	struct spi_controller *master;
+	struct device *dev;
 	void __iomem *base;
 	unsigned int clkfreq;
 	unsigned int speed;
@@ -83,13 +86,18 @@ static inline struct apple_spimc *spidev_to_apple_spimc(struct spi_device *spi)
 	return spi_controller_get_devdata(spi->master);
 }
 
-static void apple_spimc_continue_tx(struct apple_spimc *spi, unsigned avail)
+static void apple_spimc_continue_tx(struct apple_spimc *spi, unsigned avail, unsigned prime)
 {
 	unsigned maxtx = (avail & REG_AVAIL_TXFIFO_MASK) >> REG_AVAIL_TXFIFO_SHIFT;
-	unsigned data;
-	unsigned cfg;
+	unsigned data, maxrx, cfg;
 
 	maxtx = FIFO_SIZE - maxtx;
+	if(!prime) {
+		maxrx = (avail & REG_AVAIL_RXFIFO_MASK) >> REG_AVAIL_RXFIFO_SHIFT;
+		if(maxrx < maxtx)
+			maxtx = maxrx;
+	}
+
 	while(spi->tx_compl < spi->len && maxtx) {
 		if(spi->tx_buf)
 			data = spi->tx_buf[spi->tx_compl];
@@ -132,7 +140,7 @@ static irqreturn_t apple_spimc_irq(int irq, void *dev_id)
 {
 	struct apple_spimc *spi = dev_id;
 	unsigned long flags;
-	unsigned status, avail;
+	unsigned status, avail, done;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
@@ -140,9 +148,9 @@ static irqreturn_t apple_spimc_irq(int irq, void *dev_id)
 	avail = readl(spi->base + REG_AVAIL);
 	writel(status, spi->base + REG_STATUS);
 
-	apple_spimc_continue_tx(spi, avail);
-
-	if(apple_spimc_continue_rx(spi, avail))
+	done = apple_spimc_continue_rx(spi, avail);
+	apple_spimc_continue_tx(spi, avail, 0);
+	if(done)
 		complete(&spi->done);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
@@ -177,6 +185,8 @@ static int apple_spimc_prepare(struct spi_device *spid, unsigned int speed)
 
 	if(readl(spi->base + REG_RXCNT))
 		writel(0, spi->base + REG_RXCNT);
+	if(readl(spi->base + REG_TXCNT))
+		writel(0, spi->base + REG_TXCNT);
 	avail = readl(spi->base + REG_AVAIL);
 	avail = (avail & REG_AVAIL_RXFIFO_MASK) >> REG_AVAIL_RXFIFO_SHIFT;
 	while(avail --)
@@ -188,6 +198,7 @@ static int apple_spimc_prepare(struct spi_device *spid, unsigned int speed)
 	writel(REG_STATUS_COMPL | REG_STATUS_TXEMPTY | REG_STATUS_RXRDY, spi->base + REG_STATUS);
 	writel(readl(spi->base + REG_SPCON) & ~REG_SPCON_MODE, spi->base + REG_SPCON);
 	writel(REG_CONFIG_SET, spi->base + REG_CONFIG);
+	writel(REG_CLKCFG_ENABLE, spi->base + REG_CLKCFG);
 	writel(readl(spi->base + REG_HWDLY_CFG) & ~REG_HWDLY_CFG_EN, spi->base + REG_HWDLY_CFG);
 	writel(readl(spi->base + REG_HWDLY_PRE) & ~REG_HWDLY_PRE_EN, spi->base + REG_HWDLY_PRE);
 	writel(readl(spi->base + REG_HWDLY_POST) & ~REG_HWDLY_POST_EN, spi->base + REG_HWDLY_POST);
@@ -200,16 +211,16 @@ static int apple_spimc_prepare(struct spi_device *spid, unsigned int speed)
 
 static int apple_spimc_transfer_one_message(struct spi_controller *master, struct spi_message *m)
 {
-	unsigned long timeout = msecs_to_jiffies(TIMEOUT_MS);
+	unsigned long timeout;
 	struct apple_spimc *spi = spi_controller_get_devdata(master);
 	struct spi_device *spid = m->spi;
-	unsigned int speed = spid->max_speed_hz;
+	unsigned int speed = spid->max_speed_hz, avail;
 	struct spi_transfer *t = NULL;
-	int status = 0;
-	unsigned long flags;
+	int status = 0, seg, offs;
+	unsigned long flags, cs_set = 0;
 
 	list_for_each_entry(t, &m->transfers, transfer_list)
-		if(t->speed_hz < speed)
+		if(t->speed_hz < speed && t->speed_hz)
 			speed = t->speed_hz;
 
 	if(apple_spimc_prepare(spid, speed)) {
@@ -217,53 +228,79 @@ static int apple_spimc_transfer_one_message(struct spi_controller *master, struc
 		goto msg_done;
 	}
 
-	apple_spimc_set_cs(spid, 1);
-
 	m->actual_length = 0;
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		spin_lock_irqsave(&spi->lock, flags);
+		if(!cs_set && (t->len || !t->cs_change)) {
+			apple_spimc_set_cs(spid, 1);
+			cs_set = 1;
+		}
 
-		reinit_completion(&spi->done);
+		for(offs=0; offs<t->len; offs+=seg) {
+			seg = t->len - offs;
+			if(seg > MAX_SEG_SIZE)
+				seg = MAX_SEG_SIZE;
 
-		spi->len = t->len;
-		spi->tx_compl = spi->rx_compl = 0;
-		spi->tx_buf = t->tx_buf;
-		spi->rx_buf = t->rx_buf;
+			spin_lock_irqsave(&spi->lock, flags);
 
-		writel(t->len, spi->base + REG_RXCNT);
-		writel(t->len, spi->base + REG_TXCNT);
-		writel(REG_CONFIG_SET | REG_CONFIG_PIOEN, spi->base + REG_CONFIG);
-		writel(REG_CLKCFG_ENABLE, spi->base + REG_CLKCFG);
+			reinit_completion(&spi->done);
 
-		apple_spimc_continue_tx(spi, readl(spi->base + REG_AVAIL));
+			spi->len = seg;
+			spi->tx_compl = spi->rx_compl = 0;
+			spi->tx_buf = t->tx_buf ? (t->tx_buf + offs) : NULL;
+			spi->rx_buf = t->rx_buf ? (t->rx_buf + offs) : NULL;
 
-		spin_unlock_irqrestore(&spi->lock, flags);
+			writel(spi->len, spi->base + REG_TXCNT);
+			writel(spi->len, spi->base + REG_RXCNT);
+			writel(REG_CONFIG_SET | REG_CONFIG_PIOEN, spi->base + REG_CONFIG);
 
-		timeout = wait_for_completion_timeout(&spi->done, timeout);
+			avail = readl(spi->base + REG_AVAIL);
+			apple_spimc_continue_tx(spi, avail, 1);
 
-		spin_lock_irqsave(&spi->lock, flags);
+			spin_unlock_irqrestore(&spi->lock, flags);
 
-		writel(0, spi->base + REG_CLKCFG);
-		writel(REG_CONFIG_SET, spi->base + REG_CONFIG);
-		writel(REG_STATUS_COMPL | REG_STATUS_TXEMPTY | REG_STATUS_RXRDY,
-			spi->base + REG_STATUS);
+			timeout = msecs_to_jiffies(TIMEOUT_MS);
+			timeout = wait_for_completion_timeout(&spi->done, timeout);
 
-		if(timeout == 0) {
-			dev_err(&spid->dev, "transfer timed out with %d/%d remaining.\n",
-				spi->len - spi->tx_compl, spi->len - spi->rx_compl);
-			status = -ETIMEDOUT;
-		}
+			spin_lock_irqsave(&spi->lock, flags);
+
+			writel(REG_CONFIG_SET, spi->base + REG_CONFIG);
+			writel(REG_STATUS_COMPL | REG_STATUS_TXEMPTY | REG_STATUS_RXRDY,
+				spi->base + REG_STATUS);
+
+			if(timeout == 0) {
+				dev_err(&spid->dev, "transfer timed out with %d/%d remaining (of %d).\n",
+					spi->len - spi->tx_compl, spi->len - spi->rx_compl, spi->len);
+				status = -ETIMEDOUT;
+			}
 
-		m->actual_length += t->len;
+			m->actual_length += spi->len;
 
-		spin_unlock_irqrestore(&spi->lock, flags);
+			spin_unlock_irqrestore(&spi->lock, flags);
+
+			if(status)
+				break;
+		}
 
 		if(status)
 			break;
+
+		if(t->delay_usecs)
+			udelay(t->delay_usecs);
+		spi_delay_exec(&t->delay, t);
+
+		if(t->cs_change) {
+			apple_spimc_set_cs(spid, 0);
+			if(spi_delay_exec(&t->cs_change_delay, t) < 0)
+				udelay(50);
+			apple_spimc_set_cs(spid, 1);
+			cs_set = 1;
+		}
 	}
 
 	apple_spimc_set_cs(spid, 0);
 
+	writel(0, spi->base + REG_CLKCFG);
+
 msg_done:
 	m->status = status;
 	spi_finalize_current_message(master);
@@ -330,7 +367,7 @@ static int apple_spimc_probe(struct platform_device *pdev)
 
 	master = spi_alloc_master(&pdev->dev, sizeof(*spi));
 	if(!master) {
-		dev_info(&pdev->dev, "master allocation failed.\n");
+		dev_err(&pdev->dev, "master allocation failed.\n");
 		return -ENOMEM;
 	}
 
@@ -345,6 +382,7 @@ static int apple_spimc_probe(struct platform_device *pdev)
 	dev_set_drvdata(&pdev->dev, master);
 
 	spi = spi_controller_get_devdata(master);
+	spi->dev = &pdev->dev;
 	spi->base = base;
 	spi->clk = clk;
 	spi->master = master;
-- 
2.34.0


From 4229074608c73963b36f48f145fa16e81fc1aa4b Mon Sep 17 00:00:00 2001
From: Joey Gouly <joey.gouly@arm.com>
Date: Thu, 12 Aug 2021 09:57:02 +0000
Subject: [PATCH 77/83] spi: spi-apple-mc: `delay_usecs` was removed in
 3ab1cce55337

This is already handled by spi_delay_exec.

Fixes: d088cd9b5987 ("Implement delay options in SPI driver.")

Signed-off-by: Joey Gouly <joey.gouly@arm.com>
---
 drivers/spi/spi-apple-mc.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/drivers/spi/spi-apple-mc.c b/drivers/spi/spi-apple-mc.c
index 7429abdeff35..8cce347a94dc 100644
--- a/drivers/spi/spi-apple-mc.c
+++ b/drivers/spi/spi-apple-mc.c
@@ -284,8 +284,6 @@ static int apple_spimc_transfer_one_message(struct spi_controller *master, struc
 		if(status)
 			break;
 
-		if(t->delay_usecs)
-			udelay(t->delay_usecs);
 		spi_delay_exec(&t->delay, t);
 
 		if(t->cs_change) {
-- 
2.34.0


From 8c0ce0370651d196f1a020a44405afaf48014785 Mon Sep 17 00:00:00 2001
From: Joey Gouly <joey.gouly@arm.com>
Date: Fri, 13 Aug 2021 11:57:00 +0000
Subject: [PATCH 78/83] spi: spple-mc: Convert to use GPIO descriptors

Using GPIO numbers is the legacy method.

Signed-off-by: Joey Gouly <joey.gouly@arm.com>
---
 drivers/spi/spi-apple-mc.c | 36 ++++++++++--------------------------
 1 file changed, 10 insertions(+), 26 deletions(-)

diff --git a/drivers/spi/spi-apple-mc.c b/drivers/spi/spi-apple-mc.c
index 8cce347a94dc..c3b14f63b166 100644
--- a/drivers/spi/spi-apple-mc.c
+++ b/drivers/spi/spi-apple-mc.c
@@ -72,7 +72,6 @@ struct apple_spimc {
 	unsigned int clkfreq;
 	unsigned int speed;
 	struct clk *clk;
-	struct gpio_descs *csgpio;
 
 	spinlock_t lock;
 	const unsigned char *tx_buf;
@@ -160,13 +159,10 @@ static irqreturn_t apple_spimc_irq(int irq, void *dev_id)
 
 static void apple_spimc_set_cs(struct spi_device *spid, int enable)
 {
-	struct apple_spimc *spi = spidev_to_apple_spimc(spid);
-	int cs = spid->chip_select;
-
-	if(!spi->csgpio || cs >= spi->csgpio->ndescs)
+	if (!spid->cs_gpiod)
 		return;
 
-	gpiod_direction_output(spi->csgpio->desc[cs], enable);
+	gpiod_direction_output(spid->cs_gpiod, enable);
 }
 
 static int apple_spimc_prepare(struct spi_device *spid, unsigned int speed)
@@ -334,8 +330,7 @@ static int apple_spimc_probe(struct platform_device *pdev)
 	struct apple_spimc *spi;
 	void __iomem *base;
 	struct clk *clk;
-	struct gpio_descs *csgpio = NULL;
-	int ret, ncs, irq;
+	int ret, irq;
 
 	base = devm_platform_ioremap_resource(pdev, 0);
 	if(IS_ERR(base))
@@ -347,18 +342,6 @@ static int apple_spimc_probe(struct platform_device *pdev)
 		return PTR_ERR(clk);
 	}
 
-	ncs = gpiod_count(&pdev->dev, "cs");
-	if(ncs > 0) {
-		csgpio = devm_gpiod_get_array(&pdev->dev, "cs", 0);
-		if(IS_ERR(csgpio)) {
-			if(PTR_ERR(csgpio) != -EPROBE_DEFER)
-				dev_err(&pdev->dev, "failed to get chip select gpios: %ld\n",
-					PTR_ERR(csgpio));
-			return PTR_ERR(csgpio);
-		}
-	} else
-		ncs = 0;
-
 	ret = clk_prepare_enable(clk);
 	if(ret)
 		return ret;
@@ -375,7 +358,7 @@ static int apple_spimc_probe(struct platform_device *pdev)
 	master->transfer_one_message = apple_spimc_transfer_one_message;
 	master->bits_per_word_mask = SPI_BPW_MASK(8);
 	master->dev.of_node = pdev->dev.of_node;
-	master->num_chipselect = ncs ? ncs : 1;
+	master->use_gpio_descriptors = true;
 
 	dev_set_drvdata(&pdev->dev, master);
 
@@ -385,10 +368,6 @@ static int apple_spimc_probe(struct platform_device *pdev)
 	spi->clk = clk;
 	spi->master = master;
 	spi->clkfreq = clk_get_rate(spi->clk);
-	spi->csgpio = csgpio;
-
-	dev_err(&pdev->dev, "Apple SPI-MC at %d MHz, %d chip select GPIO%s.\n",
-		spi->clkfreq / 1000000, ncs, ncs == 1 ? "" : "s");
 
 	spin_lock_init(&spi->lock);
 	init_completion(&spi->done);
@@ -401,7 +380,12 @@ static int apple_spimc_probe(struct platform_device *pdev)
 	if(ret < 0)
 		return ret;
 
-	return devm_spi_register_controller(&pdev->dev, master);
+	ret = devm_spi_register_controller(&pdev->dev, master);
+
+	dev_err(&pdev->dev, "Apple SPI-MC at %d MHz, %d chip select GPIO%s.\n",
+		spi->clkfreq / 1000000, master->num_chipselect, master->num_chipselect == 1 ? "" : "s");
+
+	return ret;
 }
 
 static int apple_spimc_remove(struct platform_device *pdev)
-- 
2.34.0


From bbfc9816dca3cd9850953d37f3c9a5e21a76ba3d Mon Sep 17 00:00:00 2001
From: Stan Skowronek <stan@corellium.com>
Date: Fri, 29 Jan 2021 18:03:21 -0500
Subject: [PATCH 79/83] input: applespi.c was preparing delay values after
 consuming them.

Signed-off-by: Stan Skowronek <stan@corellium.com>

[joey: cherry picked 5f6ff1f62f93b965275cd1bb379dd9b4f7ac6d78 from
corellium/linux-m1]
---
 drivers/input/keyboard/applespi.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/drivers/input/keyboard/applespi.c b/drivers/input/keyboard/applespi.c
index eda1b23002b5..27de3dbf8eac 100644
--- a/drivers/input/keyboard/applespi.c
+++ b/drivers/input/keyboard/applespi.c
@@ -1688,10 +1688,6 @@ static int applespi_probe(struct spi_device *spi)
 	    !applespi->rx_buffer || !applespi->msg_buf)
 		return -ENOMEM;
 
-	/* set up our spi messages */
-	applespi_setup_read_txfrs(applespi);
-	applespi_setup_write_txfrs(applespi);
-
 	/* cache ACPI method handles */
 	acpi_sts = acpi_get_handle(spi_handle, "SIEN", &applespi->sien);
 	if (ACPI_FAILURE(acpi_sts)) {
@@ -1709,11 +1705,16 @@ static int applespi_probe(struct spi_device *spi)
 		return -ENODEV;
 	}
 
-	/* switch on the SPI interface */
+	/* prepare SPI settings and locks */
 	sts = applespi_setup_spi(applespi);
 	if (sts)
 		return sts;
 
+	/* set up our SPI messages */
+	applespi_setup_read_txfrs(applespi);
+	applespi_setup_write_txfrs(applespi);
+
+	/* switch on the SPI interface */
 	sts = applespi_enable_spi(applespi);
 	if (sts)
 		return sts;
-- 
2.34.0


From cf33d2335ae436efa08372800e0d6997ca154ab1 Mon Sep 17 00:00:00 2001
From: Stan Skowronek <stan@corellium.com>
Date: Fri, 29 Jan 2021 18:03:34 -0500
Subject: [PATCH 80/83] input: Add support for M1 MacBooks in applespi driver
 (OF instead of ACPI).

Signed-off-by: Stan Skowronek <stan@corellium.com>

[joey: cherry picked aa80cf74c9afe10d10b04dd58f6e914a411bdc00 from
corellium/linux-m1]
---
 drivers/input/keyboard/Kconfig    |   4 +-
 drivers/input/keyboard/applespi.c | 371 ++++++++++++++++++++++--------
 2 files changed, 277 insertions(+), 98 deletions(-)

diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index 0c607da9ee10..f9a22770891d 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -69,9 +69,9 @@ config KEYBOARD_AMIGA
 
 config KEYBOARD_APPLESPI
 	tristate "Apple SPI keyboard and trackpad"
-	depends on ACPI && EFI
+	depends on (ACPI && EFI) || (OF && GPIOLIB)
 	depends on SPI
-	depends on X86 || COMPILE_TEST
+	depends on X86 || ARM64 || COMPILE_TEST
 	depends on LEDS_CLASS
 	select CRC16
 	help
diff --git a/drivers/input/keyboard/applespi.c b/drivers/input/keyboard/applespi.c
index 27de3dbf8eac..9cae4b9fb36a 100644
--- a/drivers/input/keyboard/applespi.c
+++ b/drivers/input/keyboard/applespi.c
@@ -55,6 +55,9 @@
 #include <linux/spi/spi.h>
 #include <linux/wait.h>
 #include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/gpio/consumer.h>
 
 #include <asm/barrier.h>
 #include <asm/unaligned.h>
@@ -90,6 +93,7 @@
 #define APPLE_FLAG_FKEY		0x01
 
 #define SPI_RW_CHG_DELAY_US	100	/* from experimentation, in µs */
+#define SPI_END_CS_DELAY_US	20
 
 #define SYNAPTICS_VENDOR_ID	0x06cb
 
@@ -387,10 +391,24 @@ struct applespi_data {
 	u8				last_fn_pressed;
 	struct input_mt_pos		pos[MAX_FINGERS];
 	int				slots[MAX_FINGERS];
+
+	bool				of_mode;
+
+	/* ACPI specific */
+#ifdef CONFIG_ACPI
 	int				gpe;
 	acpi_handle			sien;
 	acpi_handle			sist;
+#endif
+
+#ifdef CONFIG_OF
+	/* OF specific */
+	int				gpioirq;
+	struct gpio_desc		*spiengpio, *irqgpio;
+	bool				gpioirq_enabled;
+#endif
 
+	struct spi_transfer		rw_t;
 	struct spi_transfer		dl_t;
 	struct spi_transfer		rd_t;
 	struct spi_message		rd_m;
@@ -549,19 +567,29 @@ static applespi_trace_fun applespi_get_trace_fun(enum applespi_evt_type type)
 static void applespi_setup_read_txfrs(struct applespi_data *applespi)
 {
 	struct spi_message *msg = &applespi->rd_m;
+	struct spi_transfer *rw_t = &applespi->rw_t;
 	struct spi_transfer *dl_t = &applespi->dl_t;
 	struct spi_transfer *rd_t = &applespi->rd_t;
 
+	memset(rw_t, 0, sizeof(*rw_t));
 	memset(dl_t, 0, sizeof(*dl_t));
 	memset(rd_t, 0, sizeof(*rd_t));
 
+	rw_t->delay.value = SPI_RW_CHG_DELAY_US;
+	rw_t->delay.unit = SPI_DELAY_UNIT_USECS;
+	rw_t->cs_change = 1;
+
 	dl_t->delay.value = applespi->spi_settings.spi_cs_delay;
 	dl_t->delay.unit = SPI_DELAY_UNIT_USECS;
 
 	rd_t->rx_buf = applespi->rx_buffer;
 	rd_t->len = APPLESPI_PACKET_SIZE;
+	rd_t->delay.value = SPI_END_CS_DELAY_US;
+	rd_t->delay.unit = SPI_DELAY_UNIT_USECS;
 
 	spi_message_init(msg);
+	if(applespi->of_mode)
+		spi_message_add_tail(rw_t, msg);
 	spi_message_add_tail(dl_t, msg);
 	spi_message_add_tail(rd_t, msg);
 }
@@ -599,6 +627,8 @@ static void applespi_setup_write_txfrs(struct applespi_data *applespi)
 
 	st_t->rx_buf = applespi->tx_status;
 	st_t->len = APPLESPI_STATUS_SIZE;
+	st_t->delay.value = SPI_END_CS_DELAY_US;
+	st_t->delay.unit = SPI_DELAY_UNIT_USECS;
 
 	spi_message_init(msg);
 	spi_message_add_tail(wt_t, msg);
@@ -638,27 +668,35 @@ static inline bool applespi_check_write_status(struct applespi_data *applespi,
 
 static int applespi_get_spi_settings(struct applespi_data *applespi)
 {
-	struct acpi_device *adev = ACPI_COMPANION(&applespi->spi->dev);
-	const union acpi_object *o;
 	struct spi_settings *settings = &applespi->spi_settings;
 
-	if (!acpi_dev_get_property(adev, "spiCSDelay", ACPI_TYPE_BUFFER, &o))
-		settings->spi_cs_delay = *(u64 *)o->buffer.pointer;
-	else
-		dev_warn(&applespi->spi->dev,
-			 "Property spiCSDelay not found\n");
+	if(applespi->of_mode) {
+		settings->spi_cs_delay = 100;
+		settings->reset_a2r_usec = 25;
+		settings->reset_rec_usec = 10;
+	} else {
+#ifdef CONFIG_ACPI
+		struct acpi_device *adev = ACPI_COMPANION(&applespi->spi->dev);
+		const union acpi_object *o;
+		if (!acpi_dev_get_property(adev, "spiCSDelay", ACPI_TYPE_BUFFER, &o))
+			settings->spi_cs_delay = *(u64 *)o->buffer.pointer;
+		else
+			dev_warn(&applespi->spi->dev,
+				 "Property spiCSDelay not found\n");
 
-	if (!acpi_dev_get_property(adev, "resetA2RUsec", ACPI_TYPE_BUFFER, &o))
-		settings->reset_a2r_usec = *(u64 *)o->buffer.pointer;
-	else
-		dev_warn(&applespi->spi->dev,
-			 "Property resetA2RUsec not found\n");
+		if (!acpi_dev_get_property(adev, "resetA2RUsec", ACPI_TYPE_BUFFER, &o))
+			settings->reset_a2r_usec = *(u64 *)o->buffer.pointer;
+		else
+			dev_warn(&applespi->spi->dev,
+				 "Property resetA2RUsec not found\n");
 
-	if (!acpi_dev_get_property(adev, "resetRecUsec", ACPI_TYPE_BUFFER, &o))
-		settings->reset_rec_usec = *(u64 *)o->buffer.pointer;
-	else
-		dev_warn(&applespi->spi->dev,
-			 "Property resetRecUsec not found\n");
+		if (!acpi_dev_get_property(adev, "resetRecUsec", ACPI_TYPE_BUFFER, &o))
+			settings->reset_rec_usec = *(u64 *)o->buffer.pointer;
+		else
+			dev_warn(&applespi->spi->dev,
+				 "Property resetRecUsec not found\n");
+#endif
+	}
 
 	dev_dbg(&applespi->spi->dev,
 		"SPI settings: spi_cs_delay=%llu reset_a2r_usec=%llu reset_rec_usec=%llu\n",
@@ -684,21 +722,34 @@ static int applespi_setup_spi(struct applespi_data *applespi)
 
 static int applespi_enable_spi(struct applespi_data *applespi)
 {
-	acpi_status acpi_sts;
 	unsigned long long spi_status;
 
-	/* check if SPI is already enabled, so we can skip the delay below */
-	acpi_sts = acpi_evaluate_integer(applespi->sist, NULL, NULL,
-					 &spi_status);
-	if (ACPI_SUCCESS(acpi_sts) && spi_status)
-		return 0;
+	if(applespi->of_mode) {
+#ifdef CONFIG_OF
+		spi_status = gpiod_get_value(applespi->spiengpio);
+		if(spi_status)
+			return 0;
 
-	/* SIEN(1) will enable SPI communication */
-	acpi_sts = acpi_execute_simple_method(applespi->sien, NULL, 1);
-	if (ACPI_FAILURE(acpi_sts)) {
-		dev_err(&applespi->spi->dev, "SIEN failed: %s\n",
-			acpi_format_exception(acpi_sts));
-		return -ENODEV;
+		gpiod_direction_output(applespi->spiengpio, 1);
+#endif
+	} else {
+#ifdef CONFIG_ACPI
+		acpi_status acpi_sts;
+
+		/* check if SPI is already enabled, so we can skip the delay below */
+		acpi_sts = acpi_evaluate_integer(applespi->sist, NULL, NULL,
+						 &spi_status);
+		if (ACPI_SUCCESS(acpi_sts) && spi_status)
+			return 0;
+
+		/* SIEN(1) will enable SPI communication */
+		acpi_sts = acpi_execute_simple_method(applespi->sien, NULL, 1);
+		if (ACPI_FAILURE(acpi_sts)) {
+			dev_err(&applespi->spi->dev, "SIEN failed: %s\n",
+				acpi_format_exception(acpi_sts));
+			return -ENODEV;
+		}
+#endif
 	}
 
 	/*
@@ -1566,12 +1617,22 @@ static void applespi_async_read_complete(void *context)
 		applespi_got_data(applespi);
 	}
 
-	acpi_finish_gpe(NULL, applespi->gpe);
+	if(applespi->of_mode) {
+#ifdef CONFIG_OF
+		if(!applespi->gpioirq_enabled) {
+			applespi->gpioirq_enabled = true;
+			enable_irq(applespi->gpioirq);
+		}
+#endif
+	} else {
+#ifdef CONFIG_ACPI
+		acpi_finish_gpe(NULL, applespi->gpe);
+#endif
+	}
 }
 
-static u32 applespi_notify(acpi_handle gpe_device, u32 gpe, void *context)
+static void applespi_irq_handler(struct applespi_data *applespi)
 {
-	struct applespi_data *applespi = context;
 	int sts;
 	unsigned long flags;
 
@@ -1591,12 +1652,35 @@ static u32 applespi_notify(acpi_handle gpe_device, u32 gpe, void *context)
 	}
 
 	spin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);
+}
 
+#ifdef CONFIG_ACPI
+static u32 applespi_notify(acpi_handle gpe_device, u32 gpe, void *context)
+{
+	struct applespi_data *applespi = context;
+	applespi_irq_handler(applespi);
 	return ACPI_INTERRUPT_HANDLED;
 }
+#endif
+
+#ifdef CONFIG_OF
+static irqreturn_t applespi_gpioirq_isr(int irq, void *dev_id)
+{
+	struct applespi_data *applespi = dev_id;
+
+	if(applespi->gpioirq_enabled) {
+		applespi->gpioirq_enabled = false;
+		disable_irq_nosync(applespi->gpioirq);
+	}
+
+	applespi_irq_handler(applespi);
+	return IRQ_HANDLED;
+}
+#endif
 
 static int applespi_get_saved_bl_level(struct applespi_data *applespi)
 {
+#ifdef CONFIG_EFI
 	struct efivar_entry *efivar_entry;
 	u16 efi_data = 0;
 	unsigned long efi_data_len;
@@ -1620,11 +1704,15 @@ static int applespi_get_saved_bl_level(struct applespi_data *applespi)
 	kfree(efivar_entry);
 
 	return sts ? sts : efi_data;
+#else
+	return 0;
+#endif
 }
 
 static void applespi_save_bl_level(struct applespi_data *applespi,
 				   unsigned int level)
 {
+#ifdef CONFIG_EFI
 	efi_guid_t efi_guid;
 	u32 efi_attr;
 	unsigned long efi_data_len;
@@ -1643,22 +1731,40 @@ static void applespi_save_bl_level(struct applespi_data *applespi,
 	if (sts)
 		dev_warn(&applespi->spi->dev,
 			 "Error saving backlight level to EFI vars: %d\n", sts);
+#endif
 }
 
 static int applespi_probe(struct spi_device *spi)
 {
 	struct applespi_data *applespi;
-	acpi_handle spi_handle = ACPI_HANDLE(&spi->dev);
-	acpi_status acpi_sts;
 	int sts, i;
+#ifdef CONFIG_ACPI
+	acpi_handle spi_handle;
+	acpi_status acpi_sts;
 	unsigned long long gpe, usb_status;
+#endif
+	bool of_mode = false;
 
-	/* check if the USB interface is present and enabled already */
-	acpi_sts = acpi_evaluate_integer(spi_handle, "UIST", NULL, &usb_status);
-	if (ACPI_SUCCESS(acpi_sts) && usb_status) {
-		/* let the USB driver take over instead */
-		dev_info(&spi->dev, "USB interface already enabled\n");
+	if (spi->dev.of_node)
+		of_mode = true;
+
+	if(of_mode) {
+#ifndef CONFIG_OF
+		return -ENODEV;
+#endif
+	} else {
+#ifdef CONFIG_ACPI
+		/* check if the USB interface is present and enabled already */
+		spi_handle = ACPI_HANDLE(&spi->dev);
+		acpi_sts = acpi_evaluate_integer(spi_handle, "UIST", NULL, &usb_status);
+		if (ACPI_SUCCESS(acpi_sts) && usb_status) {
+			/* let the USB driver take over instead */
+			dev_info(&spi->dev, "USB interface already enabled\n");
+			return -ENODEV;
+		}
+#else
 		return -ENODEV;
+#endif
 	}
 
 	/* allocate driver data */
@@ -1667,6 +1773,7 @@ static int applespi_probe(struct spi_device *spi)
 		return -ENOMEM;
 
 	applespi->spi = spi;
+	applespi->of_mode = of_mode;
 
 	INIT_WORK(&applespi->work, applespi_worker);
 
@@ -1688,21 +1795,41 @@ static int applespi_probe(struct spi_device *spi)
 	    !applespi->rx_buffer || !applespi->msg_buf)
 		return -ENOMEM;
 
-	/* cache ACPI method handles */
-	acpi_sts = acpi_get_handle(spi_handle, "SIEN", &applespi->sien);
-	if (ACPI_FAILURE(acpi_sts)) {
-		dev_err(&applespi->spi->dev,
-			"Failed to get SIEN ACPI method handle: %s\n",
-			acpi_format_exception(acpi_sts));
-		return -ENODEV;
-	}
+	if(of_mode) {
+#ifdef CONFIG_OF
+		applespi->spiengpio = devm_gpiod_get_index(&spi->dev, "spien", 0, 0);
+		if(IS_ERR(applespi->spiengpio)) {
+			sts = PTR_ERR(applespi->spiengpio);
+			if(sts != -EPROBE_DEFER)
+				dev_err(&spi->dev, "failed to get spien gpio: %d\n", sts);
+			return sts;
+		}
 
-	acpi_sts = acpi_get_handle(spi_handle, "SIST", &applespi->sist);
-	if (ACPI_FAILURE(acpi_sts)) {
-		dev_err(&applespi->spi->dev,
-			"Failed to get SIST ACPI method handle: %s\n",
-			acpi_format_exception(acpi_sts));
-		return -ENODEV;
+		/* reset the controller on boot */
+		gpiod_direction_output(applespi->spiengpio, 1);
+		msleep(5);
+		gpiod_direction_output(applespi->spiengpio, 0);
+		msleep(5);
+#endif
+	} else {
+#ifdef CONFIG_ACPI
+		/* cache ACPI method handles */
+		acpi_sts = acpi_get_handle(spi_handle, "SIEN", &applespi->sien);
+		if (ACPI_FAILURE(acpi_sts)) {
+			dev_err(&applespi->spi->dev,
+				"Failed to get SIEN ACPI method handle: %s\n",
+				acpi_format_exception(acpi_sts));
+			return -ENODEV;
+		}
+
+		acpi_sts = acpi_get_handle(spi_handle, "SIST", &applespi->sist);
+		if (ACPI_FAILURE(acpi_sts)) {
+			dev_err(&applespi->spi->dev,
+				"Failed to get SIST ACPI method handle: %s\n",
+				acpi_format_exception(acpi_sts));
+			return -ENODEV;
+		}
+#endif
 	}
 
 	/* prepare SPI settings and locks */
@@ -1761,38 +1888,68 @@ static int applespi_probe(struct spi_device *spi)
 		return -ENODEV;
 	}
 
-	/*
-	 * The applespi device doesn't send interrupts normally (as is described
-	 * in its DSDT), but rather seems to use ACPI GPEs.
-	 */
-	acpi_sts = acpi_evaluate_integer(spi_handle, "_GPE", NULL, &gpe);
-	if (ACPI_FAILURE(acpi_sts)) {
-		dev_err(&applespi->spi->dev,
-			"Failed to obtain GPE for SPI slave device: %s\n",
-			acpi_format_exception(acpi_sts));
-		return -ENODEV;
-	}
-	applespi->gpe = (int)gpe;
+	if(of_mode) {
+#ifdef CONFIG_OF
+		applespi->irqgpio = devm_gpiod_get_index(&spi->dev, "irq", 0, 0);
+		if(IS_ERR(applespi->irqgpio)) {
+			sts = PTR_ERR(applespi->irqgpio);
+			if(sts != -EPROBE_DEFER)
+				dev_err(&spi->dev, "failed to get irq gpio: %d\n", sts);
+			return sts;
+		}
+		gpiod_direction_input(applespi->irqgpio);
 
-	acpi_sts = acpi_install_gpe_handler(NULL, applespi->gpe,
-					    ACPI_GPE_LEVEL_TRIGGERED,
-					    applespi_notify, applespi);
-	if (ACPI_FAILURE(acpi_sts)) {
-		dev_err(&applespi->spi->dev,
-			"Failed to install GPE handler for GPE %d: %s\n",
-			applespi->gpe, acpi_format_exception(acpi_sts));
-		return -ENODEV;
-	}
+		applespi->suspended = false;
+		applespi->gpioirq_enabled = true;
 
-	applespi->suspended = false;
+		applespi->gpioirq = of_irq_get(spi->dev.of_node, 0);
+		if(applespi->gpioirq < 0) {
+			dev_err(&spi->dev, "failed to map IRQ: %d\n", applespi->gpioirq);
+			return applespi->gpioirq;
+		}
+		sts = devm_request_irq(&spi->dev, applespi->gpioirq, applespi_gpioirq_isr, 0,
+				dev_name(&spi->dev), applespi);
+		if(sts < 0) {
+			dev_err(&spi->dev, "failed to request IRQ: %d\n", sts);
+			return sts;
+		}
+#endif
+	} else {
+#ifdef CONFIG_ACPI
+		/*
+		 * The applespi device doesn't send interrupts normally (as is described
+		 * in its DSDT), but rather seems to use ACPI GPEs.
+		 */
+		acpi_sts = acpi_evaluate_integer(spi_handle, "_GPE", NULL, &gpe);
+		if (ACPI_FAILURE(acpi_sts)) {
+			dev_err(&applespi->spi->dev,
+				"Failed to obtain GPE for SPI slave device: %s\n",
+				acpi_format_exception(acpi_sts));
+			return -ENODEV;
+		}
+		applespi->gpe = (int)gpe;
+
+		acpi_sts = acpi_install_gpe_handler(NULL, applespi->gpe,
+						    ACPI_GPE_LEVEL_TRIGGERED,
+						    applespi_notify, applespi);
+		if (ACPI_FAILURE(acpi_sts)) {
+			dev_err(&applespi->spi->dev,
+				"Failed to install GPE handler for GPE %d: %s\n",
+				applespi->gpe, acpi_format_exception(acpi_sts));
+			return -ENODEV;
+		}
 
-	acpi_sts = acpi_enable_gpe(NULL, applespi->gpe);
-	if (ACPI_FAILURE(acpi_sts)) {
-		dev_err(&applespi->spi->dev,
-			"Failed to enable GPE handler for GPE %d: %s\n",
-			applespi->gpe, acpi_format_exception(acpi_sts));
-		acpi_remove_gpe_handler(NULL, applespi->gpe, applespi_notify);
-		return -ENODEV;
+		applespi->suspended = false;
+
+		acpi_sts = acpi_enable_gpe(NULL, applespi->gpe);
+		if (ACPI_FAILURE(acpi_sts)) {
+			dev_err(&applespi->spi->dev,
+				"Failed to enable GPE handler for GPE %d: %s\n",
+				applespi->gpe, acpi_format_exception(acpi_sts));
+			acpi_remove_gpe_handler(NULL, applespi->gpe, applespi_notify);
+			return -ENODEV;
+		}
+#endif
 	}
 
 	/* trigger touchpad setup */
@@ -1865,8 +2022,13 @@ static int applespi_remove(struct spi_device *spi)
 
 	applespi_drain_writes(applespi);
 
-	acpi_disable_gpe(NULL, applespi->gpe);
-	acpi_remove_gpe_handler(NULL, applespi->gpe, applespi_notify);
+	if (applespi->of_mode) {
+	} else {
+#ifdef CONFIG_ACPI
+		acpi_disable_gpe(NULL, applespi->gpe);
+		acpi_remove_gpe_handler(NULL, applespi->gpe, applespi_notify);
+#endif
+	}
 	device_wakeup_disable(&spi->dev);
 
 	applespi_drain_reads(applespi);
@@ -1897,7 +2059,6 @@ static int __maybe_unused applespi_suspend(struct device *dev)
 {
 	struct spi_device *spi = to_spi_device(dev);
 	struct applespi_data *applespi = spi_get_drvdata(spi);
-	acpi_status acpi_sts;
 	int sts;
 
 	/* turn off caps-lock - it'll stay on otherwise */
@@ -1909,11 +2070,17 @@ static int __maybe_unused applespi_suspend(struct device *dev)
 	applespi_drain_writes(applespi);
 
 	/* disable the interrupt */
-	acpi_sts = acpi_disable_gpe(NULL, applespi->gpe);
-	if (ACPI_FAILURE(acpi_sts))
-		dev_err(&applespi->spi->dev,
-			"Failed to disable GPE handler for GPE %d: %s\n",
-			applespi->gpe, acpi_format_exception(acpi_sts));
+	if (applespi->of_mode) {
+	} else {
+#ifdef CONFIG_ACPI
+		acpi_status acpi_sts;
+		acpi_sts = acpi_disable_gpe(NULL, applespi->gpe);
+		if (ACPI_FAILURE(acpi_sts))
+			dev_err(&applespi->spi->dev,
+				"Failed to disable GPE handler for GPE %d: %s\n",
+				applespi->gpe, acpi_format_exception(acpi_sts));
+#endif
+	}
 
 	applespi_drain_reads(applespi);
 
@@ -1924,7 +2091,6 @@ static int __maybe_unused applespi_resume(struct device *dev)
 {
 	struct spi_device *spi = to_spi_device(dev);
 	struct applespi_data *applespi = spi_get_drvdata(spi);
-	acpi_status acpi_sts;
 	unsigned long flags;
 
 	/* ensure our flags and state reflect a newly resumed device */
@@ -1945,11 +2111,17 @@ static int __maybe_unused applespi_resume(struct device *dev)
 	applespi_enable_spi(applespi);
 
 	/* re-enable the interrupt */
-	acpi_sts = acpi_enable_gpe(NULL, applespi->gpe);
-	if (ACPI_FAILURE(acpi_sts))
-		dev_err(&applespi->spi->dev,
-			"Failed to re-enable GPE handler for GPE %d: %s\n",
-			applespi->gpe, acpi_format_exception(acpi_sts));
+	if (applespi->of_mode) {
+	} else {
+#ifdef CONFIG_ACPI
+		acpi_status acpi_sts;
+		acpi_sts = acpi_enable_gpe(NULL, applespi->gpe);
+		if (ACPI_FAILURE(acpi_sts))
+			dev_err(&applespi->spi->dev,
+				"Failed to re-enable GPE handler for GPE %d: %s\n",
+				applespi->gpe, acpi_format_exception(acpi_sts));
+#endif
+	}
 
 	/* switch the touchpad into multitouch mode */
 	applespi_init(applespi, true);
@@ -1963,6 +2135,12 @@ static const struct acpi_device_id applespi_acpi_match[] = {
 };
 MODULE_DEVICE_TABLE(acpi, applespi_acpi_match);
 
+static const struct of_device_id applespi_of_match[] = {
+	{ .compatible = "input,applespi-kbd-v1" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, applespi_of_match);
+
 static const struct dev_pm_ops applespi_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(applespi_suspend, applespi_resume)
 	.poweroff_late	= applespi_poweroff_late,
@@ -1972,6 +2150,7 @@ static struct spi_driver applespi_driver = {
 	.driver		= {
 		.name			= "applespi",
 		.acpi_match_table	= applespi_acpi_match,
+		.of_match_table		= applespi_of_match,
 		.pm			= &applespi_pm_ops,
 	},
 	.probe		= applespi_probe,
-- 
2.34.0


From 0494f4a92bb72949c05f8f44db740c95d499d09a Mon Sep 17 00:00:00 2001
From: Joey Gouly <joey.gouly@arm.com>
Date: Sat, 14 Aug 2021 09:49:26 +0000
Subject: [PATCH 81/83] input: applespi: don't manually set the direction of
 the GPIO irq

The following chain of calls with end up with the pin being set:
  devm_request_irq ->
    __irq_setup ->
      irq_startup ->
        apple_gpio_gpio_irq_startup

Signed-off-by: Joey Gouly <joey.gouly@arm.com>
---
 drivers/input/keyboard/applespi.c | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/drivers/input/keyboard/applespi.c b/drivers/input/keyboard/applespi.c
index 9cae4b9fb36a..596a9569fec6 100644
--- a/drivers/input/keyboard/applespi.c
+++ b/drivers/input/keyboard/applespi.c
@@ -1890,15 +1890,6 @@ static int applespi_probe(struct spi_device *spi)
 
 	if(of_mode) {
 #ifdef CONFIG_OF
-		applespi->irqgpio = devm_gpiod_get_index(&spi->dev, "irq", 0, 0);
-		if(IS_ERR(applespi->irqgpio)) {
-			sts = PTR_ERR(applespi->irqgpio);
-			if(sts != -EPROBE_DEFER)
-				dev_err(&spi->dev, "failed to get irq gpio: %d\n", sts);
-			return sts;
-		}
-		gpiod_direction_input(applespi->irqgpio);
-
 		applespi->suspended = false;
 		applespi->gpioirq_enabled = true;
 
-- 
2.34.0


From ba686f741cd8dab4e4001c5d745d92ae8fe35d1a Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Thu, 11 Nov 2021 21:31:21 +0100
Subject: [PATCH 82/83] arm64: dts: apple: t6001: Add spi3/keyboard nodes

Enables keyboard and touchpad input on MacBook Pro (14/16-inch,
M1 Pro/Max, 2021).

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t6001.dtsi           | 12 ++++++++++++
 arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi | 10 ++++++++++
 2 files changed, 22 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t6001.dtsi b/arch/arm64/boot/dts/apple/t6001.dtsi
index 0804e9296071..f7f24455e576 100644
--- a/arch/arm64/boot/dts/apple/t6001.dtsi
+++ b/arch/arm64/boot/dts/apple/t6001.dtsi
@@ -397,6 +397,18 @@ i2c5: i2c@39b054000 {
 			status = "disabled";
 		};
 
+		spi3: spi@39b10c000 {
+			compatible = "apple,spi-mc-m1";
+			reg = <0x3 0x9b10c000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 0 1109 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkref>;
+			cs-gpios = <&pinctrl_ap 55 0>;
+			power-domains = <&ps_spi3>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
 		pcie0_dart_0: dart@581008000 {
 			compatible = "apple,t6000-dart";
 			reg = <0x5 0x81008000 0x0 0x4000>;
diff --git a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
index 219b53badcea..4bc3713cc9b8 100644
--- a/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
+++ b/arch/arm64/boot/dts/apple/t600x-j314-j316.dtsi
@@ -130,6 +130,16 @@ hpm5: usb-pd@3a {
 	};
 };
 
+&spi3 {
+	keyboard@0 {
+		compatible = "input,applespi-kbd-v1";
+		reg = <0>;
+		spi-max-frequency = <2000000>;
+		spien-gpios = <&pinctrl_ap 194 0>;
+		interrupts-extended = <&pinctrl_nub 6 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
 /* PCIe devices */
 &port00 {
 	/* WLAN */
-- 
2.34.0


From 183c830664ca7d454b022224b59b22de2ffd7d3d Mon Sep 17 00:00:00 2001
From: Janne Grunau <j@jannau.net>
Date: Fri, 26 Nov 2021 00:24:15 +0100
Subject: [PATCH 83/83] arm64: dts: apple: t8103: Add spi3/keyboard nodes

Enables keyboard and touchpad input on MacBook Air (M1, 2020) and
MacBook Pro (13-inch, M1, 2020).

Signed-off-by: Janne Grunau <j@jannau.net>
---
 arch/arm64/boot/dts/apple/t8103-j293.dts | 12 ++++++++++++
 arch/arm64/boot/dts/apple/t8103-j313.dts | 12 ++++++++++++
 arch/arm64/boot/dts/apple/t8103.dtsi     | 13 +++++++++++++
 3 files changed, 37 insertions(+)

diff --git a/arch/arm64/boot/dts/apple/t8103-j293.dts b/arch/arm64/boot/dts/apple/t8103-j293.dts
index 6f08fd64f482..eff0a1731473 100644
--- a/arch/arm64/boot/dts/apple/t8103-j293.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j293.dts
@@ -29,6 +29,18 @@ &typec1 {
 	label = "USB-C Left-front";
 };
 
+&spi3 {
+	status = "okay";
+
+	keyboard@0 {
+		compatible = "input,applespi-kbd-v1";
+		reg = <0>;
+		spi-max-frequency = <2000000>;
+		spien-gpios = <&pinctrl_ap 195 0>;
+		interrupts-extended = <&pinctrl_nub 13 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
 /*
  * Remove unused PCIe ports and disable the associated DARTs.
  */
diff --git a/arch/arm64/boot/dts/apple/t8103-j313.dts b/arch/arm64/boot/dts/apple/t8103-j313.dts
index 114aa87c8cb4..a5cde6150e58 100644
--- a/arch/arm64/boot/dts/apple/t8103-j313.dts
+++ b/arch/arm64/boot/dts/apple/t8103-j313.dts
@@ -29,6 +29,18 @@ &typec1 {
 	label = "USB-C Left-front";
 };
 
+&spi3 {
+	status = "okay";
+
+	keyboard@0 {
+		compatible = "input,applespi-kbd-v1";
+		reg = <0>;
+		spi-max-frequency = <2000000>;
+		spien-gpios = <&pinctrl_ap 195 0>;
+		interrupts-extended = <&pinctrl_nub 13 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
 /*
  * Remove unused PCIe ports and disable the associated DARTs.
  */
diff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi
index 0fdd9945041a..bbd1894545cd 100644
--- a/arch/arm64/boot/dts/apple/t8103.dtsi
+++ b/arch/arm64/boot/dts/apple/t8103.dtsi
@@ -179,6 +179,19 @@ i2c4: i2c@235020000 {
 			status = "disabled"; /* only used in J293 */
 		};
 
+		spi3: spi@23510c000 {
+			compatible = "apple,spi-mc-m1";
+			reg = <0x2 0x3510c000 0x0 0x4000>;
+			interrupt-parent = <&aic>;
+			interrupts = <AIC_IRQ 617 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkref>;
+			cs-gpios = <&pinctrl_ap 49 0>;
+			power-domains = <&ps_spi3>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled"; /* only used in J293/J313 */
+		};
+
 		serial0: serial@235200000 {
 			compatible = "apple,s5l-uart";
 			reg = <0x2 0x35200000 0x0 0x1000>;
-- 
2.34.0

